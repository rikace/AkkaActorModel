<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Akka</name>
    </assembly>
    <members>
        <member name="T:Akka.Actor.IActorState">
            <summary>
            This interface represents the parts of the internal actor state; the behavior stack, watched by, watching and termination queue
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorState.RemoveWatching(Akka.Actor.IActorRef)">
            <summary>
            Removes the provided <see cref="T:Akka.Actor.IActorRef"/> from the `Watching` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be removed</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.RemoveWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            Removes the provided <see cref="T:Akka.Actor.IActorRef"/> from the `WatchedBy` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be removed</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.RemoveTerminated(Akka.Actor.IActorRef)">
            <summary>
            Removes the provided <see cref="T:Akka.Actor.IActorRef"/> from the `Termination queue` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be removed</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.AddWatching(Akka.Actor.IActorRef)">
            <summary>
            Adds the provided <see cref="T:Akka.Actor.IActorRef"/> to the `Watching` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be added</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.AddWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            Adds the provided <see cref="T:Akka.Actor.IActorRef"/> to the `WatchedBy` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be added</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.AddTerminated(Akka.Actor.IActorRef)">
            <summary>
            Adds the provided <see cref="T:Akka.Actor.IActorRef"/> to the `Termination queue` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be added</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ClearWatching">
            <summary>
            Clears the `Watching` set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ClearTerminated">
            <summary>
            Clears the `Termination queue` set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ClearBehaviorStack">
            <summary>
            Clears the `Behavior` stack
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.Become(Akka.Actor.Receive)">
            <summary>
            Replaces the current receive behavior with a new behavior
            </summary>
            <param name="receive">The new behavior</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.BecomeStacked(Akka.Actor.Receive)">
            <summary>
            Pushes a new receive behavior onto the `Behavior` stack
            </summary>
            <param name="receive">The new top level behavior</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.UnbecomeStacked">
            <summary>
            Removes the top level receive behavior from the `Behavior` stack
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ContainsWatching(Akka.Actor.IActorRef)">
            <summary>
            Determines whether the provided <see cref="T:Akka.Actor.IActorRef"/> is present in the `Watching` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to locate in the `Watching` set</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ContainsWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            Determines whether the provided <see cref="T:Akka.Actor.IActorRef"/> is present in the `WatchedBy` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to locate in the `WatchedBy` set</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ContainsTerminated(Akka.Actor.IActorRef)">
            <summary>
            Determines whether the provided <see cref="T:Akka.Actor.IActorRef"/> is present in the `Termination queue` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to locate in the `Termination queue` set</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.GetWatching">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> over the `Watching` set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.GetWatchedBy">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> over the `WatchedBy` set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.Getterminated">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> over the `Termination queue` set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.GetCurrentBehavior">
            <summary>
            Returns the top level receive behavior from the behavior stack
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akka.Actor.DefaultActorState">
            <summary>
            Represents the default start up state for any actor.
            This state provides capacity for one `WatchedBy` and one `Receive` behavior
            As soon as this container is no longer enough to contain the current state
            The state container will escalate into a `FullActorState` instance
            </summary>
        </member>
        <member name="T:Akka.Actor.FullActorState">
            <summary>
            Represents the full state of an actor, this is used whenever an actor need more state than the `DefaultActorState` container can contain
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorCell">
            <summary>
                Class ActorCell.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.WatchedActorTerminated(Akka.Actor.IActorRef,System.Boolean,System.Boolean)">
            <summary>
            When this actor is watching the subject of <see cref="T:Akka.Actor.Terminated"/> message
            it will be propagated to user's receive.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.MaintainAddressTerminatedSubscription(System.Action,Akka.Actor.IActorRef)">
            <summary>
            Starts subscription to AddressTerminated if not already subscribing and the
            block adds a non-local ref to watching or watchedBy.
            Ends subscription to AddressTerminated if subscribing and the
            block removes the last non-local ref from watching and watchedBy.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.FaultRecreate(System.Exception)">
            <summary>Re-create the actor in response to a failure.</summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.FaultSuspend">
            <summary>
            Suspends the actor in response to a failure of a parent (i.e. the "recursive suspend" feature).
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.FaultResume(System.Exception)">
            <summary>
            Resumes the actor in response to a failure
            </summary>
            <param name="causedByFailure">The exception that caused the failure. signifies if it was our own failure 
            which prompted this action.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.FaultCreate">
            <summary>
            Create the actor in response to a failure
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Terminate">
            <summary>Terminates this instance.</summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.HandleNonFatalOrInterruptedException(System.Action)">
            <summary>
                Handles the non fatal or interrupted exception.
            </summary>
            <param name="action">The action.</param>
        </member>
        <member name="F:Akka.Actor.ActorCell._self">
            <summary>NOTE! Only constructor and ClearActorFields is allowed to update this</summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.ActorType">
            <summary>
                Gets the type of the actor.
            </summary>
            <value>The type of the actor.</value>
        </member>
        <member name="M:Akka.Actor.ActorCell.Invoke(Akka.Actor.Envelope)">
            <summary>
                Invokes the specified envelope.
            </summary>
            <param name="envelope">The envelope.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.MatchSender(Akka.Actor.Envelope)">
            <summary>
            If the envelope.Sender property is null, then we'll substitute
            Deadletters as the <see cref="P:Akka.Actor.ActorCell.Sender"/> of this message.
            </summary>
            <param name="envelope">The envelope we received</param>
            <returns>An IActorRef that corresponds to a Sender</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.ReceiveMessageForTest(Akka.Actor.Envelope)">
            <summary>
            This is only intended to be called from TestKit's TestActorRef
            </summary>
            <param name="envelope"></param>
        </member>
        <member name="M:Akka.Actor.ActorCell.ReceiveSelection(Akka.Actor.ActorSelectionMessage)">
            <summary>   
                Receives the selection.
            </summary>
            <param name="m">The m.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.SystemInvoke(Akka.Actor.Envelope)">
            <summary>
                Systems the invoke.
            </summary>
            <param name="envelope">The envelope.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.Publish(Akka.Event.LogEvent)">
            <summary>
                Publishes the specified event.
            </summary>
            <param name="event">The event.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.HandleIdentity(Akka.Actor.Identify)">
            <summary>
                Handles the identity.
            </summary>
            <param name="m">The m.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.HandlePoisonPill">
            <summary>
                Handles the poison pill.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Restart(System.Exception)">
            <summary>
                Restarts the specified cause.
            </summary>
            <param name="cause">The cause.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.Start">
            <summary>
                Starts this instance.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.PreStart">
            <summary>
            Allow extra pre-start initialization in derived classes
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Resume(System.Exception)">
            <summary>
                Resumes the specified caused by failure.
            </summary>
            <param name="causedByFailure">The caused by failure.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.Stop">
            <summary>
                Async stop this actor
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Suspend">
            <summary>
                Suspends this instance.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Kill">
            <summary>
                Kills this instance.
            </summary>
            <exception cref="T:Akka.Actor.ActorKilledException">Kill</exception>
        </member>
        <member name="M:Akka.Actor.ActorCell.Stop(Akka.Actor.IActorRef)">
            <summary>
                Stops the specified child.
            </summary>
            <param name="child">The child.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.UpdateChildrenRefs``1(System.Func{Akka.Actor.Internal.IChildrenContainer,System.Tuple{System.Boolean,Akka.Actor.Internal.IChildrenContainer,``0}})">
            <summary>
            Swaps out the children container, by calling <paramref name="updater"/>  to produce the new container.
            If the underlying container has been updated while <paramref name="updater"/> was called,
            <paramref name="updater"/> will be called again with the new container. This will repeat until the 
            container can be swapped out, or until <see cref="P:System.Tuple`3.Item1"/> contains <c>false</c>.
            <para>The returned tuple should contain:</para>
            <para>Item1: <c>true</c> if the container should be updated; <c>false</c> to not update and return Item3</para>
            <para>Item2: The new container (will only be used if Item1=<c>true</c>)</para>
            <para>Item3: The return value</para>
            </summary>
            <param name="updater">A function that returns a new container.</param>
            <returns>The third value of the tuple that <paramref name="updater"/> returned.</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.UpdateChildrenRefs(System.Func{Akka.Actor.Internal.IChildrenContainer,Akka.Actor.Internal.IChildrenContainer})">
            <summary>
            Swaps out the children container, by calling <paramref name="updater" />  to produce the new container.
            If the underlying container has been updated while <paramref name="updater" /> was called,
            <paramref name="updater" /> will be called again with the new container. This will repeat until the
            container can be swapped out.
            </summary>
            <param name="updater">A function that returns a new container.</param>
            <returns>The new updated <see cref="P:Akka.Actor.ActorCell.ChildrenContainer"/></returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.InitChild(Akka.Actor.IInternalActorRef)">
            <summary>This should only be used privately or when creating the root actor. </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.SuspendChildren(System.Collections.Generic.List{Akka.Actor.IActorRef})">
            <summary>
                Suspends the children.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.ResumeChildren(System.Exception,Akka.Actor.IActorRef)">
            <summary>
                Resumes the children.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.TryGetChildStatsByName(System.String,Akka.Actor.Internal.IChildStats@)">
            <summary>
            Tries to get the stats for the child with the specified name. The stats can be either <see cref="T:Akka.Actor.Internal.ChildNameReserved"/> 
            indicating that only a name has been reserved for the child, or a <see cref="T:Akka.Actor.Internal.ChildRestartStats"/> for a child that 
            has been initialized/created.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.TryGetChildRestartStatsByName(System.String,Akka.Actor.Internal.ChildRestartStats@)">
            <summary>
            Tries to get the stats for the child with the specified name. This ignores children for whom only names have been reserved.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.TryGetChildStatsByRef(Akka.Actor.IActorRef,Akka.Actor.Internal.ChildRestartStats@)">
            <summary>
            Tries to get the stats for the specified child.
            <remarks>Since the child exists <see cref="T:Akka.Actor.Internal.ChildRestartStats"/> is the only valid <see cref="T:Akka.Actor.Internal.IChildStats"/>.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.IActorProducerPlugin">
            <summary>
            Plugin interface used to define
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorProducerPlugin.CanBeAppliedTo(System.Type)">
            <summary>
            Determines if current plugin can be applied to provided actor based on it's type.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorProducerPlugin.AfterIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to underlying <paramref name="actor"/> instance when the new one is being created.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorProducerPlugin.BeforeIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to underlying <paramref name="actor"/> instance before the actor is being recycled.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorProducerPluginBase">
            <summary>
            Base actor producer pipeline plugin class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase.CanBeAppliedTo(System.Type)">
            <summary>
            By default derivatives of this plugin will be applied to all actors.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase.AfterIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to <paramref name="actor"/> instance when the new one is being created.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase.BeforeIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to <paramref name="actor"/> instance before the actor is being recycled.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorProducerPluginBase`1">
            <summary>
            Base generic actor producer pipeline plugin class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase`1.CanBeAppliedTo(System.Type)">
            <summary>
            By default derivatives of this plugin will be applied to all actors inheriting from <typeparamref name="TActor">actor generic type</typeparamref>.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase`1.AfterIncarnated(`0,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to <paramref name="actor"/> instance when the new one is being created.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase`1.BeforeIncarnated(`0,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to <paramref name="actor"/> instance before the actor is being recycled.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorProducerPipelineResolver">
            <summary>
            Class used to resolving actor producer pipelines depending on actor type.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorProducerPipelineResolver.TotalPluginCount">
            <summary>
            Gets total number of unique plugins registered inside current resolver.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.Register(Akka.Actor.IActorProducerPlugin)">
            <summary>
            Register target <paramref name="plugin"/> at the end of producer pipeline.
            </summary>
            <returns>True if plugin was registered (it has not been found in pipeline already). False otherwise. </returns>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.Insert(System.Int32,Akka.Actor.IActorProducerPlugin)">
            <summary>
            Register target <paramref name="plugin"/> inside producer pipeline at specified <paramref name="index"/>.
            </summary>
            <returns>True if plugin was registered (it has not been found in pipeline already). False otherwise. </returns>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.Unregister(Akka.Actor.IActorProducerPlugin)">
            <summary>
            Unregisters plugin from producer pipeline, returning false if plugin was not found.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.IsRegistered(Akka.Actor.IActorProducerPlugin)">
            <summary>
            Returns true if current actor producer pipeline already has registered provided plugin type.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipeline.AfterActorIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Resolves and applies all plugins valid to specified underlying <paramref name="actor"/> 
            registered in current producer pipeline to newly created actor.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipeline.BeforeActorIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Resolves and applies all plugins valid to specified underlying <paramref name="actor"/> 
            registered in current producer pipeline before old actor would be recycled.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.ChildRestartStats">
            <summary>
            ChildRestartStats is the statistics kept by every parent Actor for every child Actor
            and is used for SupervisorStrategies to know how to deal with problems that occur for the children.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.EmptyChildrenContainer">
            <summary>
            This is the empty container, shared among all leaf actors.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.NormalChildrenContainer">
            <summary>
            Normal children container: we do have at least one child, but none of our
            children are currently terminating (which is the time period between calling
            context.stop(child) and processing the ChildTerminated() system message).
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.IWaitingForChildren">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.Creation">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.Recreation">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.Termination">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.UserRequest">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.TerminatedChildrenContainer">
            <summary>
            This is the empty container which is installed after the last child has
            terminated while stopping; it is necessary to distinguish from the normal
            empty state while calling handleChildTerminated() for the last time.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.TerminatingChildrenContainer">
            <summary>
            Waiting state: there are outstanding termination requests (i.e. context.stop(child)
            was called but the corresponding ChildTerminated() system message has not yet been
            processed). There could be no specific reason (UserRequested), we could be Restarting
            or Terminating.
            Removing the last child which was supposed to be terminating will return a different
            type of container, depending on whether or not children are left and whether or not
            the reason was “Terminating”.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.InternalCurrentActorCellKeeper">
            <summary>INTERNAL!
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.InternalCurrentActorCellKeeper.Current">
            <summary>INTERNAL!
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.IInternalSupportsTestFSMRef`2">
            <summary>
            INTERNAL API. Used for testing.
            This is used to let TestFSMRef in TestKit access to internal methods.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.IInternalSupportsTestFSMRef`2.ApplyState(Akka.Actor.FSMBase.State{`0,`1})">
            <summary>
            INTERNAL API. Used for testing.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.IInternalSupportsTestFSMRef`2.IsStateTimerActive">
            <summary>
            INTERNAL API. Used for testing.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.InternalActivateFsmLogging">
            <summary>
            INTERNAL API. Used for testing.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.InternalActivateFsmLogging.Instance">
            <summary>
            INTERNAL API. Used for testing.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.IInitializableActor">
            <summary>
            Marks that the actor needs to be initialized directly after it has been created.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.ActorSystemImpl">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.SystemActorOf(Akka.Actor.Props,System.String)">
            <summary>Creates a new system actor.</summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.SystemActorOf``1(System.String)">
            <summary>Creates a new system actor.</summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.Start">
            <summary>Starts this system</summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.LoadExtensions">
            <summary>
            Load all of the extensions registered in the <see cref="P:Akka.Actor.ActorSystem.Settings"/>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.ConfigureSettings(Akka.Configuration.Config)">
            <summary>
                Configures the settings.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.ConfigureEventStream">
            <summary>
                Configures the event stream.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.ConfigureSerialization">
            <summary>
                Configures the serialization.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.ConfigureMailboxes">
            <summary>
                Configures the mailboxes.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.ConfigureProvider">
            <summary>
                Configures the provider.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.ConfigureLoggers">
            <summary>
            Extensions depends on loggers being configured before Start() is called
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.ConfigureDispatchers">
            <summary>
                Configures the dispatchers.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.ConfigureActorProducerPipeline">
            <summary>
            Configures the actor producer pipeline.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.ConfigureTerminationCallbacks">
            <summary>
            Configures the termination callbacks.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.RegisterOnTermination(System.Action)">
            <summary>
            Register a block of code (callback) to run after ActorSystem.shutdown has been issued and
            all actors in this actor system have been stopped.
            Multiple code blocks may be registered by calling this method multiple times.
            The callbacks will be run sequentially in reverse order of registration, i.e.
            last registration is run first.
            </summary>
            <param name="code">The code to run</param>
            <exception cref="T:System.Exception">Thrown if the System has already shut down or if shutdown has been initiated.</exception>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.Shutdown">
            <summary>
                Stop this actor system. This will stop the guardian actor, which in turn
                will recursively stop all its child actors, then the system guardian
                (below which the logging actors reside) and the execute all registered
                termination handlers (<see cref="M:Akka.Actor.ActorSystem.RegisterOnTermination(System.Action)" />).
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.Terminate">
            <summary>
            Terminates this actor system. This will stop the guardian actor, which in turn
            will recursively stop all its child actors, then the system guardian
            (below which the logging actors reside) and the execute all registered
            termination handlers (<see cref="M:Akka.Actor.ActorSystem.RegisterOnTermination(System.Action)" />).
            Be careful to not schedule any operations on completion of the returned task
            using the `dispatcher` of this actor system as it will have been shut down before the
            task completes.
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.WhenTerminated">
            <summary>
            Returns a task which will be completed after the ActorSystem has been terminated
            and termination hooks have been executed. Be careful to not schedule any operations
            on the `dispatcher` of this actor system as it will have been shut down before this
            task completes.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.AbstractStash">
            <summary>INTERNAL
            Abstract base class for stash support
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.#ctor(Akka.Actor.IActorContext,System.Int32)">
            <summary>INTERNAL
            Abstract base class for stash support
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.Stash">
            <summary>
            Stashes the current message in the actor's state.
            </summary>
            <exception cref="T:Akka.Actor.IllegalActorStateException">Thrown if we attempt to stash the same message more than once.</exception>
            <exception cref="T:Akka.Actor.StashOverflowException">Thrown in the event that we're using a <see cref="T:Akka.Dispatch.MessageQueues.BoundedMessageQueue"/> 
            for the <see cref="T:Akka.Actor.IStash"/> and we've exceeded capacity.</exception>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.Unstash">
            <summary>
            Unstash the most recently stashed message (top of the message stack.)
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.UnstashAll">
            <summary>
            Unstash all of the <see cref="T:Akka.Actor.Envelope"/>s in the Stash.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.UnstashAll(System.Func{Akka.Actor.Envelope,System.Boolean})">
            <summary>
            Unstash all of the <see cref="T:Akka.Actor.Envelope"/>s in the Stash.
            </summary>
            <param name="predicate">A predicate function to determine which messages to select.</param>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.ClearStash">
            <summary>
            Eliminates the contents of the <see cref="T:Akka.Actor.IStash"/>, and returns
            the previous contents of the messages.
            </summary>
            <returns>Previously stashed messages.</returns>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.EnqueueFirst(Akka.Actor.Envelope)">
            <summary>
            Enqueues <paramref name="msg"/> at the first position in the mailbox. If the message contained in
            the envelope is a <see cref="T:Akka.Actor.Terminated"/> message, it will be ensured that it can be re-received
            by the actor.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.BoundedStashImpl">
            <summary>INTERNAL
            A stash implementation that is bounded
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.BoundedStashImpl.#ctor(Akka.Actor.IActorContext,System.Int32)">
            <summary>INTERNAL
            A stash implementation that is bounded
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.UnboundedStashImpl">
            <summary>INTERNAL
            A stash implementation that is unbounded
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.UnboundedStashImpl.#ctor(Akka.Actor.IActorContext)">
            <summary>INTERNAL
            A stash implementation that is bounded
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.AlreadyCanceledCancelable">
            <summary>
            A <see cref="T:Akka.Actor.ICancelable"/> that is already canceled.
            </summary>
        </member>
        <member name="M:Akka.Actor.CancelableExtensions.CancelIfNotNull(Akka.Actor.ICancelable)">
            <summary>
            If <paramref name="cancelable"/> is not <c>null</c> it's canceled.
            </summary>
            <param name="cancelable">The cancelable. Will be canceled if it's not <c>null</c></param>
        </member>
        <member name="T:Akka.Actor.Cancelable">
            <summary>
            A <see cref="T:Akka.Actor.ICancelable"/> that wraps a <see cref="T:System.Threading.CancellationTokenSource"/>. 
            When canceling this instance the underlying <see cref="T:System.Threading.CancellationTokenSource"/> is canceled as well.
            </summary>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IActionScheduler,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class that will be cancelled after the specified amount of time.
            </summary>
            <param name="scheduler">The scheduler.</param>
            <param name="delay">The delay before the cancelable is canceled.</param>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IScheduler,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class that will be cancelled after the specified amount of time.
            </summary>
            <param name="scheduler">The scheduler.</param>
            <param name="delay">The delay before the cancelable is canceled.</param>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IScheduler,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class that will be cancelled after the specified amount of milliseconds.
            </summary>
            <param name="scheduler">The scheduler.</param>
            <param name="millisecondsDelay">The delay in milliseconds.</param>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class.
            </summary>
            <param name="scheduler"></param>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IActionScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class.
            </summary>
            <param name="scheduler"></param>
        </member>
        <member name="M:Akka.Actor.Cancelable.CreateCanceled">
            <summary>
            Returns a <see cref="T:Akka.Actor.ICancelable"/> that has already been canceled.
            </summary>
        </member>
        <member name="M:Akka.Actor.Cancelable.CreateLinkedCancelable(Akka.Actor.IScheduler,Akka.Actor.ICancelable[])">
            <summary>
            Creates a <see cref="T:Akka.Actor.ICancelable"/> that will be in the canceled state
            when any of the source cancelables are in the canceled state. 
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="cancelables">The cancelables instances to observe.</param>
            <returns>A new <see cref="T:Akka.Actor.ICancelable"/> that is linked to the source .</returns>
        </member>
        <member name="M:Akka.Actor.Cancelable.CreateLinkedCancelable(Akka.Actor.IActionScheduler,Akka.Actor.ICancelable[])">
            <summary>
            Creates a <see cref="T:Akka.Actor.ICancelable"/> that will be in the canceled state
            when any of the source cancelables are in the canceled state. 
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="cancelables">The cancelables instances to observe.</param>
            <returns>A new <see cref="T:Akka.Actor.ICancelable"/> that is linked to the source .</returns>
        </member>
        <member name="M:Akka.Actor.Cancelable.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="M:Akka.Actor.Cancelable.Dispose(System.Boolean)">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
            <param name="disposing">if set to <c>true</c> the method has been called directly or indirectly by a 
            user's code. Managed and unmanaged resources will be disposed.<br />
            if set to <c>false</c> the method has been called by the runtime from inside the finalizer and only 
            unmanaged resources can be disposed.</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.Become(System.Action{System.Object,Akka.Actor.IActorContext})">
            <summary>
            Changes the actor's behavior and replaces the current handler with the specified handler.
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.BecomeStacked(System.Action{System.Object,Akka.Actor.IActorContext})">
            <summary>
            Changes the actor's behavior and replaces the current handler with the specified handler without discarding the current.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.Dsl.IActorDsl.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.Dsl.IActorDsl.BecomeStacked(System.Action{System.Object,Akka.Actor.IActorContext})"/>
            is matched with a call to <see cref="M:Akka.Actor.Dsl.IActorDsl.UnbecomeStacked"/>.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.UnbecomeStacked">
            <summary>
            Changes the actor's behavior and replaces the current handler with the previous one on the behavior stack.
            <remarks>In order to store an actor on the behavior stack, a call to <see cref="M:Akka.Actor.Dsl.IActorDsl.BecomeStacked(System.Action{System.Object,Akka.Actor.IActorContext})"/> must have been made
            prior to this call</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.ICancelable">
            <summary>
            Signifies something that can be canceled
            </summary>
        </member>
        <member name="M:Akka.Actor.ICancelable.Cancel">
            <summary>
            Communicates a request for cancellation.
            </summary>
            <remarks>The associated cancelable will be notified of the cancellation and will transition to a state where 
            <see cref="P:Akka.Actor.ICancelable.IsCancellationRequested"/> returns <c>true</c>.
            Any callbacks or cancelable operations registered with the cancelable will be executed.
            Cancelable operations and callbacks registered with the token should not throw exceptions.
            However, this overload of Cancel will aggregate any exceptions thrown into an 
            <see cref="T:System.AggregateException"/>, such that one callback throwing an exception will not 
            prevent other registered callbacks from being executed.
            The <see cref="T:System.Threading.ExecutionContext"/> that was captured when each callback was registered will 
            be reestablished when the callback is invoked.</remarks>
        </member>
        <member name="P:Akka.Actor.ICancelable.IsCancellationRequested">
            <summary>
            Gets a value indicating whether cancellation has been requested
            </summary>
        </member>
        <member name="M:Akka.Actor.ICancelable.CancelAfter(System.TimeSpan)">
            <summary>
            Schedules a cancel operation on this cancelable after the specified delay.
            </summary>
            <param name="delay">The delay before this instance is canceled.</param>
        </member>
        <member name="M:Akka.Actor.ICancelable.CancelAfter(System.Int32)">
            <summary>
            Schedules a cancel operation on this cancelable after the specified number of milliseconds.
            </summary>
            <param name="millisecondsDelay">The delay in milliseconds before this instance is canceled.</param>
        </member>
        <member name="M:Akka.Actor.ICancelable.Cancel(System.Boolean)">
            <summary>
            Communicates a request for cancellation, and specifies whether remaining callbacks and cancelable operations should be processed.
            </summary>
            <param name="throwOnFirstException"><c>true</c> if exceptions should immediately propagate; otherwise, <c>false</c>.</param>
            <remarks>The associated cancelable will be notified of the cancellation and will transition to a state where 
            <see cref="P:Akka.Actor.ICancelable.IsCancellationRequested"/> returns <c>true</c>.
            Any callbacks or cancelable operations registered with the cancelable will be executed.
            Cancelable operations and callbacks registered with the token should not throw exceptions.
            If <paramref name="throwOnFirstException"/> is <c>true</c>, an exception will immediately propagate out of 
            the call to Cancel, preventing the remaining callbacks and cancelable operations from being processed.
            If <paramref name="throwOnFirstException"/> is <c>false</c>, this overload will aggregate any exceptions 
            thrown into an <see cref="T:System.AggregateException"/>, such that one callback throwing an exception will not 
            prevent other registered callbacks from being executed.
            The <see cref="T:System.Threading.ExecutionContext"/> that was captured when each callback was registered will be reestablished when the callback is invoked.</remarks>
        </member>
        <member name="T:Akka.Actor.IDateTimeOffsetNowTimeProvider">
            <summary>
            Marks that an <see cref="T:Akka.Actor.ITimeProvider"/> uses <see cref="P:System.DateTimeOffset.UtcNow"/>, 
            i.e. system time, to provide <see cref="P:Akka.Actor.ITimeProvider.Now"/>.
            </summary>
        </member>
        <member name="P:Akka.Actor.ITimeProvider.Now">
            <summary>
            Gets the scheduler's notion of current time.
            </summary>
        </member>
        <member name="T:Akka.Actor.IActionScheduler">
            <summary>
            A scheduler able of scheduling actions
            </summary>
        </member>
        <member name="M:Akka.Actor.IActionScheduler.ScheduleOnce(System.TimeSpan,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Schedules an action to be invoked after an delay.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor.
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="delay">The time period that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <param name="cancelable">A cancelable that can be used to cancel the action from being executed</param>
        </member>
        <member name="M:Akka.Actor.IActionScheduler.ScheduleOnce(System.TimeSpan,System.Action)">
            <summary>
            Schedules an action to be invoked after an delay.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor.
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="delay">The time period that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Akka.Actor.IActionScheduler.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="initialDelay">The time period that has to pass before first invocation.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <param name="cancelable">A cancelable that can be used to cancel the action from being executed</param>
        </member>
        <member name="M:Akka.Actor.IActionScheduler.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="initialDelay">The time period that has to pass before first invocation.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between the action is invoked.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="P:Akka.Actor.IScheduler.Advanced">
            <summary>
            Gets the advanced scheduler which will allow you to schedule actions. 
            <remarks>Note! It's considered bad practice to use concurrency inside actors and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.PrepareConfigureMessageHandlers">
            <summary>
            Creates and pushes a new MatchBuilder
            </summary>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Become(System.Action)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="configure">Configures the new handler by calling the different Receive overloads.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.ActorBase.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>
            is matched with a call to <see cref="M:Akka.Actor.ActorBase.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="configure">Configures the new handler by calling the different Receive overloads.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAsync``1(System.Func{``0,System.Threading.Tasks.Task},System.Predicate{``0})">
            <summary>
            Registers an asynchronous handler for incoming messages of the specified type <typeparamref name="T"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>The actor will be suspended until the task returned by <paramref name="handler"/> completes.</remarks>
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="handler">The message handler that is invoked for incoming messages of the specified type <typeparamref name="T"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAsync``1(System.Predicate{``0},System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Registers an asynchronous handler for incoming messages of the specified type <typeparamref name="T"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>The actor will be suspended until the task returned by <paramref name="handler"/> completes.</remarks>
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
            <param name="handler">The message handler that is invoked for incoming messages of the specified type <typeparamref name="T"/></param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAsync(System.Type,System.Func{System.Object,System.Threading.Tasks.Task},System.Predicate{System.Object})">
            <summary>
            Registers an asynchronous handler for incoming messages of the specified <paramref name="messageType"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>The actor will be suspended until the task returned by <paramref name="handler"/> completes.</remarks>
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="handler">The message handler that is invoked for incoming messages of the specified <paramref name="messageType"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAsync(System.Type,System.Predicate{System.Object},System.Func{System.Object,System.Threading.Tasks.Task})">
            <summary>
            Registers an asynchronous handler for incoming messages of the specified <paramref name="messageType"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>The actor will be suspended until the task returned by <paramref name="handler"/> completes.</remarks>
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
            <param name="handler">The message handler that is invoked for incoming messages of the specified <paramref name="messageType"/></param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAnyAsync(System.Func{System.Object,System.Threading.Tasks.Task})">
            <summary>
            Registers an asynchronous handler for incoming messages of any type.
            <remarks>The actor will be suspended until the task returned by <paramref name="handler"/> completes.</remarks>
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="handler">The message handler that is invoked for all</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive``1(System.Action{``0},System.Predicate{``0})">
            <summary>
            Registers a handler for incoming messages of the specified type <typeparamref name="T"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="handler">The message handler that is invoked for incoming messages of the specified type <typeparamref name="T"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive``1(System.Predicate{``0},System.Action{``0})">
            <summary>
            Registers a handler for incoming messages of the specified type <typeparamref name="T"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="handler">The message handler that is invoked for incoming messages of the specified type <typeparamref name="T"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive(System.Type,System.Action{System.Object},System.Predicate{System.Object})">
            <summary>
            Registers a handler for incoming messages of the specified <paramref name="messageType"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="handler">The message handler that is invoked for incoming messages of the specified <paramref name="messageType"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive(System.Type,System.Predicate{System.Object},System.Action{System.Object})">
            <summary>
            Registers a handler for incoming messages of the specified <paramref name="messageType"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="handler">The message handler that is invoked for incoming messages of the specified <paramref name="messageType"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive``1(System.Func{``0,System.Boolean})">
            <summary>
            Registers a handler for incoming messages of the specified type <typeparamref name="T"/>.
            The handler should return <c>true</c> if it has handled the message. 
            If the handler returns true no more handlers will be tried; otherwise the next registered handler will be tried.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="handler">The message handler that is invoked for incoming messages of the 
            specified type <typeparamref name="T"/>. It should return <c>true</c>if it handled/matched 
            the message; <c>false</c> otherwise.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive(System.Type,System.Func{System.Object,System.Boolean})">
            <summary>
            Registers a handler for incoming messages of the specified <paramref name="messageType"/>.
            The handler should return <c>true</c> if it has handled the message. 
            If the handler returns true no more handlers will be tried; otherwise the next registered handler will be tried.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="handler">The message handler that is invoked for incoming messages of the 
            specified type <paramref name="messageType"/>. It should return <c>true</c>if it handled/matched 
            the message; <c>false</c> otherwise.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAny(System.Action{System.Object})">
            <summary>
            Registers a handler for incoming messages of any type.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="handler">The message handler that is invoked for all</param>
        </member>
        <member name="T:Akka.Actor.Status">
            <summary>
            Classes for passing status back to the sender.
            Used for internal ACKing protocol, but also exposed as a utility class for user-specific ACKing if needed.
            </summary>
        </member>
        <member name="T:Akka.Actor.Status.Success">
            <summary>
            Indicates the success of some operation which has been performed
            </summary>
        </member>
        <member name="T:Akka.Actor.Status.Failure">
            <summary>
            Indicates the failure of some operation that was requested and includes an
            <see cref="T:System.Exception"/> describing the underlying cause of the problem.
            </summary>
        </member>
        <member name="T:Akka.Actor.ILogReceive">
            <summary>
                Interface ILogReceive
            </summary>
        </member>
        <member name="T:Akka.Actor.IActorLogging">
            <summary>
            Interface used on Actors that have an explicit requirement for a logger
            </summary>
        </member>
        <member name="T:Akka.Actor.IInternalActor">
            <summary>
            Contains things needed by the framework
            </summary>
        </member>
        <member name="P:Akka.Actor.IInternalActor.ActorContext">
            <summary>Gets the context for this instance.</summary>
            <value>The context.</value>
            <exception cref="T:System.NotSupportedException">
            There is no active Context, this is most likely due to use of async
            operations from within this actor.
            </exception>
        </member>
        <member name="T:Akka.Actor.ActorBase">
            <summary>
                Class ActorBase.
            </summary>
            <summary>
                Class ActorBase.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorBase" /> class.
            </summary>
            <exception cref="T:System.Exception">Do not create actors using 'new', always create them using an ActorContext/System</exception>
        </member>
        <member name="P:Akka.Actor.ActorBase.Sender">
            <summary>
                Gets the sending ActorRef of the current message
            </summary>
            <value>The sender ActorRef</value>
        </member>
        <member name="P:Akka.Actor.ActorBase.Self">
            <summary>
                Gets the self ActorRef
            </summary>
            <value>Self ActorRef</value>
        </member>
        <member name="P:Akka.Actor.ActorBase.Akka#Actor#IInternalActor#ActorContext">
            <summary>
                Gets the context.
            </summary>
            <value>The context.</value>
            <exception cref="T:System.NotSupportedException">
                There is no active ActorContext, this is most likely due to use of async
                operations from within this actor.
            </exception>
        </member>
        <member name="P:Akka.Actor.ActorBase.Context">
            <summary>
                Gets the context.
            </summary>
            <value>The context.</value>
            <exception cref="T:System.NotSupportedException">
                There is no active Context, this is most likely due to use of async
                operations from within this actor.
            </exception>
        </member>
        <member name="M:Akka.Actor.ActorBase.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="P:Akka.Actor.ActorBase.EmptyReceive">
            <summary>
            EmptyReceive is a Receive-delegate that matches no messages at all, ever.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.Unhandled(System.Object)">
            <summary>
            Is called when a message isn't handled by the current behavior of the actor
            by default it fails with either a <see cref="T:Akka.Actor.DeathPactException"/> (in
            case of an unhandled <see cref="T:Akka.Actor.Terminated"/> message) or publishes an <see cref="T:Akka.Event.UnhandledMessage"/>
            to the actor's system's <see cref="T:Akka.Event.EventStream"/>
            </summary>
            <param name="message">The unhandled message.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.Become(Akka.Actor.Receive)">
            <summary>
            Changes the actor's command behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.BecomeStacked(Akka.Actor.Receive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.ActorBase.BecomeStacked(Akka.Actor.Receive)"/>
            is matched with a call to <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.UnbecomeStacked">
            <summary>
            Reverts the Actor behavior to the previous one on the behavior stack.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.SetReceiveTimeout(System.Nullable{System.TimeSpan})">
            <summary>
            <para>
            Defines the inactivity timeout after which the sending of a <see cref="T:Akka.Actor.ReceiveTimeout"/> message is triggered.
            When specified, the receive function should be able to handle a <see cref="T:Akka.Actor.ReceiveTimeout"/> message.
            </para>
            
            <para>
            Please note that the receive timeout might fire and enqueue the <see cref="T:Akka.Actor.ReceiveTimeout"/> message right after
            another message was enqueued; hence it is not guaranteed that upon reception of the receive
            timeout there must have been an idle period beforehand as configured via this method.
            </para>
            
            <para>
            Once set, the receive timeout stays in effect (i.e. continues firing repeatedly after inactivity
            periods). Pass in <c>null</c> to switch off this feature.
            </para>
            </summary>
            <param name="timeout">The timeout. Pass in <c>null</c> to switch off this feature.</param>
        </member>
        <member name="P:Akka.Actor.ActorBase.SupervisorStrategyInternal">
            <summary>
            Gets or sets a <see cref="M:Akka.Actor.ActorBase.SupervisorStrategy"/>.
            When getting, if a previously <see cref="M:Akka.Actor.ActorBase.SupervisorStrategy"/> has been set it's returned; otherwise calls
            <see cref="M:Akka.Actor.ActorBase.SupervisorStrategy">SupervisorStrategy()</see>, stores and returns it.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundPreRestart(System.Exception,System.Object)">
            <summary>
                Can be overridden to intercept calls to `preRestart`. Calls `preRestart` by default.
            </summary>
            <param name="cause">The cause.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundPreStart">
            <summary>
                Can be overridden to intercept calls to `preStart`. Calls `preStart` by default.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.PreStart">
            <summary>
                User overridable callback.
                <p />
                Is called when an Actor is started.
                Actors are automatically started asynchronously when created.
                Empty default implementation.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundPostRestart(System.Exception,System.Object)">
            <summary>
                Can be overridden to intercept calls to `postRestart`. Calls `postRestart` by default.
            </summary>
            <param name="cause">The cause.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)">
            <summary>
                User overridable callback: '''By default it disposes of all children and then calls `postStop()`.'''
                <p />
                Is called on a crashed Actor right BEFORE it is restarted to allow clean
                up of resources before Actor is terminated.
            </summary>
            <param name="reason">the Exception that caused the restart to happen.</param>
            <param name="message">optionally the current message the actor processed when failing, if applicable.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.PostRestart(System.Exception)">
            <summary>
                User overridable callback: By default it calls `preStart()`.
                <p />
                Is called right AFTER restart on the newly created Actor to allow reinitialization after an Actor crash.
            </summary>
            <param name="reason">the Exception that caused the restart to happen.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundPostStop">
            <summary>
                Can be overridden to intercept calls to `postStop`. Calls `postStop` by default..
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.PostStop">
            <summary>
                User overridable callback.
                <p />
                Is called asynchronously after 'actor.stop()' is invoked.
                Empty default implementation.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorPath">
            <summary>
            Actor path is a unique path to an actor that shows the creation path
            up through the actor tree to the root actor.
            ActorPath defines a natural ordering (so that ActorRefs can be put into
            collections with this requirement); this ordering is intended to be as fast
            as possible, which owing to the bottom-up recursive nature of ActorPath
            is sorted by path elements FROM RIGHT TO LEFT, where RootActorPath >
            ChildActorPath in case the number of elements is different.
            Two actor paths are compared equal when they have the same name and parent
            elements, including the root address information. That does not necessarily
            mean that they point to the same incarnation of the actor if the actor is
            re-created with the same path. In other words, in contrast to how actor
            references are compared the unique id of the actor is not taken into account
            when comparing actor paths.
            </summary>
        </member>
        <member name="F:Akka.Actor.ActorPath.ValidSymbols">
            INTERNAL API 
        </member>
        <member name="M:Akka.Actor.ActorPath.IsValidPathElement(System.String)">
            <summary> 
            Method that checks if actor name conforms to RFC 2396, http://www.ietf.org/rfc/rfc2396.txt
            Note that AKKA JVM does not allow parenthesis ( ) but, according to RFC 2396 those are allowed, and 
            since we use URL Encode to create valid actor names, we must allow them.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorPath.#ctor(Akka.Actor.Address,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorPath" /> class.
            </summary>
            <param name="address"> The address. </param>
            <param name="name"> The name. </param>
        </member>
        <member name="M:Akka.Actor.ActorPath.#ctor(Akka.Actor.ActorPath,System.String,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorPath" /> class.
            </summary>
            <param name="parentPath"> The parent path. </param>
            <param name="name"> The name. </param>
            <param name="uid"> The uid. </param>
        </member>
        <member name="P:Akka.Actor.ActorPath.Uid">
            <summary>
            Gets the uid.
            </summary>
            <value> The uid. </value>
        </member>
        <member name="P:Akka.Actor.ActorPath.Elements">
            <summary>
            Gets the elements.
            </summary>
            <value> The elements. </value>
        </member>
        <member name="P:Akka.Actor.ActorPath.Name">
            <summary>
            Gets the name.
            </summary>
            <value> The name. </value>
        </member>
        <member name="P:Akka.Actor.ActorPath.Address">
            <summary>
            The Address under which this path can be reached; walks up the tree to
            the RootActorPath.
            </summary>
            <value> The address. </value>
        </member>
        <member name="M:Akka.Actor.ActorPath.Equals(Akka.Actor.ActorPath)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other"> An object to compare with this object. </param>
            <returns> true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.WithUid(System.Int64)">
            <summary>
            Withes the uid.
            </summary>
            <param name="uid"> The uid. </param>
            <returns> ActorPath. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.op_Division(Akka.Actor.ActorPath,System.String)">
            <summary>
            Create a new child actor path.
            </summary>
            <param name="path"> The path. </param>
            <param name="name"> The name. </param>
            <returns> The result of the operator. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.op_Division(Akka.Actor.ActorPath,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Recursively create a descendant’s path by appending all child names.
            </summary>
            <param name="path"> The path. </param>
            <param name="name"> The name. </param>
            <returns> The result of the operator. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.TryParse(System.String,Akka.Actor.ActorPath@)">
            <summary>
            Tries to parse the uri, which should be a full uri, i.e containing protocol.
            For example "akka://System/user/my-actor"
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorPath.Join">
            <summary>
            Joins this instance.
            </summary>
            <returns> System.String. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToStringWithoutAddress">
            <summary>
            String representation of the path elements, excluding the address
            information. The elements are separated with "/" and starts with "/",
            e.g. "/user/a/b".
            </summary>
            <returns> System.String. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns> A <see cref="T:System.String" /> that represents this instance. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToStringWithUid">
            <summary>
            Returns a string representation of this instance including uid.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.Child(System.String)">
            <summary>
            Creates a child with the specified name
            </summary>
            <param name="childName"> Name of the child. </param>
            <returns> ActorPath. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns> A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
            <param name="obj"> The object to compare with the current object. </param>
            <returns>
            <c> true </c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise,
            <c> false </c>.
            </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToStringWithAddress">
            <summary>
            Generate String representation, with the address in the RootActorPath.
            </summary>
            <returns> System.String. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToStringWithAddress(Akka.Actor.Address)">
            <summary>
            Generate String representation, replacing the Address in the RootActorPath
            with the given one unless this path’s address includes host and port
            information.
            </summary>
            <param name="address"> The address. </param>
            <returns> System.String. </returns>
        </member>
        <member name="T:Akka.Actor.RootActorPath">
            <summary>
            Class RootActorPath.
            </summary>
        </member>
        <member name="M:Akka.Actor.RootActorPath.#ctor(Akka.Actor.Address,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.RootActorPath" /> class.
            </summary>
            <param name="address"> The address. </param>
            <param name="name"> The name. </param>
        </member>
        <member name="M:Akka.Actor.RootActorPath.WithUid(System.Int64)">
            <summary>
            Withes the uid.
            </summary>
            <param name="uid"> The uid. </param>
            <returns> ActorPath. </returns>
            <exception cref="T:System.NotSupportedException"> RootActorPath must have undefinedUid </exception>
        </member>
        <member name="T:Akka.Actor.ChildActorPath">
            <summary>
            Class ChildActorPath.
            </summary>
        </member>
        <member name="M:Akka.Actor.ChildActorPath.#ctor(Akka.Actor.ActorPath,System.String,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ChildActorPath" /> class.
            </summary>
            <param name="parentPath"> The parent path. </param>
            <param name="name"> The name. </param>
            <param name="uid"> The uid. </param>
        </member>
        <member name="M:Akka.Actor.ChildActorPath.WithUid(System.Int64)">
            <summary>
            Creates a copy of the given ActorPath and applies a new Uid
            </summary>
            <param name="uid"> The uid. </param>
            <returns> ActorPath. </returns>
        </member>
        <member name="T:Akka.Actor.IActorRefScope">
            <summary>
            All ActorRefs have a scope which describes where they live. Since it is often
            necessary to distinguish between local and non-local references, this is the only
            method provided on the scope.
            INTERNAL
            </summary>
        </member>
        <member name="T:Akka.Actor.ILocalRef">
            <summary>
            Marker interface for Actors that are deployed within local scope, 
            i.e. <see cref="P:Akka.Actor.IActorRefScope.IsLocal"/> always returns <c>true</c>.
            </summary>
        </member>
        <member name="T:Akka.Actor.IRepointableRef">
            <summary>
            RepointableActorRef (and potentially others) may change their locality at
            runtime, meaning that isLocal might not be stable. RepointableActorRef has
            the feature that it starts out “not fully started” (but you can send to it),
            which is why <see cref="P:Akka.Actor.IRepointableRef.IsStarted"/> features here; it is not improbable that cluster
            actor refs will have the same behavior.
            INTERNAL
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefImplicitSenderExtensions.Forward(Akka.Actor.IActorRef,System.Object)">
            <summary>
            Forwards the message using the current Sender
            </summary>
            <param name="receiver">The actor that receives the forward</param>
            <param name="message">The message to forward</param>
        </member>
        <member name="F:Akka.Actor.ActorRefs.NoSender">
            <summary>
            Use this value as an argument to <see cref="M:Akka.Actor.ICanTell.Tell(System.Object,Akka.Actor.IActorRef)"/> if there is not actor to
            reply to (e.g. when sending from non-actor code).
            </summary>
        </member>
        <member name="M:Akka.Actor.IInternalActorRef.GetChild(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Obtain a child given the paths element to that actor, by possibly traversing the actor tree or 
            looking it up at some provider-specific location. 
            A path element of ".." signifies the parent, a trailing "" element must be disregarded. 
            If the requested path does not exist, returns <see cref="T:Akka.Actor.Nobody"/>.
            </summary>
            <param name="name">The path elements.</param>
            <returns>The <see cref="T:Akka.Actor.IActorRef"/>, or if the requested path does not exist, returns <see cref="T:Akka.Actor.Nobody"/>.</returns>
        </member>
        <member name="M:Akka.Actor.InternalActorRefBase.GetChild(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Obtain a child given the paths element to that actor, by possibly traversing the actor tree or 
            looking it up at some provider-specific location. 
            A path element of ".." signifies the parent, a trailing "" element must be disregarded. 
            If the requested path does not exist, returns <see cref="T:Akka.Actor.Nobody"/>.
            </summary>
            <param name="name">The path elements.</param>
            <returns>The <see cref="T:Akka.Actor.IActorRef"/>, or if the requested path does not exist, returns <see cref="T:Akka.Actor.Nobody"/>.</returns>
        </member>
        <member name="T:Akka.Actor.Nobody">
            <summary> This is an internal look-up failure token, not useful for anything else.</summary>
        </member>
        <member name="T:Akka.Actor.VirtualPathContainer.Enumerable`1">
            <summary>
            An enumerable that continues where the supplied enumerator is positioned
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorRefExtensions">
            <summary>
                An extension method class for working with ActorRefs
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefExtensions.IsNobody(Akka.Actor.IActorRef)">
            <summary>
                If we call a method such as <code>Context.Child(name)</code>
                and don't receive a valid result in return, this method will indicate
                whether or not the actor we received is valid.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefFactoryExtensions.ActorSelection(Akka.Actor.IActorRefFactory,Akka.Actor.IActorRef,System.String)">
            <summary>
                Construct an <see cref="T:Akka.Actor.ActorSelection"/> from the given string representing a path
                relative to the given target. This operation has to create all the
                matching magic, so it is preferable to cache its result if the
                intention is to send messages frequently.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorRefFactoryShared">
            <summary>
            This class contains implementations originally found in Akka´s trait ActorRefFactory in ActorRefProvider.scala
            https://github.com/akka/akka/blob/master/akka-actor/src/main/scala/akka/actor/ActorRefProvider.scala#L180
            <see cref="T:Akka.Actor.IActorRefFactory"/> corresponds to that trait, but since it is an interface it
            cannot contain any code, hence this class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefFactoryShared.ActorSelection(Akka.Actor.ActorPath,Akka.Actor.ActorSystem)">
            <summary>
                Construct an <see cref="T:Akka.Actor.ActorSelection"/> from the given path, which is
                parsed for wildcards (these are replaced by regular expressions
                internally). No attempt is made to verify the existence of any part of
                the supplied path, it is recommended to send a message and gather the
                replies in order to resolve the matching set of actors.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefFactoryShared.ActorSelection(System.String,Akka.Actor.ActorSystem,Akka.Actor.IActorRef)">
            <summary>
                Construct an <see cref="T:Akka.Actor.ActorSelection"/> from the given path, which is
                parsed for wildcards (these are replaced by regular expressions
                internally). No attempt is made to verify the existence of any part of
                the supplied path, it is recommended to send a message and gather the
                replies in order to resolve the matching set of actors.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefFactoryShared.ActorSelection(Akka.Actor.IActorRef,System.String)">
            <summary>
                Construct an <see cref="T:Akka.Actor.ActorSelection"/> from the given string representing a path
                relative to the given target. This operation has to create all the
                matching magic, so it is preferable to cache its result if the
                intention is to send messages frequently.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.RootGuardian">
            <summary>
            Reference to the supervisor of guardian and systemGuardian; this is
            exposed so that the ActorSystemImpl can use it as lookupRoot, i.e.
            for anchoring absolute actor look-ups.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.RootGuardianAt(Akka.Actor.Address)">
            <summary>Reference to the supervisor of guardian and systemGuardian at the specified address;
            this is exposed so that the ActorRefFactory can use it as lookupRoot, i.e.
            for anchoring absolute actor selections.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.Guardian">
            <summary> Gets the supervisor used for all top-level user actors.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.SystemGuardian">
            <summary>Gets the supervisor used for all top-level system actors.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.DeadLetters">
            <summary>Gets the dead letters.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.RootPath">
            <summary>
            Gets the root path for all actors within this actor system, not including any remote address information.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.Settings">
            <summary>Gets the settings.</summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.Init(Akka.Actor.Internal.ActorSystemImpl)">
            <summary>
            Initialization of an ActorRefProvider happens in two steps: first
            construction of the object with settings, eventStream, etc.
            and then—when the ActorSystem is constructed—the second phase during
            which actors may be created (e.g. the guardians).
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.Deployer">
            <summary>Gets the deployer.</summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.TempPath">
            <summary>Generates and returns a unique actor path below "/temp".</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.TempContainer">
            <summary>Returns the actor reference representing the "/temp" path.</summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.RegisterTempActor(Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath)">
            <summary>Registers an actorRef at a path returned by <see cref="M:Akka.Actor.IActorRefProvider.TempPath"/>; do NOT pass in any other path.</summary>
            <param name="actorRef">The actor reference.</param>
            <param name="path">A path returned by <see cref="M:Akka.Actor.IActorRefProvider.TempPath"/>. Do NOT pass in any other path!</param>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.UnregisterTempActor(Akka.Actor.ActorPath)">
            <summary>Unregister a temporary actor (i.e. obtained from <see cref="M:Akka.Actor.IActorRefProvider.TempPath"/>); do NOT pass in any other path.</summary>
            <param name="path">A path returned by <see cref="M:Akka.Actor.IActorRefProvider.TempPath"/>. Do NOT pass in any other path!</param>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.ActorOf(Akka.Actor.Internal.ActorSystemImpl,Akka.Actor.Props,Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath,System.Boolean,Akka.Actor.Deploy,System.Boolean,System.Boolean)">
            <summary>
            Actor factory with create-only semantics: will create an actor as
            described by <paramref name="props"/> with the given <paramref name="supervisor"/> and <paramref name="path"/> (may be different
            in case of remote supervision). If <paramref name="systemService"/> is true, deployment is
            bypassed (local-only). If a value for<paramref name="deploy"/> is passed in, it should be
            regarded as taking precedence over the nominally applicable settings,
            but it should be overridable from external configuration; the lookup of
            the latter can be suppressed by setting "lookupDeploy" to "false".
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.ResolveActorRef(System.String)">
            <summary>Get the actor reference for a specified path. If no such actor exists, it will be (equivalent to) a dead letter reference.</summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.ResolveActorRef(Akka.Actor.ActorPath)">
            <summary>Get the actor reference for a specified path. If no such actor exists, it will be (equivalent to) a dead letter reference.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.TerminationTask">
            <summary>
            This Future is completed upon termination of this <see cref="T:Akka.Actor.IActorRefProvider"/>, which
            is usually initiated by stopping the guardian via <see cref="M:Akka.Actor.ActorSystem.Stop(Akka.Actor.IActorRef)"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.GetExternalAddressFor(Akka.Actor.Address)">
            <summary>
            Obtain the address which is to be used within sender references when
            sending to the given other address or none if the other address cannot be
            reached from this system (i.e. no means of communication known; no
            attempt is made to verify actual reachability).
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.DefaultAddress">
            <summary>Gets the external address of the default transport. </summary>
        </member>
        <member name="T:Akka.Actor.LocalActorRefProvider">
            <summary>
                Class LocalActorRefProvider. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.RegisterExtraName(System.String,Akka.Actor.IInternalActorRef)">
            <summary>
            Higher-level providers (or extensions) might want to register new synthetic
            top-level paths for doing special stuff. This is the way to do just that.
            Just be careful to complete all this before <see cref="!:ActorSystem.Start"/> finishes,
            or before you start your own auto-spawned actors.
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.ResolveActorRef(Akka.Actor.ActorPath)">
            <summary>
                Resolves the actor reference.
            </summary>
            <param name="path">The actor path.</param>
            <returns>ActorRef.</returns>
            <exception cref="T:System.NotSupportedException">The provided actor path is not valid in the LocalActorRefProvider</exception>
        </member>
        <member name="T:Akka.Actor.ActorSelection">
            <summary>
                Class ActorSelection.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSelection.Anchor">
            <summary>
                Gets the anchor.
            </summary>
            <value>The anchor.</value>
        </member>
        <member name="P:Akka.Actor.ActorSelection.Path">
            <summary>
                Gets or sets the elements.
            </summary>
            <value>The elements.</value>
        </member>
        <member name="P:Akka.Actor.ActorSelection.PathString">
            <summary>
            <see cref="T:System.String"/> representation of all of the elements in the <see cref="T:Akka.Actor.ActorSelection"/> path.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSelection.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelection" /> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSelection.#ctor(Akka.Actor.IActorRef,Akka.Actor.SelectionPathElement[])">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelection" /> class.
            </summary>
            <param name="anchor">The anchor.</param>
            <param name="path">The path.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.#ctor(Akka.Actor.IActorRef,System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelection" /> class.
            </summary>
            <param name="anchor">The anchor.</param>
            <param name="path">The path.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.#ctor(Akka.Actor.IActorRef,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelection" /> class.
            </summary>
            <param name="anchor">The anchor.</param>
            <param name="elements">The elements.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.Tell(System.Object,Akka.Actor.IActorRef)">
            <summary>
                Posts a message to this ActorSelection.
            </summary>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.DeliverSelection(Akka.Actor.IInternalActorRef,Akka.Actor.IActorRef,Akka.Actor.ActorSelectionMessage)">
            <summary>
                INTERNAL API
                Convenience method used by remoting when receiving <see cref="T:Akka.Actor.ActorSelectionMessage" /> from a remote
                actor.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorSelectionMessage">
            <summary>
                Class ActorSelectionMessage.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSelectionMessage.#ctor(System.Object,Akka.Actor.SelectionPathElement[],System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelectionMessage" /> class.
            </summary>
            <param name="message">The message.</param>
            <param name="elements">The elements.</param>
            <param name="wildCardFanOut"></param>
        </member>
        <member name="P:Akka.Actor.ActorSelectionMessage.Message">
            <summary>
                The message that should be delivered to this ActorSelection.
            </summary>
            <value>The message.</value>
        </member>
        <member name="P:Akka.Actor.ActorSelectionMessage.Elements">
            <summary>
                The elements, e.g. "foo/bar/baz".
            </summary>
            <value>The elements.</value>
        </member>
        <member name="T:Akka.Actor.SelectionPathElement">
            <summary>
                Class SelectionPathElement.
            </summary>
        </member>
        <member name="T:Akka.Actor.SelectChildName">
            <summary>
                Class SelectChildName.
            </summary>
        </member>
        <member name="M:Akka.Actor.SelectChildName.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.SelectChildName" /> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="P:Akka.Actor.SelectChildName.Name">
            <summary>
                Gets or sets the actor name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="M:Akka.Actor.SelectChildName.ToString">
            <summary>
                Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Actor.SelectChildPattern">
            <summary>
                Class SelectChildPattern.
            </summary>
        </member>
        <member name="M:Akka.Actor.SelectChildPattern.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.SelectChildPattern" /> class.
            </summary>
            <param name="patternStr">The pattern string.</param>
        </member>
        <member name="P:Akka.Actor.SelectChildPattern.PatternStr">
            <summary>
                Gets the pattern string.
            </summary>
            <value>The pattern string.</value>
        </member>
        <member name="M:Akka.Actor.SelectChildPattern.ToString">
            <summary>
                Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Actor.SelectParent">
            <summary>
                Class SelectParent.
            </summary>
        </member>
        <member name="M:Akka.Actor.SelectParent.ToString">
            <summary>
                Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Actor.ActorSystem">
            <summary>
                An actor system is a hierarchical group of actors which share common
                configuration, e.g. dispatchers, deployments, remote capabilities and
                addresses. It is also the entry point for creating or looking up actors.
                There are several possibilities for creating actors (see <see cref="T:Akka.Actor.Props"/>
                for details on `props`):
                <code>
            system.ActorOf(props, "name");
            system.ActorOf(props);
            system.ActorOf(Props.Create(typeof(MyActor)), "name");
            system.ActorOf(Props.Create(() =&gt; new MyActor(arg1, arg2), "name");
            </code>
                Where no name is given explicitly, one will be automatically generated.
                <b>
                    <i>Important Notice:</i>
                </b>
                This class is not meant to be extended by user code.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Settings">
            <summary>Gets the settings.</summary>
            <value>The settings.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Name">
            <summary>Gets the name of this system.</summary>
            <value>The name.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Serialization">
            <summary>Gets the serialization.</summary>
            <value>The serialization.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.EventStream">
            <summary>Gets the event stream.</summary>
            <value>The event stream.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.DeadLetters">
            <summary>
                Gets the dead letters.
            </summary>
            <value>The dead letters.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Dispatchers">
            <summary>Gets the dispatchers.</summary>
            <value>The dispatchers.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Mailboxes">
            <summary>Gets the mailboxes.</summary>
            <value>The mailboxes.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Scheduler">
            <summary>Gets the scheduler.</summary>
            <value>The scheduler.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Log">
            <summary>Gets the log</summary>
        </member>
        <member name="P:Akka.Actor.ActorSystem.StartTime">
            <summary>
            Start-up time since the epoch.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Uptime">
            <summary>
            Up-time of this actor system.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Create(System.String,Akka.Configuration.Config)">
            <summary>
                Creates a new ActorSystem with the specified name, and the specified Config
            </summary>
            <param name="name">Name of the ActorSystem
            <remarks>Must contain only word characters (i.e. [a-zA-Z0-9] plus non-leading '-'</remarks>
            </param>
            <param name="config">Configuration of the ActorSystem</param>
            <returns>ActorSystem.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Create(System.String)">
            <summary>
                Creates the specified name.
            </summary>
            <param name="name">The name. The name must be uri friendly.
            <remarks>Must contain only word characters (i.e. [a-zA-Z0-9] plus non-leading '-'</remarks>
            </param>
            <returns>ActorSystem.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.GetExtension(Akka.Actor.IExtensionId)">
            <summary>
            Returns an extension registered to this ActorSystem
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.GetExtension``1">
            <summary>
            Returns an extension registered to this ActorSystem
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.HasExtension(System.Type)">
            <summary>
            Determines whether this instance has the specified extension.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.HasExtension``1">
            <summary>
            Determines whether this instance has the specified extension.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.TryGetExtension(System.Type,System.Object@)">
            <summary>
            Tries to the get the extension of specified type.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.TryGetExtension``1(``0@)">
            <summary>
            Tries to the get the extension of specified type.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.RegisterOnTermination(System.Action)">
            <summary>
            Register a block of code (callback) to run after ActorSystem.shutdown has been issued and
            all actors in this actor system have been stopped.
            Multiple code blocks may be registered by calling this method multiple times.
            The callbacks will be run sequentially in reverse order of registration, i.e.
            last registration is run first.
            </summary>
            <param name="code">The code to run</param>
            <exception cref="T:System.Exception">Thrown if the System has already shut down or if shutdown has been initiated.</exception>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Shutdown">
            <summary>
            Stop this actor system. This will stop the guardian actor, which in turn
            will recursively stop all its child actors, then the system guardian
            (below which the logging actors reside) and the execute all registered
            termination handlers (<see cref="M:Akka.Actor.ActorSystem.RegisterOnTermination(System.Action)" />).
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Terminate">
            <summary>
            Terminates this actor system. This will stop the guardian actor, which in turn
            will recursively stop all its child actors, then the system guardian
            (below which the logging actors reside) and the execute all registered
            termination handlers (<see cref="M:Akka.Actor.ActorSystem.RegisterOnTermination(System.Action)" />).
            Be careful to not schedule any operations on completion of the returned task
            using the `dispatcher` of this actor system as it will have been shut down before the
            task completes.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSystem.TerminationTask">
            <summary>
            Returns a task that will be completed when the system has terminated.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.AwaitTermination">
            <summary>
            Block current thread until the system has been shutdown.
            This will block until after all on termination callbacks have been run.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.AwaitTermination(System.TimeSpan)">
            <summary>
            Block current thread until the system has been shutdown, or the specified
            timeout has elapsed. 
            This will block until after all on termination callbacks have been run.
            <para>Returns <c>true</c> if the system was shutdown during the specified time;
            <c>false</c> if it timed out.</para>
            </summary>
            <param name="timeout">The timeout.</param>
            <returns>Returns <c>true</c> if the system was shutdown during the specified time;
            <c>false</c> if it timed out.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.AwaitTermination(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Block current thread until the system has been shutdown, or the specified
            timeout has elapsed, or the cancellationToken was canceled. 
            This will block until after all on termination callbacks have been run.
            <para>Returns <c>true</c> if the system was shutdown during the specified time;
            <c>false</c> if it timed out, or the cancellationToken was canceled. </para>
            </summary>
            <param name="timeout">The timeout.</param>
            <param name="cancellationToken">A cancellation token that cancels the wait operation.</param>
            <returns>Returns <c>true</c> if the system was shutdown during the specified time;
            <c>false</c> if it timed out, or the cancellationToken was canceled. </returns>
        </member>
        <member name="P:Akka.Actor.ActorSystem.WhenTerminated">
            <summary>
            Returns a task which will be completed after the ActorSystem has been terminated
            and termination hooks have been executed. Be careful to not schedule any operations
            on the `dispatcher` of this actor system as it will have been shut down before this
            task completes.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Dispose(System.Boolean)">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
            <param name="disposing">if set to <c>true</c> the method has been called directly or indirectly by a 
            user's code. Managed and unmanaged resources will be disposed.<br />
            if set to <c>false</c> the method has been called by the runtime from inside the finalizer and only 
            unmanaged resources can be disposed.</param>
        </member>
        <member name="M:Akka.Actor.ActorSystem.WaitForShutdown">
            <summary>
            Block and prevent the main application thread from exiting unless
            the actor system is shut down.
            </summary>
        </member>
        <member name="T:Akka.Actor.Address">
            <summary>
             The address specifies the physical location under which an Actor can be
             reached. Examples are local addresses, identified by the <see cref="T:Akka.Actor.ActorSystem"/>'s
            name, and remote addresses, identified by protocol, host and port.
             
            This class is sealed to allow use as a case class (copy method etc.); if
            for example a remote transport would want to associate additional
            information with an address, then this must be done externally.
            </summary>
        </member>
        <member name="F:Akka.Actor.Address.AllSystems">
            <summary>
            Pseudo address for all systems
            </summary>
        </member>
        <member name="M:Akka.Actor.Address.Parse(System.String)">
            <summary>
            Parses a new <see cref="T:Akka.Actor.Address"/> from a given string
            </summary>
            <param name="address">The address to parse</param>
            <returns>A populated <see cref="T:Akka.Actor.Address"/> object with host and port included, if available</returns>
            <exception cref="T:System.UriFormatException">Thrown if the address is not able to be parsed</exception>
        </member>
        <member name="T:Akka.Actor.RelativeActorPath">
            <summary>
            Extractor class for so-called "relative actor paths" - as in "relative URI", not
            "relative to some other actors."
            
            Examples:
            
             * "grand/child"
             * "/user/hello/world"
            </summary>
        </member>
        <member name="T:Akka.Actor.ExtendedActorSystem">
            <summary>
            More powerful interface to the actor system’s implementation which is presented to 
            extensions (see <see cref="T:Akka.Actor.IExtension"/>).
            <remarks>Important Notice:<para>
            This class is not meant to be extended by user code. If you want to
            actually roll your own Akka, beware that you are completely on your own in
            that case!</para></remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.Provider">
            <summary>Gets the provider.</summary>
            <value>The provider.</value>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.Guardian">
            <summary>
            Gets the top-level supervisor of all user actors created using 
            <see cref="M:Akka.Actor.ActorSystem.ActorOf(Akka.Actor.Props,System.String)">system.ActorOf(...)</see>
            </summary>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.SystemGuardian">
            <summary>
            Gets the top-level supervisor of all system-internal services like logging.
            </summary>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.ActorPipelineResolver">
            <summary>
            Gets the actor producer pipeline resolver for current actor system. It may be used by
            Akka plugins to inject custom behavior directly into actor creation chain.
            </summary>
        </member>
        <member name="M:Akka.Actor.ExtendedActorSystem.SystemActorOf(Akka.Actor.Props,System.String)">
            <summary>Creates a new system actor in the "/system" namespace. This actor 
            will be shut down during system shutdown only after all user actors have
            terminated.</summary>
        </member>
        <member name="M:Akka.Actor.ExtendedActorSystem.SystemActorOf``1(System.String)">
            <summary>Creates a new system actor in the "/system" namespace. This actor 
            will be shut down during system shutdown only after all user actors have
            terminated.</summary>
        </member>
        <member name="T:Akka.Actor.Futures">
            <summary>
                Extension method class designed to create Ask support for
                non-ActorRef objects such as <see cref="T:Akka.Actor.ActorSelection" />.
            </summary>
        </member>
        <member name="T:Akka.Actor.PromiseActorRef">
            <summary>
            Akka private optimized representation of the temporary actor spawned to
            receive the reply to an "ask" operation.
            
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Actor.PromiseActorRef._mcn">
            <summary>
            This is necessary for weaving the PromiseActorRef into the asked message, i.e. the replyTo pattern.
            </summary>
        </member>
        <member name="F:Akka.Actor.PromiseActorRef._stateDoNotCallMeDirectly">
             As an optimization for the common (local) case we only register this PromiseActorRef
             with the provider when the `path` member is actually queried, which happens during
             serialization (but also during a simple call to `ToString`, `Equals` or `GetHashCode`!).
            
             Defined states:
             null                  => started, path not yet created
             Registering           => currently creating temp path and registering it
             path: ActorPath       => path is available and was registered
             StoppedWithPath(path) => stopped, path available
             Stopped               => stopped, path not yet created
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.AddWatcher(Akka.Actor.IActorRef)">
            <summary>
            Returns false if the <see cref="F:Akka.Actor.PromiseActorRef.Result"/> is already completed.
            </summary>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.GetPath">
            <summary>
             Contract of this method:
             Must always return the same ActorPath, which must have
             been registered if we haven't been stopped yet.
            </summary>
        </member>
        <member name="T:Akka.Actor.PoisonPill">
            <summary>
            Sending a <see cref="T:Akka.Actor.PoisonPill"/> to an will stop the actor when the message 
            is processed. <see cref="T:Akka.Actor.PoisonPill"/> is enqueued as ordinary messages and will be handled after 
            messages that were already queued in the mailbox.
            <para>See also <see cref="T:Akka.Actor.Kill"/> which causes the actor to throw an  <see cref="T:Akka.Actor.ActorKilledException"/> when 
            it processes the message, which gets handled using the normal supervisor mechanism, and
            <see cref="M:Akka.Actor.IActorContext.Stop(Akka.Actor.IActorRef)"/> which causes the actor to stop without processing any more messages. </para>
            </summary>
        </member>
        <member name="T:Akka.Actor.Kill">
            <summary>
            Sending an <see cref="T:Akka.Actor.Kill"/> message to an actor causes the actor to throw an 
            <see cref="T:Akka.Actor.ActorKilledException"/> when it processes the message, which gets handled using the normal supervisor mechanism.
            <para>See also <see cref="T:Akka.Actor.PoisonPill"/> which causes the actor to stop when the <see cref="T:Akka.Actor.PoisonPill"/>
            is processed, without throwing an exception, and 
            <see cref="M:Akka.Actor.IActorContext.Stop(Akka.Actor.IActorRef)"/> which causes the actor to stop without processing any more messages. </para>
            </summary>
        </member>
        <member name="T:Akka.Actor.AddressTerminated">
            <summary>
            INTERNAL API
            
            Used for remote death watch. Failure detectors publish this to the
            <see cref="T:Akka.Event.AddressTerminatedTopic"/> when a remote node is detected to be unreachable and / or decided
            to be removed.
            
            The watcher <see cref="!:DeathWatch"/> subscribes to the <see cref="T:Akka.Event.AddressTerminatedTopic"/> and translates this
            event to <see cref="T:Akka.Actor.Terminated"/>, which is sent to itself.
            </summary>
        </member>
        <member name="T:Akka.Actor.EventStreamActor">
            <summary>
                Class EventStreamActor.
            </summary>
        </member>
        <member name="M:Akka.Actor.EventStreamActor.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Actor.GuardianActor">
            <summary>
                Class GuardianActor.
            </summary>
        </member>
        <member name="T:Akka.Actor.SystemGuardianActor">
            <summary>
            System guardian. 
            
            Root actor for all actors under the /system path.
            </summary>
        </member>
        <member name="M:Akka.Actor.SystemGuardianActor.Receive(System.Object)">
            <summary>
            Processor for messages that are sent to the root system guardian
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Akka.Actor.DeadLetterActorRef">
            <summary>
                Class DeadLetterActorRef.
            </summary>
        </member>
        <member name="T:Akka.Actor.ICell">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.ICell.Self">
            <summary>Gets the “self” reference which this Cell is attached to.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.System">
            <summary>The system within which this Cell lives.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.SystemImpl">
            <summary>The system internals within which this Cell lives.</summary>
        </member>
        <member name="M:Akka.Actor.ICell.Start">
            <summary>
            Start the cell: enqueued message must not be processed before this has
            been called. The usual action is to attach the mailbox to a dispatcher.
            </summary>
        </member>
        <member name="M:Akka.Actor.ICell.Suspend">
            <summary>Recursively suspend this actor and all its children. Is only allowed to throw fatal exceptions.</summary>
        </member>
        <member name="M:Akka.Actor.ICell.Resume(System.Exception)">
            <summary>Recursively resume this actor and all its children. Is only allowed to throw fatal exceptions.</summary>
        </member>
        <member name="M:Akka.Actor.ICell.Restart(System.Exception)">
            <summary>Restart this actor (will recursively restart or stop all children). Is only allowed to throw Fatal Throwables.</summary>
        </member>
        <member name="M:Akka.Actor.ICell.Stop">
            <summary>Recursively terminate this actor and all its children. Is only allowed to throw Fatal Throwables.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.Parent">
            <summary>The supervisor of this actor.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.IsLocal">
            <summary>Returns true if the actor is local.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.Props">
            <summary>The props for this actor cell.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.HasMessages">
            <summary>
            If the actor isLocal, returns whether "user messages" are currently queued,
            <c>false</c>otherwise.
            </summary>
        </member>
        <member name="P:Akka.Actor.ICell.NumberOfMessages">
            <summary>
            If the actor isLocal, returns the number of "user messages" currently queued,
            which may be a costly operation, 0 otherwise.
            </summary>
        </member>
        <member name="M:Akka.Actor.ICell.GetSingleChild(System.String)">
            <summary>
            Method for looking up a single child beneath this actor.
            It is racy if called from the outside.</summary>
        </member>
        <member name="M:Akka.Actor.ICell.TryGetChildStatsByName(System.String,Akka.Actor.Internal.IChildStats@)">
            <summary>
            Tries to get the stats for the child with the specified name. The stats can be either <see cref="T:Akka.Actor.Internal.ChildNameReserved"/> 
            indicating that only a name has been reserved for the child, or a <see cref="T:Akka.Actor.Internal.ChildRestartStats"/> for a child that 
            has been initialized/created.
            </summary>
        </member>
        <member name="T:Akka.Actor.IInboxable">
            <summary>
            <see cref="T:Akka.Actor.IInboxable"/> is an actor-like object to be listened by external objects.
            It can watch other actors lifecycle and contains inner actor, which could be passed
            as reference to other actors.
            </summary>
        </member>
        <member name="P:Akka.Actor.IInboxable.Receiver">
            <summary>
            Get a reference to internal actor. It may be for example registered in event stream.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInboxable.Receive">
            <summary>
            Receive a next message from current <see cref="T:Akka.Actor.IInboxable"/> with default timeout. This call will return immediately,
            if the internal actor previously received a message, or will block until it'll receive a message.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInboxable.Receive(System.TimeSpan)">
            <summary>
            Receive a next message from current <see cref="T:Akka.Actor.IInboxable"/>. This call will return immediately,
            if the internal actor previously received a message, or will block for time specified by 
            <paramref name="timeout"/> until it'll receive a message.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInboxable.ReceiveWhere(System.Predicate{System.Object})">
            <summary>
            Receive a next message satisfying specified <paramref name="predicate"/> under default timeout.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInboxable.ReceiveWhere(System.Predicate{System.Object},System.TimeSpan)">
            <summary>
            Receive a next message satisfying specified <paramref name="predicate"/> under provided <paramref name="timeout"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInboxable.Send(Akka.Actor.IActorRef,System.Object)">
            <summary>
            Makes an internal actor act as a proxy of a given <paramref name="message"/>, 
            which is sent to a given target actor. It means, that all <paramref name="target"/>'s
            replies will be sent to current inbox instead.
            </summary>
        </member>
        <member name="M:Akka.Actor.Inbox.Watch(Akka.Actor.IActorRef)">
            <summary>
            Make the inbox’s actor watch the <paramref name="subject"/> actor such that 
            reception of the <see cref="T:Akka.Actor.Terminated"/> message can then be awaited.
            </summary>
        </member>
        <member name="M:Akka.Actor.Inbox.Receive">
            <summary>
            Receive a single message from <see cref="P:Akka.Actor.Inbox.Receiver"/> actor with default timeout. 
            NOTE: Timeout resolution depends on system's scheduler.
            </summary>
            <remarks>
            Don't use this method within actors, since it block current thread until a message is received.
            </remarks>
        </member>
        <member name="M:Akka.Actor.Inbox.Receive(System.TimeSpan)">
            <summary>
            Receive a single message from <see cref="P:Akka.Actor.Inbox.Receiver"/> actor. 
            Provided <paramref name="timeout"/> is used for cleanup purposes.
            NOTE: <paramref name="timeout"/> resolution depends on system's scheduler.
            </summary>
            <remarks>
            Don't use this method within actors, since it block current thread until a message is received.
            </remarks>
        </member>
        <member name="T:Akka.Actor.LocalScope">
            <summary>
            Used to deploy actors in local scope
            </summary>
        </member>
        <member name="T:Akka.Actor.ReceiveTimeout">
            <summary>
            This message is sent to an actor that has set a receive timeout, either by calling 
            <see cref="M:Akka.Actor.IActorContext.SetReceiveTimeout(System.Nullable{System.TimeSpan})">Context.SetReceiveTimeout</see> or
            <see cref="M:Akka.Actor.ActorBase.SetReceiveTimeout(System.Nullable{System.TimeSpan})">SetReceiveTimeout</see>
            and no message has been sent to the actor during the specified amount of time.
            </summary>
        </member>
        <member name="P:Akka.Actor.ReceiveTimeout.Instance">
            <summary>
            Gets the <see cref="T:Akka.Actor.ReceiveTimeout"/> singleton instance.
            </summary>
        </member>
        <member name="T:Akka.Actor.RemoteScope">
            <summary>
            Used to deploy actors on remote nodes at the specified <see cref="P:Akka.Actor.RemoteScope.Address"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.Initialize(System.Boolean)">
            <summary>
            Initialize: make a dummy cell which holds just a mailbox, then tell our
            supervisor that we exist so that he can create the real Cell in
            handleSupervise().
            Call twice on your own peril!
            This is protected so that others can have different initialization.
             </summary>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.Point">
            <summary>
            This method is supposed to be called by the supervisor in HandleSupervise()
            to replace the UnstartedCell with the real one. It assumes no concurrent
            modification of the `underlying` field, though it is safe to send messages
            at any time.
             </summary>
        </member>
        <member name="T:Akka.Actor.RootGuardianSupervisor">
            <summary>
            Top-level anchor for the supervision hierarchy of this actor system.
            Note: This class is called theOneWhoWalksTheBubblesOfSpaceTime in Akka
            </summary>
        </member>
        <member name="T:Akka.Actor.IExtension">
            <summary>
            This interface is used to mark an object as an <see cref="T:Akka.Actor.ActorSystem"/> extension.
            </summary>
        </member>
        <member name="T:Akka.Actor.IExtensionId">
            <summary>
            This interface is used to distinguish unique <see cref="T:Akka.Actor.ActorSystem"/> extensions.
            </summary>
        </member>
        <member name="M:Akka.Actor.IExtensionId.Apply(Akka.Actor.ActorSystem)">
            <summary>
            Registers the current extension to a given actor system.
            </summary>
            <param name="system">The actor system in which to register the extension.</param>
            <returns>The extension registered to the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.IExtensionId.Get(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the current extension from a given actor system.
            </summary>
            <param name="system">The actor system from which to retrieve the extension.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.IExtensionId.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Creates the current extension using a given actor system.
            
            <note>
            Internal use only.
            </note>
            </summary>
            <param name="system">The actor system to use when creating the extension.</param>
            <returns>The extension created using the given actor system.</returns>
        </member>
        <member name="P:Akka.Actor.IExtensionId.ExtensionType">
            <summary>
            Retrieves the underlying type for the current extension
            </summary>
        </member>
        <member name="T:Akka.Actor.IExtensionId`1">
            <summary>
            This interface is used to distinguish unique <see cref="T:Akka.Actor.ActorSystem"/> extensions.
            </summary>
            <typeparam name="T">The type associated with the current extension.</typeparam>
        </member>
        <member name="M:Akka.Actor.IExtensionId`1.Apply(Akka.Actor.ActorSystem)">
            <summary>
            Registers the current extension to a given actor system.
            </summary>
            <param name="system">The actor system in which to register the extension.</param>
            <returns>The extension registered to the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.IExtensionId`1.Get(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the current extension from a given actor system.
            </summary>
            <param name="system">The actor system from which to retrieve the extension.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.IExtensionId`1.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Creates the current extension using a given actor system.
            
            <note>
            Internal use only.
            </note>
            </summary>
            <param name="system">The actor system to use when creating the extension.</param>
            <returns>The extension created using the given actor system.</returns>
        </member>
        <member name="T:Akka.Actor.ActorSystemWithExtensions">
            <summary>
            This class contains extension methods used for resolving <see cref="T:Akka.Actor.ActorSystem"/> extensions.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystemWithExtensions.WithExtension``1(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the extension specified by a given type, <typeparamref name="T"/>, from a given actor system.
            </summary>
            <typeparam name="T">The type associated with the extension to retrieve.</typeparam>
            <param name="system">The actor system from which to retrieve the extension.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystemWithExtensions.WithExtension``1(Akka.Actor.ActorSystem,System.Type)">
            <summary>
            Retrieves the extension specified by a given type, <typeparamref name="T"/>, from a given actor system.
            If the extension does not exist within the actor system, then the extension specified by <paramref name="extensionId"/>
            is registered to the actor system.
            </summary>
            <typeparam name="T">The type associated with the extension to retrieve.</typeparam>
            <param name="system">The actor system from which to retrieve the extension or to register with if it does not exist.</param>
            <param name="extensionId">The type of the extension to register if it does not exist in the given actor system.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystemWithExtensions.WithExtension``2(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the extension specified by a given type, <typeparamref name="T"/>, from a given actor system.
            If the extension does not exist within the actor system, then the extension specified by <typeparamref name="TI"/>
            is registered to the actor system.
            </summary>
            <typeparam name="T">The type associated with the extension to retrieve.</typeparam>
            <typeparam name="TI">The type associated with the extension to retrieve if it does not exist within the system.</typeparam>
            <param name="system">The actor system from which to retrieve the extension or to register with if it does not exist.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="T:Akka.Actor.ExtensionIdProvider`1">
            <summary>
            This class represents the base provider implementation for creating, registering and retrieving extensions within an <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.ExtensionIdProvider`1.Apply(Akka.Actor.ActorSystem)">
            <summary>
            Registers the current extension to a given actor system.
            </summary>
            <param name="system">The actor system in which to register the extension.</param>
            <returns>The extension registered to the given actor system.</returns>
        </member>
        <member name="P:Akka.Actor.ExtensionIdProvider`1.ExtensionType">
            <summary>
            Retrieves the underlying type for the current extension
            </summary>
        </member>
        <member name="M:Akka.Actor.ExtensionIdProvider`1.Get(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the current extension from a given actor system.
            </summary>
            <param name="system">The actor system from which to retrieve the extension.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.ExtensionIdProvider`1.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Creates the current extension using a given actor system.
            </summary>
            <param name="system">The actor system to use when creating the extension.</param>
            <returns>The extension created using the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.ExtensionIdProvider`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns><c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Actor.ExtensionIdProvider`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. </returns>
        </member>
        <member name="T:Akka.Actor.FSMBase.CurrentState`1">
            <summary>
            Message type which is sent directly to the subscriber Actor in <see cref="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack"/>
            before sending any <see cref="T:Akka.Actor.FSMBase.Transition`1"/> messages.
            </summary>
            <typeparam name="TS">The type of the state being used in this finite state machine.</typeparam>
        </member>
        <member name="T:Akka.Actor.FSMBase.Transition`1">
            <summary>
            Message type which is used to communicate transitions between states to all subscribed listeners
            (use <see cref="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack"/>)
            </summary>
            <typeparam name="TS">The type of state used</typeparam>
        </member>
        <member name="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack">
            <summary>
            Send this to an <see cref="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack"/> to request first the <see cref="T:Akka.Actor.FSMBase.UnsubscribeTransitionCallBack"/>
            followed by a series of <see cref="T:Akka.Actor.FSMBase.Transition`1"/> updates. Cancel the subscription using
            <see cref="T:Akka.Actor.FSMBase.CurrentState`1"/>.
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.UnsubscribeTransitionCallBack">
            <summary>
            Unsubscribe from <see cref="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack"/> notifications which were
            initialized by sending the corresponding <see cref="T:Akka.Actor.FSMBase.Transition`1"/>.
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Reason">
            <summary>
            Reason why this <see cref="T:Akka.Actor.FSM`2"/> is shutting down
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Normal">
            <summary>
            Default <see cref="T:Akka.Actor.FSMBase.Reason"/> if calling Stop().
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Shutdown">
            <summary>
            Reason given when someone as calling <see cref="T:Akka.Dispatch.SysMsg.Stop"/> from outside;
            also applies to <see cref="T:Akka.Actor.ActorSystem"/> supervision directive.
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Failure">
            <summary>
            Signifies that the <see cref="T:Akka.Actor.FSM`2"/> is shutting itself down because of an error,
            e.g. if the state to transition into does not exist. You can use this to communicate a more
            precise cause to the <see cref="M:Akka.Actor.FSM`2.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})"/> block.
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.StateTimeout">
            <summary>
            Used in the event of a timeout between transitions
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.LogEntry`2">
            <summary>
            Log entry of the <see cref="T:Akka.Actor.ILoggingFSM"/> - can be obtained by calling <see cref="!:GetLog"/>
            </summary>
            <typeparam name="TS">The name of the state</typeparam>
            <typeparam name="TD">The data of the state</typeparam>
        </member>
        <member name="T:Akka.Actor.FSMBase.State`2">
            <summary>
            This captures all of the managed state of the <see cref="T:Akka.Actor.FSM`2"/>: the state name,
            the state data, possibly custom timeout, stop reason, and replies accumulated while
            processing the last message.
            </summary>
            <typeparam name="TS">The name of the state</typeparam>
            <typeparam name="TD">The data of the state</typeparam>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.ForMax(System.TimeSpan)">
            <summary>
            Modify the state transition descriptor to include a state timeout for the 
            next state. This timeout overrides any default timeout set for the next state.
            <remarks>Use <see cref="F:System.TimeSpan.MaxValue"/> to cancel a timeout.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.Replying(System.Object)">
            <summary>
            Send reply to sender of the current message, if available.
            </summary>
            <param name="replyValue"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.Using(`1)">
            <summary>
            Modify state transition descriptor with new state data. The data will be set
            when transitioning to the new state.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.WithStopReason(Akka.Actor.FSMBase.Reason)">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Event`1">
            <summary>
            All messages sent to the <see cref="T:Akka.Actor.FSM`2"/> will be wrapped inside an <see cref="T:Akka.Actor.FSMBase.Event`1"/>,
            which allows pattern matching to extract both state and data.
            </summary>
            <typeparam name="TD">The state data for this event</typeparam>
        </member>
        <member name="T:Akka.Actor.FSMBase.StopEvent`2">
            <summary>
            Class representing the state of the <see cref="T:Akka.Actor.FSM`2"/> within the OnTermination block.
            </summary>
        </member>
        <member name="T:Akka.Actor.FSM`2">
            <summary>
            Finite state machine (FSM) actor.
            </summary>
            <typeparam name="TState">The state name type</typeparam>
            <typeparam name="TData">The state data type</typeparam>
        </member>
        <member name="M:Akka.Actor.FSM`2.When(`0,Akka.Actor.FSM{`0,`1}.StateFunction,System.Nullable{System.TimeSpan})">
            <summary>
            Insert a new <see cref="T:Akka.Actor.FSM`2.StateFunction"/> at the end of the processing chain for the
            given state. If the stateTimeout parameter is set, entering this state without a
            differing explicit timeout setting will trigger a <see cref="T:Akka.Actor.FSMBase.StateTimeout"/>.
            </summary>
            <param name="stateName">designator for the state</param>
            <param name="func">delegate describing this state's response to input</param>
            <param name="timeout">default timeout for this state</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.StartWith(`0,`1,System.Nullable{System.TimeSpan})">
            <summary>
            Sets the initial state for this FSM. Call this method from the constructor before the <see cref="M:Akka.Actor.FSM`2.Initialize"/> method.
            If different state is needed after a restart this method, followed by <see cref="M:Akka.Actor.FSM`2.Initialize"/>, can be used in the actor
            life cycle hooks <see cref="M:Akka.Actor.ActorBase.PreStart"/> and <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)"/>.
            </summary>
            <param name="stateName">Initial state designator.</param>
            <param name="stateData">Initial state data.</param>
            <param name="timeout">State timeout for the initial state, overriding the default timeout for that state.</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.GoTo(`0)">
            <summary>
            Produce transition to other state. Return this from a state function
            in order to effect the transition.
            </summary>
            <param name="nextStateName">State designator for the next state</param>
            <returns>State transition descriptor</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.GoTo(`0,`1)">
            <summary>
            Produce transition to other state. Return this from a state function
            in order to effect the transition.
            </summary>
            <param name="nextStateName">State designator for the next state</param>
            <param name="stateData">Data for next state</param>
            <returns>State transition descriptor</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.Stay">
            <summary>
            Produce "empty" transition descriptor. Return this from a state function
            when no state change is to be effected.
            </summary>
            <returns>Descriptor for staying in the current state.</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.Stop">
            <summary>
            Produce change descriptor to stop this FSM actor with <see cref="T:Akka.Actor.FSMBase.Reason"/> <see cref="T:Akka.Actor.FSMBase.Normal"/>
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.Stop(Akka.Actor.FSMBase.Reason)">
            <summary>
            Produce change descriptor to stop this FSM actor with the specified <see cref="T:Akka.Actor.FSMBase.Reason"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.SetTimer(System.String,System.Object,System.TimeSpan,System.Boolean)">
            <summary>
            Schedule named timer to deliver message after given delay, possibly repeating.
            Any existing timer with the same name will automatically be canceled before adding
            the new timer.
            </summary>
            <param name="name">identifier to be used with <see cref="M:Akka.Actor.FSM`2.CancelTimer(System.String)"/>.</param>
            <param name="msg">message to be delivered</param>
            <param name="timeout">delay of first message delivery and between subsequent messages.</param>
            <param name="repeat">send once if false, scheduleAtFixedRate if true</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.CancelTimer(System.String)">
            <summary>
            Cancel a named <see cref="T:System.Threading.Timer"/>, ensuring that the message is not subsequently delivered (no race.)
            </summary>
            <param name="name">The name of the timer to cancel.</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.IsTimerActive(System.String)">
            <summary>
            Determines whether the named timer is still active. Returns true 
            unless the timer does not exist, has previously been cancelled, or
            if it was a single-shot timer whose message was already received.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.SetStateTimeout(`0,System.Nullable{System.TimeSpan})">
            <summary>
            Set the state timeout explicitly. This method can be safely used from
            within a state handler.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.OnTransition(Akka.Actor.FSM{`0,`1}.TransitionHandler)">
            <summary>
            Set handler which is called upon each state transition, i.e. not when
            staying in the same state. 
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})">
            <summary>
            Set the handler which is called upon termination of this FSM actor. Calling this
            method again will overwrite the previous contents.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.WhenUnhandled(Akka.Actor.FSM{`0,`1}.StateFunction)">
            <summary>
            Set handler which is called upon reception of unhandled FSM messages. Calling
            this method again will overwrite the previous contents.
            </summary>
            <param name="stateFunction"></param>
        </member>
        <member name="M:Akka.Actor.FSM`2.Initialize">
            <summary>
            Verify the existence of initial state and setup timers. This should be the
            last call within the constructor or <see cref="M:Akka.Actor.ActorBase.PreStart"/> and
            <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)"/>.
            </summary>
        </member>
        <member name="P:Akka.Actor.FSM`2.StateName">
            <summary>
            Current state name
            </summary>
        </member>
        <member name="P:Akka.Actor.FSM`2.StateData">
            <summary>
            Current state data
            </summary>
        </member>
        <member name="P:Akka.Actor.FSM`2.NextStateData">
            <summary>
            Return next state data (available in <see cref="M:Akka.Actor.FSM`2.OnTransition(Akka.Actor.FSM{`0,`1}.TransitionHandler)"/> handlers)
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2.DebugEvent">
            <summary>
            Can be set to enable debugging on certain actions taken by the FSM
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._currentState">
            <summary>
            FSM state data and current timeout handling
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._timers">
            <summary>
            Timer handling
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._stateFunctions">
            <summary>
            State definitions
            </summary>
        </member>
        <member name="P:Akka.Actor.FSM`2.HandleEventDefault">
            <summary>
            Unhandled event handler
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._terminateEvent">
            <summary>
            Termination handling
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._transitionEvent">
            <summary>
            Transition handling
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.OrElse(Akka.Actor.FSM{`0,`1}.StateFunction,Akka.Actor.FSM{`0,`1}.StateFunction)">
            <summary>
            C# port of Scala's orElse method for partial function chaining.
            
            See http://scalachina.com/api/scala/PartialFunction.html
            </summary>
            <param name="original">The original <see cref="T:Akka.Actor.FSM`2.StateFunction"/> to be called</param>
            <param name="fallback">The <see cref="T:Akka.Actor.FSM`2.StateFunction"/> to be called if <paramref name="original"/> returns null</param>
            <returns>A <see cref="T:Akka.Actor.FSM`2.StateFunction"/> which combines both the results of <paramref name="original"/> and <paramref name="fallback"/></returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.Receive(System.Object)">
            <summary>
            Main actor receive method
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Akka.Actor.FSM`2.PostStop">
            <summary>
            Call the <see cref="M:Akka.Actor.FSM`2.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})"/> hook if you want to retain this behavior.
            When overriding make sure to call base.PostStop();
            
            Please note that this method is called by default from <see cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)"/> so
            override that one if <see cref="M:Akka.Actor.FSM`2.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})"/> shall not be called during restart.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.LogTermination(Akka.Actor.FSMBase.Reason)">
            <summary>
            By default, <see cref="T:Akka.Actor.Failure"/> is logged at error level and other
            reason types are not logged. It is possible to override this behavior.
            </summary>
            <param name="reason"></param>
        </member>
        <member name="T:Akka.Actor.ILoggingFSM">
            <summary>
            Marker interface to let the setting "akka.actor.debug.fsm" control if logging should occur in <see cref="T:Akka.Actor.FSM`2"/>
            </summary>
        </member>
        <member name="T:Akka.Actor.GracefulStopSupport">
            <summary>
            Returns a <see cref="T:System.Threading.Tasks.Task"/> that will be completed with success when existing messages
            of the target actor have been processed and the actor has been terminated.
            
            Useful when you need to wait for termination or compose ordered termination of several actors,
            which should only be done outside of the <see cref="T:Akka.Actor.ActorSystem"/> as blocking inside <see cref="T:Akka.Actor.ActorBase"/> is discouraged.
            
            <remarks><c>IMPORTANT:</c> the actor being terminated and its supervisor being informed of the availability of the deceased actor's name
            are two distinct operations, which do not obey any reliable ordering.</remarks>
            
            If the target actor isn't terminated within the timeout the <see cref="T:System.Threading.Tasks.Task"/> is completed with failure.
            
            If you want to invoke specialized stopping logic on your target actor instead of <see cref="T:Akka.Actor.PoisonPill"/>, you can pass your stop command as a parameter:
            <code>
                GracefulStop(someChild, timeout, MyStopGracefullyMessage).ContinueWith(r => {
                    // Do something after someChild starts being stopped.
                });
            </code>
            </summary>
        </member>
        <member name="T:Akka.Actor.IUntypedActorContext">
            <summary>
            Interface IUntypedActorContext
            </summary>
        </member>
        <member name="M:Akka.Actor.IUntypedActorContext.Become(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.IUntypedActorContext.BecomeStacked(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="!:IUntypedActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.IUntypedActorContext.BecomeStacked(Akka.Actor.UntypedReceive)"/>
            is matched with a call to <see cref="!:IUntypedActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="T:Akka.Actor.INoSerializationVerificationNeeded">
            <summary>
                Marker Interface INoSerializationVerificationNeeded, this interface prevents
                implementing message types from being serialized if configuration setting 'akka.actor.serialize-messages' is "on"
            </summary>
        </member>
        <member name="T:Akka.Actor.IPossiblyHarmful">
            <summary>
            Marker interface to indicate that a message might be potentially harmful;
            this is used to block messages coming in over remoting.
            </summary>
        </member>
        <member name="T:Akka.Actor.PipeToSupport">
            <summary>
            Creates the PipeTo pattern for automatically sending the results of completed tasks
            into the inbox of a designated Actor
            </summary>
        </member>
        <member name="M:Akka.Actor.PipeToSupport.PipeTo``1(System.Threading.Tasks.Task{``0},Akka.Actor.ICanTell,Akka.Actor.IActorRef,System.Func{``0,System.Object},System.Func{System.Exception,System.Object})">
            <summary>
            Pipes the output of a Task directly to the <paramref name="recipient"/>'s mailbox once
            the task completes
            </summary>
        </member>
        <member name="M:Akka.Actor.PipeToSupport.PipeTo(System.Threading.Tasks.Task,Akka.Actor.ICanTell,Akka.Actor.IActorRef)">
            <summary>
            Pipes the output of a Task directly to the <paramref name="recipient"/>'s mailbox once
            the task completes.  As this task has no result, only exceptions will be piped to the <paramref name="recipient"/>
            </summary>
        </member>
        <member name="T:Akka.Actor.Receive">
            <summary>
                Delegate Receive
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Actor.ITellScheduler">
            <summary>
            A scheduler that's able to schedule sending messages.
            </summary>
        </member>
        <member name="M:Akka.Actor.ITellScheduler.ScheduleTellOnce(System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="delay">The time period that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
        </member>
        <member name="M:Akka.Actor.ITellScheduler.ScheduleTellOnce(System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="delay">The time period that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="cancelable">An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message has been sent, it cannot be canceled.</param>
        </member>
        <member name="M:Akka.Actor.ITellScheduler.ScheduleTellRepeatedly(System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="initialDelay">The time period that has to pass before the first message is sent.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between messages are being sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
        </member>
        <member name="M:Akka.Actor.ITellScheduler.ScheduleTellRepeatedly(System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="initialDelay">The time period that has to pass before the first message is sent.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between messages are being sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="cancelable">An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message has been sent, it cannot be canceled.</param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellOnce(Akka.Actor.ITellScheduler,System.Int32,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="millisecondsDelay">The time in milliseconds that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="cancelable">OPTIONAL. An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Note that once the message has been sent, it cannot be canceled.</param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellRepeatedly(Akka.Actor.ITellScheduler,System.Int32,System.Int32,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialMillisecondsDelay">The time in milliseconds that has to pass before the first message is sent.</param>
            <param name="millisecondsInterval">The interval, i.e. the time in milliseconds that has to pass between messages are being sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="cancelable">OPTIONAL. An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Note that once the message has been sent, it cannot be canceled.</param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleOnce(Akka.Actor.IActionScheduler,System.Int32,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Schedules an action to be invoked after an delay.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor.
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="millisecondsDelay">The time in milliseconds that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <param name="cancelable">OPTIONAL. A cancelable that can be used to cancel the action from being executed. Defaults to <c>null</c></param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleRepeatedly(Akka.Actor.IActionScheduler,System.Int32,System.Int32,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialMillisecondsDelay">The time in milliseconds that has to pass before first invocation.</param>
            <param name="millisecondsInterval">The interval, i.e. the time in milliseconds that has to pass before the action is invoked again.</param>
            <param name="action">The action to perform.</param>
            <param name="cancelable">OPTIONAL. A cancelable that can be used to cancel the action from being executed. Defaults to <c>null</c></param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellOnceCancelable(Akka.Actor.IScheduler,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="delay">The time period that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <returns>An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message already has been sent, it cannot be cancelled.</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellOnceCancelable(Akka.Actor.IScheduler,System.Int32,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="millisecondsDelay">The time in milliseconds that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <returns>An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message already has been sent, it cannot be cancelled.</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellRepeatedlyCancelable(Akka.Actor.IScheduler,System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialDelay">The time period that has to pass before the first message is sent.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between messages are being sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <returns>An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message already has been sent, it cannot be cancelled.</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellRepeatedlyCancelable(Akka.Actor.IScheduler,System.Int32,System.Int32,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialMillisecondsDelay">The time in milliseconds that has to pass before the first message is sent.</param>
            <param name="millisecondsInterval">The interval, i.e. the time in milliseconds that has to pass between messages are sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <returns>An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message already has been sent, it cannot be cancelled.</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleOnceCancelable(Akka.Actor.IActionScheduler,System.TimeSpan,System.Action)">
            <summary>
            Schedules an action to be invoked after an delay.
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="delay">The time period that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <returns>A cancelable that can be used to cancel the action from being executed</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleOnceCancelable(Akka.Actor.IActionScheduler,System.Int32,System.Action)">
            <summary>
            Schedules an action to be invoked after an delay.
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="millisecondsDelay">The time in milliseconds that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <returns>A cancelable that can be used to cancel the action from being executed</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleRepeatedlyCancelable(Akka.Actor.IActionScheduler,System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialDelay">The time period that has to pass before first invocation.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <returns>A cancelable that can be used to cancel the action from being executed</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleRepeatedlyCancelable(Akka.Actor.IActionScheduler,System.Int32,System.Int32,System.Action)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialMillisecondsDelay">The time in milliseconds that has to pass before first invocation.</param>
            <param name="millisecondsInterval">The interval, i.e. the time in milliseconds that has to pass between the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <returns>A cancelable that can be used to cancel the action from being executed</returns>
        </member>
        <member name="T:Akka.Actor.Scope">
            <summary>
            Defines the scope of a <see cref="T:Akka.Actor.Deploy"/>
            
            Valid values are:
            
            * Local - this actor will be deployed locally in this process
            * Remote - this actor will be deployed remotely on another system
            * Cluster - this actor will be deployed into a cluster of remote processes
            </summary>
        </member>
        <member name="T:Akka.Actor.NoScopeGiven">
            <summary>
            Place-holder for when a scope of this deployment has not been specified yet
            </summary>
        </member>
        <member name="T:Akka.Actor.Settings">
            <summary>
                Settings are the overall ActorSystem Settings which also provides a convenient access to the Config object.
                For more detailed information about the different possible configuration options, look in the Akka .NET
                Documentation under "Configuration"
            </summary>
        </member>
        <member name="M:Akka.Actor.Settings.RebuildConfig">
            <summary>
            Combines the user config and the fallback chain of configs
            </summary>
        </member>
        <member name="M:Akka.Actor.Settings.InjectTopLevelFallback(Akka.Configuration.Config)">
            <summary>
            Injects a system config at the top of the fallback chain
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:Akka.Actor.Settings.#ctor(Akka.Actor.ActorSystem,Akka.Configuration.Config)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Settings" /> class.
            </summary>
            <param name="system">The system.</param>
            <param name="config">The configuration.</param>
        </member>
        <member name="P:Akka.Actor.Settings.System">
            <summary>
                Gets the system.
            </summary>
            <value>The system.</value>
        </member>
        <member name="P:Akka.Actor.Settings.Config">
            <summary>
                Gets the configuration.
            </summary>
            <value>The configuration.</value>
        </member>
        <member name="P:Akka.Actor.Settings.ConfigVersion">
            <summary>
                Gets the configuration version.
            </summary>
            <value>The configuration version.</value>
        </member>
        <member name="P:Akka.Actor.Settings.ProviderClass">
            <summary>
                Gets the provider class.
            </summary>
            <value>The provider class.</value>
        </member>
        <member name="P:Akka.Actor.Settings.SupervisorStrategyClass">
            <summary>
                Gets the supervisor strategy class.
            </summary>
            <value>The supervisor strategy class.</value>
        </member>
        <member name="P:Akka.Actor.Settings.SerializeAllMessages">
            <summary>
                Gets a value indicating whether [serialize all messages].
            </summary>
            <value><c>true</c> if [serialize all messages]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.SerializeAllCreators">
            <summary>
                Gets a value indicating whether [serialize all creators].
            </summary>
            <value><c>true</c> if [serialize all creators]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.AskTimeout">
            <summary>
                Gets the default timeout for <see cref="M:Akka.Actor.Futures.Ask(Akka.Actor.ICanTell,System.Object,System.Nullable{System.TimeSpan})" /> calls.
            </summary>
            <value>The ask timeout.</value>
        </member>
        <member name="P:Akka.Actor.Settings.CreationTimeout">
            <summary>
                Gets the creation timeout.
            </summary>
            <value>The creation timeout.</value>
        </member>
        <member name="P:Akka.Actor.Settings.UnstartedPushTimeout">
            <summary>
                Gets the unstarted push timeout.
            </summary>
            <value>The unstarted push timeout.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LogLevel">
            <summary>
                Gets the log level.
            </summary>
            <value>The log level.</value>
        </member>
        <member name="P:Akka.Actor.Settings.StdoutLogLevel">
            <summary>
                Gets the stdout log level.
            </summary>
            <value>The stdout log level.</value>
        </member>
        <member name="P:Akka.Actor.Settings.Loggers">
            <summary>
                Gets the loggers.
            </summary>
            <value>The loggers.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LoggerStartTimeout">
            <summary>
                Gets the logger start timeout.
            </summary>
            <value>The logger start timeout.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LogConfigOnStart">
            <summary>
                Gets a value indicating whether [log configuration on start].
            </summary>
            <value><c>true</c> if [log configuration on start]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LogDeadLetters">
            <summary>
                Gets the log dead letters.
            </summary>
            <value>The log dead letters.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LogDeadLettersDuringShutdown">
            <summary>
                Gets a value indicating whether [log dead letters during shutdown].
            </summary>
            <value><c>true</c> if [log dead letters during shutdown]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.AddLoggingReceive">
            <summary>
                Gets a value indicating whether [add logging receive].
            </summary>
            <value><c>true</c> if [add logging receive]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugAutoReceive">
            <summary>
                Gets a value indicating whether [debug automatic receive].
            </summary>
            <value><c>true</c> if [debug automatic receive]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugEventStream">
            <summary>
                Gets a value indicating whether [debug event stream].
            </summary>
            <value><c>true</c> if [debug event stream]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugUnhandledMessage">
            <summary>
                Gets a value indicating whether [debug unhandled message].
            </summary>
            <value><c>true</c> if [debug unhandled message]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugRouterMisconfiguration">
            <summary>
                Gets a value indicating whether [debug router misconfiguration].
            </summary>
            <value><c>true</c> if [debug router misconfiguration]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.Home">
            <summary>
                Gets the home.
            </summary>
            <value>The home.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugLifecycle">
            <summary>
                Gets a value indicating whether [debug lifecycle].
            </summary>
            <value><c>true</c> if [debug lifecycle]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DefaultVirtualNodesFactor">
            <summary>
            The number of default virtual nodes to use with <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/>.
            </summary>
        </member>
        <member name="P:Akka.Actor.Settings.SchedulerClass">
            <summary>
            Gets the scheduler implementation used by this system.
            </summary>
        </member>
        <member name="M:Akka.Actor.Settings.ToString">
            <summary>
                Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Actor.IActorStash">
            <summary>
            Marker interface for adding stash support
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorStash.Stash">
            <summary>
            Gets or sets the stash. This will be automatically populated by the framework AFTER the constructor has been run.
            Implement this as an auto property.
            </summary>
            <value>
            The stash.
            </value>
        </member>
        <member name="M:Akka.Actor.ActorStashPlugin.CanBeAppliedTo(System.Type)">
            <summary>
            Stash plugin is applied to all actors implementing <see cref="T:Akka.Actor.IActorStash"/> interface.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorStashPlugin.AfterIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Creates a new stash for specified <paramref name="actor"/> if it has not been initialized already.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorStashPlugin.BeforeIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Ensures, that all stashed messages inside <paramref name="actor"/> stash have been unstashed.
            </summary>
        </member>
        <member name="T:Akka.Actor.IStash">
            <summary>
            Public interface used to expose stash capabilities to user-level actors
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.Stash">
            <summary>
            Stashes the current message (the message that the actor received last)
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.Unstash">
            <summary>
            Unstash the oldest message in the stash and prepends it to the actor's mailbox.
            The message is removed from the stash.
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.UnstashAll">
            <summary>
            Unstashes all messages by prepending them to the actor's mailbox.
            The stash is guaranteed to be empty afterwards.
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.UnstashAll(System.Func{Akka.Actor.Envelope,System.Boolean})">
            <summary>
            Unstashes all messages selected by the predicate function. Other messages are discarded.
            The stash is guaranteed to be empty afterwards.
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.ClearStash">
            <summary>
            Returns all messages and clears the stash.
            The stash is guaranteed to be empty afterwards.
            </summary>
        </member>
        <member name="T:Akka.Actor.UntypedActorWithBoundedStash">
            <summary>
            An UntypedActor with bounded Stash capabilities
            </summary>
        </member>
        <member name="P:Akka.Actor.UntypedActorWithBoundedStash.CurrentStash">
            <summary>
            The stash implementation available for this actor
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithBoundedStash.Stash">
            <summary>
            Stashes the current message
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithBoundedStash.Unstash">
            <summary>
            Unstash the oldest message in the stash
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithBoundedStash.UnstashAll">
            <summary>
            Unstashes all messages
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithBoundedStash.UnstashAll(System.Func{Akka.Actor.Envelope,System.Boolean})">
            <summary>
            Unstashes all messages selected by the predicate function
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithBoundedStash.PreRestart(System.Exception,System.Object)">
            <summary>
            Overridden callback. Prepends all messages in the stash to the mailbox,
            clears the stash, stops all children, and invokes the PostStop callback.
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithBoundedStash.PostStop">
            <summary>
            Overridden callback. Prepends all messages in the stash to the mailbox,
            clears the stash. Must be called when overriding this method; otherwise stashed messages won't be
            propagated to DeadLetters when actor stops.
            </summary>
        </member>
        <member name="T:Akka.Actor.StashFactory">
            <summary>
            Static factor used for creating Stash instances
            </summary>
        </member>
        <member name="T:Akka.Actor.StashOverflowException">
            <summary>
            This exception is thrown when the size of the Stash exceeds the capacity of the stash.
            </summary>
        </member>
        <member name="M:Akka.Actor.StashOverflowException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.StashOverflowException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Actor.StashOverflowException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.StashOverflowException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.UntypedActorWithUnboundedStash">
            <summary>
            An UntypedActor with Unbounded Stash capabilities
            </summary>
        </member>
        <member name="P:Akka.Actor.UntypedActorWithUnboundedStash.CurrentStash">
            <summary>
            The stash implementation available for this actor
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithUnboundedStash.Stash">
            <summary>
            Stashes the current message
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithUnboundedStash.Unstash">
            <summary>
            Unstash the oldest message in the stash
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithUnboundedStash.UnstashAll">
            <summary>
            Unstashes all messages
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithUnboundedStash.UnstashAll(System.Func{Akka.Actor.Envelope,System.Boolean})">
            <summary>
            Unstashes all messages selected by the predicate function
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithUnboundedStash.PreRestart(System.Exception,System.Object)">
            <summary>
            Overridden callback. Prepends all messages in the stash to the mailbox,
            clears the stash, stops all children, and invokes the PostStop callback.
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithUnboundedStash.PostStop">
            <summary>
            Overridden callback. Prepends all messages in the stash to the mailbox,
            clears the stash. Must be called when overriding this method; otherwise stashed messages won't be
            propagated to DeadLetters when actor stops.
            </summary>
        </member>
        <member name="T:Akka.Actor.IWithBoundedStash">
            <summary>
            Lets the <see cref="T:Akka.Actor.StashFactory"/> know that this Actor needs stash support
            with restricted storage capacity
            You need to add the property:
            <code>public IStash Stash { get; set; }</code>
            </summary>
        </member>
        <member name="T:Akka.Actor.IWithUnboundedStash">
            <summary>
            Lets the <see cref="T:Akka.Actor.StashFactory"/> know that this Actor needs stash support
            with unrestricted storage capacity.
            You need to add the property:
            <code>public IStash Stash { get; set; }</code>
            </summary>
        </member>
        <member name="T:Akka.Actor.AkkaException">
            <summary>
            This exception provides the base for all Akka.NET specific exceptions within the system.
            </summary>
        </member>
        <member name="M:Akka.Actor.AkkaException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.AkkaException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.AkkaException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.AkkaException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Actor.AkkaException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.AkkaException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Akka.Actor.AkkaException.Cause">
            <summary>
            The exception that is the cause of the current exception.
            </summary>
        </member>
        <member name="T:Akka.Actor.InvalidActorNameException">
            <summary>
            This exception is thrown when the actor name is invalid.
            </summary>
        </member>
        <member name="M:Akka.Actor.InvalidActorNameException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.InvalidActorNameException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.InvalidActorNameException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.InvalidActorNameException"/> class.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Actor.InvalidActorNameException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.InvalidActorNameException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.AskTimeoutException">
            <summary>
            This exception is thrown when an Ask operation times out.
            </summary>
        </member>
        <member name="M:Akka.Actor.AskTimeoutException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.AskTimeoutException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.AskTimeoutException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.AskTimeoutException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.ActorInitializationException">
            <summary>
            This exception is thrown when the initialization logic for an Actor fails.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorInitializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorInitializationException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorInitializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.ActorInitializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Actor.ActorInitializationException.#ctor(Akka.Actor.IActorRef,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorInitializationException"/> class.
            </summary>
            <param name="actor">The actor whose initialization logic failed.</param>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Actor.ActorInitializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorInitializationException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Akka.Actor.ActorInitializationException.Actor">
            <summary>
            Retrieves the actor whose initialization logic failed.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorInitializationException.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Actor.LoggerInitializationException">
            <summary>
            This exception is thrown when there was a problem initializing a logger.
            </summary>
        </member>
        <member name="M:Akka.Actor.LoggerInitializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.LoggerInitializationException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.LoggerInitializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.LoggerInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.LoggerInitializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.LoggerInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Actor.LoggerInitializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.LoggerInitializationException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.ActorKilledException">
            <summary>
            This exception is thrown when a <see cref="T:Akka.Actor.Kill"/> message has been sent to an Actor.
            <see cref="F:Akka.Actor.SupervisorStrategy.DefaultDecider"/> will by default stop the actor.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorKilledException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorKilledException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.ActorKilledException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorKilledException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.IllegalActorStateException">
            <summary>
            This exception is thrown when a core invariant in the Actor implementation has been violated.
            For instance, if you try to create an Actor that doesn't inherit from <see cref="T:Akka.Actor.ActorBase" />.
            </summary>
        </member>
        <member name="M:Akka.Actor.IllegalActorStateException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.IllegalActorStateException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.IllegalActorStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.IllegalActorStateException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.IllegalActorNameException">
            <summary>
            This exception is thrown when an Actor with an invalid name is deployed.
            </summary>
        </member>
        <member name="M:Akka.Actor.IllegalActorNameException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.IllegalActorNameException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.IllegalActorNameException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.IllegalActorNameException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.DeathPactException">
            <summary>
            This exception is thrown by an Actor that receives a Terminated(someActor) message
            that it doesn't handle itself, effectively crashing the Actor and escalating to the supervisor.
            </summary>
        </member>
        <member name="M:Akka.Actor.DeathPactException.#ctor(Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.DeathPactException"/> class.
            </summary>
            <param name="deadActor">The actor that has been terminated.</param>
        </member>
        <member name="M:Akka.Actor.DeathPactException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.DeathPactException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Akka.Actor.DeathPactException.DeadActor">
            <summary>
            Retrieves the actor that has been terminated.
            </summary>
        </member>
        <member name="T:Akka.Actor.PreRestartException">
             <summary>
             This exception is thrown when the <see cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)"/> method fails during a restart attempt.
            
             <note>
             This exception is not propagated to the supervisor, as it originates from the already failed instance,
             hence it is only visible as log entry on the event stream.
             </note>
             </summary>
        </member>
        <member name="M:Akka.Actor.PreRestartException.#ctor(Akka.Actor.IActorRef,System.Exception,System.Exception,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.PreRestartException"/> class.
            </summary>
            <param name="actor">The actor whose <see cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)"/> hook failed.</param>
            <param name="restartException">The exception thrown by the <paramref name="actor"/> within <see cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)"/>.</param>
            <param name="cause">The exception which caused the restart in the first place.</param>
            <param name="optionalMessage">The message which was optionally passed into <see cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)"/>.</param>
        </member>
        <member name="M:Akka.Actor.PreRestartException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.PreRestartException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.PostRestartException">
            <summary>
            This exception is thrown when the Actor constructor or <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)"/> method
            fails during a restart attempt.
            </summary>
        </member>
        <member name="M:Akka.Actor.PostRestartException.#ctor(Akka.Actor.IActorRef,System.Exception,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.PostRestartException"/> class.
            </summary>
            <param name="actor">The actor whose constructor or <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)"/> hook failed.</param>
            <param name="cause">The exception thrown by the <paramref name="actor"/> within <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)"/>.</param>
            <param name="originalCause">The original cause is the exception which caused the restart in the first place.</param>
        </member>
        <member name="M:Akka.Actor.PostRestartException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.PostRestartException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Akka.Actor.PostRestartException.OriginalCause">
            <summary>
             Retrieves the exception which caused the restart in the first place.
             </summary>
        </member>
        <member name="T:Akka.Actor.ActorNotFoundException">
            <summary>
            This exception is thrown when an Actor can not be found.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorNotFoundException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorNotFoundException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorNotFoundException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:Akka.Actor.ActorNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            <see cref="T:Akka.Actor.ActorNotFoundException"/> that takes a descriptive <paramref name="message"/> and optional <paramref name="innerException"/>.
            </summary>
            <param name="message">A user-defined error message.</param>
            <param name="innerException">An inner <see cref="T:System.Exception"/>.</param>
        </member>
        <member name="T:Akka.Actor.InvalidMessageException">
             <summary>
             This exception is thrown when an invalid message is sent to an Actor.
            
             <note>
             Currently only <c>null</c> is an invalid message.
             </note>
             </summary>
        </member>
        <member name="M:Akka.Actor.InvalidMessageException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.InvalidMessageException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.InvalidMessageException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.InvalidMessageException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.InvalidMessageException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.InvalidMessageException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:Akka.Actor.ICanWatch.Watch(Akka.Actor.IActorRef)">
            <summary>
            Monitors the specified actor for termination. When the <paramref name="subject"/> terminates
            the instance watching will receive a <see cref="T:Akka.Actor.Terminated"/> message.
            <remarks>Note that if the <see cref="T:Akka.Actor.Terminated"/> message isn't handled by the actor,
            by default the actor will crash by throwing a <see cref="T:Akka.Actor.DeathPactException"/>. To change
            the default behavior, override <see cref="M:Akka.Actor.ActorBase.Unhandled(System.Object)"/>.
            </remarks>
            </summary>
            <param name="subject">The actor to monitor for termination.</param>
            <returns>Returns the provided subject</returns>
        </member>
        <member name="M:Akka.Actor.ICanWatch.Unwatch(Akka.Actor.IActorRef)">
            <summary>
            Stops monitoring the <paramref name="subject"/> for termination.
            </summary>
            <param name="subject">The actor to stop monitor for termination.</param>
            <returns>Returns the provided subject</returns>
        </member>
        <member name="P:Akka.Actor.IActorContext.Self">
            <summary>
            Gets the <see cref="T:Akka.Actor.IActorRef"/> belonging to the current actor.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.Sender">
            <summary>
            Gets the <see cref="T:Akka.Actor.IActorRef"/> of the actor who sent the current message.
            
            If the message was not sent by an actor (i.e. some external non-actor code
            sent this actor a message) then this value will default to <see cref="F:Akka.Actor.ActorRefs.NoSender"/>.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.System">
            <summary>
            Gets a reference to the <see cref="T:Akka.Actor.ActorSystem"/> to which this actor belongs.
            
            <remarks>
            This property is how you can get access to the <see cref="T:Akka.Actor.IScheduler"/> and other parts
            of Akka.NET from within an actor instance.
            </remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.Parent">
            <summary>
            Gets the <see cref="T:Akka.Actor.IActorRef"/> of the parent of the current actor.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorContext.Become(Akka.Actor.Receive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.IActorContext.BecomeStacked(Akka.Actor.Receive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.IActorContext.BecomeStacked(Akka.Actor.Receive)"/>
            is matched with a call to <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.IActorContext.UnbecomeStacked">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the previous one on the behavior stack.
            <remarks>In order to store an actor on the behavior stack, a call to <see cref="M:Akka.Actor.IActorContext.BecomeStacked(Akka.Actor.Receive)"/> must have been made
            prior to this call</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorContext.Child(System.String)">
            <summary>
            Retrieves a child actor with the specified name, if it exists.
            
            If the child with the given name cannot be found, 
            then <see cref="F:Akka.Actor.ActorRefs.Nobody"/> will be returned instead.
            </summary>
            <param name="name">
            The name of the child actor.
            
            e.g. "child1", "foo"
            
            Not the path, just the name of the child at the time it was created by this parent.
            </param>
            <returns>The <see cref="T:Akka.Actor.IActorRef"/> belonging to the child if found, <see cref="F:Akka.Actor.ActorRefs.Nobody"/> otherwise.</returns>
        </member>
        <member name="M:Akka.Actor.IActorContext.GetChildren">
            <summary>
            Gets all of the children that belong to this actor.
            
            If this actor has no children, 
            an empty collection of <see cref="T:Akka.Actor.IActorRef"/> is returned instead.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorContext.SetReceiveTimeout(System.Nullable{System.TimeSpan})">
            <summary>
            <para>
            Defines the inactivity timeout after which the sending of a <see cref="P:Akka.Actor.IActorContext.ReceiveTimeout"/> message is triggered.
            When specified, the receive function should be able to handle a <see cref="P:Akka.Actor.IActorContext.ReceiveTimeout"/> message.
            </para>
            
            <para>
            Please note that the receive timeout might fire and enqueue the <see cref="P:Akka.Actor.IActorContext.ReceiveTimeout"/> message right after
            another message was enqueued; hence it is not guaranteed that upon reception of the receive
            timeout there must have been an idle period beforehand as configured via this method.
            </para>
            
            <para>
            Once set, the receive timeout stays in effect (i.e. continues firing repeatedly after inactivity
            periods). Pass in <c>null</c> to switch off this feature.
            </para>
            </summary>
            <param name="timeout">The timeout. Pass in <c>null</c> to switch off this feature.</param>
        </member>
        <member name="P:Akka.Actor.IActorContext.ReceiveTimeout">
            <summary>
            Gets the inactivity deadline timeout set using <see cref="M:Akka.Actor.IActorContext.SetReceiveTimeout(System.Nullable{System.TimeSpan})"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorContext.Stop(Akka.Actor.IActorRef)">
            <summary>
            Issues a stop command to the provided <see cref="T:Akka.Actor.IActorRef"/>, which will cause that actor
            to terminate.
            </summary>
        </member>
        <member name="T:Akka.Actor.IActorRefFactory">
            <summary>
            Interface IActorRefFactory
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorRefFactory.ActorOf(Akka.Actor.Props,System.String)">
            <summary>
            Create new actor as child of this context with the given name, which must
            not start with “$”. If the given name is already in use,
            and `InvalidActorNameException` is thrown.
            See <see cref="T:Akka.Actor.Props"/> for details on how to obtain a <see cref="T:Akka.Actor.Props"/> object.
            @throws akka.actor.InvalidActorNameException if the given name is
            invalid or already in use
            @throws akka.ConfigurationException if deployment, dispatcher
            or mailbox configuration is wrong
            </summary>
            <param name="props">The props.</param>
            <param name="name">The name.</param>
            <returns>InternalActorRef.</returns>
        </member>
        <member name="M:Akka.Actor.IActorRefFactory.ActorSelection(Akka.Actor.ActorPath)">
            <summary>
            Construct an <see cref="T:Akka.Actor.ActorSelection" /> from the given path, which is
            parsed for wildcards (these are replaced by regular expressions
            internally). No attempt is made to verify the existence of any part of
            the supplied path, it is recommended to send a message and gather the
            replies in order to resolve the matching set of actors.
            </summary>
            <param name="actorPath">The actor path.</param>
            <returns>ActorSelection.</returns>
        </member>
        <member name="M:Akka.Actor.IActorRefFactory.ActorSelection(System.String)">
            <summary>
            Construct an <see cref="T:Akka.Actor.ActorSelection" /> from the given path, which is
            parsed for wildcards (these are replaced by regular expressions
            internally). No attempt is made to verify the existence of any part of
            the supplied path, it is recommended to send a message and gather the
            replies in order to resolve the matching set of actors.
            </summary>
            <param name="actorPath">The actor path.</param>
            <returns>ActorSelection.</returns>
        </member>
        <member name="T:Akka.Actor.Props">
            <summary>
                Props is a configuration object used in creating an <see cref="T:Akka.Actor.ActorBase">Actor</see>; it is
                immutable, so it is thread-safe and fully shareable.
            <example>
            <code>
              private Props props = Props.Empty();
              private Props props = Props.Create(() => new MyActor(arg1, arg2));
            
              private Props otherProps = props.WithDispatcher("dispatcher-id");
              private Props otherProps = props.WithDeploy(deployment info);
             </code>
             </example>
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.defaultDeploy">
            <summary>
                The default deploy
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.noArgs">
            <summary>
                No args
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.empty">
            <summary>
                A Props instance whose creator will create an actor that doesn't respond to any message
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.None">
            <summary>
                The none
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.defaultProducer">
            <summary>
                The default producer
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.inputType">
            <summary>
                The intern type of the actor or the producer
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.outputType">
            <summary>
                The extern type of the actor
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.producer">
            <summary>
                The producer of the actor
            </summary>
        </member>
        <member name="M:Akka.Actor.Props.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(Akka.Actor.Props)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class from a copy.
            </summary>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(System.Type,System.Object[])">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            </summary>
            <param name="type">The type.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(System.Type)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(System.Type,Akka.Actor.SupervisorStrategy,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            </summary>
            <param name="type">The type.</param>
            <param name="supervisorStrategy">The supervisor strategy.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(System.Type,Akka.Actor.SupervisorStrategy,System.Object[])">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            </summary>
            <param name="type">The type.</param>
            <param name="supervisorStrategy">The supervisor strategy.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(Akka.Actor.Deploy,System.Type,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            </summary>
            <param name="deploy">The deploy.</param>
            <param name="type">The type.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(Akka.Actor.Deploy,System.Type,System.Object[])">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            </summary>
            <param name="deploy">The deploy.</param>
            <param name="type">The type.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="P:Akka.Actor.Props.Type">
            <summary>
                Gets the type.
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Akka.Actor.Props.Dispatcher">
            <summary>
                Gets or sets the dispatcher.
            </summary>
            <value>The dispatcher.</value>
        </member>
        <member name="P:Akka.Actor.Props.Mailbox">
            <summary>
                Gets or sets the mailbox.
            </summary>
            <value>The mailbox.</value>
        </member>
        <member name="P:Akka.Actor.Props.RouterConfig">
            <summary>
                Gets or sets the router configuration.
            </summary>
            <value>The router configuration.</value>
        </member>
        <member name="P:Akka.Actor.Props.Deploy">
            <summary>
                Gets or sets the deploy.
            </summary>
            <value>The deploy.</value>
        </member>
        <member name="P:Akka.Actor.Props.SupervisorStrategy">
            <summary>
                Gets or sets the supervisor strategy.
            </summary>
            <value>The supervisor strategy.</value>
        </member>
        <member name="P:Akka.Actor.Props.Empty">
            <summary>
                A Props instance whose creator will create an actor that doesn't respond to any message
            </summary>
            <value>The empty.</value>
        </member>
        <member name="P:Akka.Actor.Props.Arguments">
            <summary>
                Gets the arguments.
            </summary>
            <value>The arguments.</value>
        </member>
        <member name="M:Akka.Actor.Props.Create``1(System.Linq.Expressions.Expression{System.Func{``0}},Akka.Actor.SupervisorStrategy)">
            <summary>
                Creates the specified factory.
            </summary>
            <typeparam name="TActor">The type of the actor.</typeparam>
            <param name="factory">The factory.</param>
            <param name="supervisorStrategy">Optional: Supervisor strategy</param>
            <returns>Props.</returns>
            <exception cref="T:System.ArgumentException">The create function must be a 'new T (args)' expression</exception>
        </member>
        <member name="M:Akka.Actor.Props.Create``1(System.Object[])">
            <summary>
                Creates this instance.
            </summary>
            <typeparam name="TActor">The type of the actor.</typeparam>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.CreateBy``1(System.Object[])">
            <summary>
                Creates an actor by an actor producer
            </summary>
            <typeparam name="TProducer">The type of the actor producer</typeparam>
            <param name="args">The arguments</param>
            <returns>Props</returns>
        </member>
        <member name="M:Akka.Actor.Props.Create``1(Akka.Actor.SupervisorStrategy)">
            <summary>
                Creates this instance.
            </summary>
            <typeparam name="TActor">The type of the actor.</typeparam>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.Create(System.Type,System.Object[])">
            <summary>
                Creates the specified type.
            </summary>
            <param name="type">The type.</param>
            <param name="args"></param>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithMailbox(System.String)">
            <summary>
                Returns a new Props with the specified mailbox set.
            </summary>
            <param name="path">The path.</param>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithDispatcher(System.String)">
            <summary>
                Returns a new Props with the specified dispatcher set.
            </summary>
            <param name="path">The path.</param>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithRouter(Akka.Routing.RouterConfig)">
            <summary>
                Returns a new Props with the specified router config set.
            </summary>
            <param name="routerConfig">The router configuration.</param>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithDeploy(Akka.Actor.Deploy)">
            <summary>
                Returns a new Props with the specified deployment configuration.
            </summary>
            <param name="deploy">The deploy.</param>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
                Returns a new Props with the specified supervisor strategy set.
            </summary>
            <param name="strategy">The strategy.</param>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.NewActor">
            <summary>
                Create a new actor instance. This method is only useful when called during
                actor creation by the ActorSystem.
            </summary>
            <returns>ActorBase.</returns>
        </member>
        <member name="M:Akka.Actor.Props.Copy">
            <summary>
                Copies this instance.
            </summary>
            <returns>Props.</returns>
        </member>
        <member name="T:Akka.Actor.Props.EmptyActor">
            <summary>
            EmptyActor is used by <see cref="F:Akka.Actor.Props.None"/> in order to create actors that
            don't respond to any messages.
            </summary>
        </member>
        <member name="T:Akka.Actor.DynamicProps`1">
            <summary>
                Props instance that uses dynamic invocation to create new Actor instances,
                rather than a traditional Activator.
                Intended to be used in conjunction with Dependency Injection.
            </summary>
            <typeparam name="TActor">The type of the actor.</typeparam>
        </member>
        <member name="F:Akka.Actor.DynamicProps`1.invoker">
            <summary>
                The _invoker
            </summary>
        </member>
        <member name="M:Akka.Actor.DynamicProps`1.#ctor(System.Func{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.DynamicProps`1" /> class.
            </summary>
            <param name="invoker">The invoker.</param>
        </member>
        <member name="M:Akka.Actor.DynamicProps`1.NewActor">
            <summary>
                News the actor.
            </summary>
            <returns>ActorBase.</returns>
        </member>
        <member name="M:Akka.Actor.DynamicProps`1.#ctor(Akka.Actor.Props,System.Func{`0})">
            <summary>
                Copy constructor
            </summary>
            <param name="copy">The copy.</param>
            <param name="invoker">The invoker.</param>
        </member>
        <member name="M:Akka.Actor.DynamicProps`1.Copy">
            <summary>
                Copies this instance.
            </summary>
            <returns>Props.</returns>
        </member>
        <member name="T:Akka.Actor.IIndirectActorProducer">
            <summary>
                This interface defines a class of actor creation strategies deviating from
                the usual default of just reflectively instantiating the <see cref="T:Akka.Actor.ActorBase">Actor</see>
                subclass. It can be used to allow a dependency injection framework to
                determine the actual actor class and how it shall be instantiated.
            </summary>
        </member>
        <member name="M:Akka.Actor.IIndirectActorProducer.Produce">
            <summary>
                This factory method must produce a fresh actor instance upon each
                invocation. It is not permitted to return the same instance more than
                once.
            </summary>
            <returns>A fresh actor instance.</returns>
        </member>
        <member name="P:Akka.Actor.IIndirectActorProducer.ActorType">
            <summary>
                This method is used by <see cref="T:Akka.Actor.Props"/> to determine the type of actor which will
                be created. The returned type is not used to produce the actor.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Akka.Actor.IIndirectActorProducer.Release(Akka.Actor.ActorBase)" -->
        <member name="T:Akka.Actor.SupervisorStrategy">
            <summary>
                Base class for supervision strategies
            </summary>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.Handle(Akka.Actor.IActorRef,System.Exception)">
            <summary>
                Handles the specified child.
            </summary>
            <param name="child">The actor that caused the evaluation to occur</param>
            <param name="x">The exception that caused the evaluation to occur.</param>
            <returns>Directive.</returns>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.HandleFailure(Akka.Actor.ActorCell,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})">
            <summary>
                This is the main entry point: in case of a child’s failure, this method
                must try to handle the failure by resuming, restarting or stopping the
                child (and returning `true`), or it returns `false` to escalate the
                failure, which will lead to this actor re-throwing the exception which
                caused the failure. The exception will not be wrapped.
                This method calls <see cref="T:Akka.Actor.SupervisorStrategy"/>, which will
                log the failure unless it is escalated. You can customize the logging by
                setting <see cref="T:Akka.Actor.SupervisorStrategy" /> to `false` and
                do the logging inside the `decider` or override the `LogFailure` method.
            </summary>
            <param name="actorCell">The actor cell.</param>
            <param name="cause">The cause.</param>
            <param name="failedChildStats">The stats for the failed child.</param>
            <param name="allChildren"></param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="F:Akka.Actor.SupervisorStrategy.DefaultDecider">
            <summary>
                When supervisorStrategy is not specified for an actor this
                Decider is used by default in the supervisor strategy.
                The child will be stopped when <see cref="T:Akka.Actor.ActorInitializationException"/>,
                <see cref="T:Akka.Actor.ActorKilledException"/>, or <see cref="T:Akka.Actor.DeathPactException"/> is
                thrown. It will be restarted for other `Exception` types.
                The error is escalated if it's a `Exception`, i.e. `Error`.
            </summary>
            <returns>Directive.</returns>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.RestartChild(Akka.Actor.IActorRef,System.Exception,System.Boolean)">
            <summary>
                Restarts the child.
            </summary>
            <param name="child">The child.</param>
            <param name="cause">The cause.</param>
            <param name="suspendFirst">if set to <c>true</c> [suspend first].</param>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.ProcessFailure(Akka.Actor.IActorContext,System.Boolean,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})">
            <summary>
            This method is called to act on the failure of a child: restart if the flag is true, stop otherwise.
            </summary>
            <param name="context">The actor context.</param>
            <param name="restart">if set to <c>true</c> restart, stop otherwise.</param>
            <param name="cause">The exception that caused the child to fail.</param>
            <param name="failedChildStats">The stats for the child that failed. The ActorRef to the child can be obtained via the <see cref="P:Akka.Actor.Internal.ChildRestartStats.Child"/> property</param>
            <param name="allChildren">The stats for all children</param>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.ResumeChild(Akka.Actor.IActorRef,System.Exception)">
            <summary>
             Resume the previously failed child: <b>do never apply this to a child which
             is not the currently failing child</b>. Suspend/resume needs to be done in
             matching pairs, otherwise actors will wake up too soon or never at all.
            </summary>
            <param name="child">The child.</param>
            <param name="exception">The exception.</param>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.LogFailure(Akka.Actor.IActorContext,Akka.Actor.IActorRef,System.Exception,Akka.Actor.Directive)">
            <summary>
                Logs the failure.
            </summary>
            <param name="context">The actor cell.</param>
            <param name="child">The child.</param>
            <param name="cause">The cause.</param>
            <param name="directive">The directive.</param>
        </member>
        <member name="F:Akka.Actor.SupervisorStrategy.DefaultStrategy">
            <summary>
                When supervisorStrategy is not specified for an actor this
                is used by default. OneForOneStrategy with decider defined in
                <see cref="F:Akka.Actor.SupervisorStrategy.DefaultDecider" />.
            </summary>
            <value>The default.</value>
        </member>
        <member name="F:Akka.Actor.SupervisorStrategy.StoppingStrategy">
            <summary>
                This strategy resembles Erlang in that failing children are always
                terminated (one-for-one).
            </summary>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.HandleChildTerminated(Akka.Actor.IActorContext,Akka.Actor.IActorRef,System.Collections.Generic.IEnumerable{Akka.Actor.IInternalActorRef})">
            <summary>
            This method is called after the child has been removed from the set of children.
            It does not need to do anything special. Exceptions thrown from this method
            do NOT make the actor fail if this happens during termination.
            </summary>
        </member>
        <member name="T:Akka.Actor.OneForOneStrategy">
            <summary>
                Class OneForOneStrategy. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.OneForOneStrategy" /> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeRange">duration of the time window for maxNrOfRetries, Duration.Inf means no window.</param>
            <param name="localOnlyDecider">mapping from Exception to <see cref="T:Akka.Actor.Directive" /></param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},Akka.Actor.IDecider)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.OneForOneStrategy" /> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeRange">duration of the time window for maxNrOfRetries, Duration.Inf means no window.</param>
            <param name="decider">mapping from Exception to <see cref="T:Akka.Actor.Directive" /></param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Int32,System.Int32,System.Func{System.Exception,Akka.Actor.Directive},System.Boolean)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.OneForOneStrategy" /> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeMilliseconds">duration in milliseconds of the time window for <paramref name="maxNrOfRetries"/>, negative values means no window.</param>
            <param name="localOnlyDecider">Mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Int32,System.Int32,Akka.Actor.IDecider,System.Boolean)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.OneForOneStrategy" /> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeMilliseconds">duration in milliseconds of the time window for <paramref name="maxNrOfRetries"/>, negative values means no window.</param>
            <param name="decider">Mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(Akka.Actor.IDecider)">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor">
            <summary>
            Serialization-friendly constructor
            </summary>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.Handle(Akka.Actor.IActorRef,System.Exception)">
            <summary>
                Handles the specified child.
            </summary>
            <param name="child">The child.</param>
            <param name="x">The x.</param>
            <returns>Directive.</returns>
        </member>
        <member name="T:Akka.Actor.AllForOneStrategy">
            <summary>
                Class AllForOneStrategy. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.AllForOneStrategy" /> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value and null means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeRange">duration of the time window for maxNrOfRetries, <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> means no window.</param>
            <param name="localOnlyDecider">mapping from Exception to <see cref="T:Akka.Actor.Directive"/></param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},Akka.Actor.IDecider)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.AllForOneStrategy" /> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value and null means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeRange">duration of the time window for maxNrOfRetries, <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> means no window.</param>
            <param name="decider">mapping from Exception to <see cref="T:Akka.Actor.Directive"/></param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Int32,System.Int32,System.Func{System.Exception,Akka.Actor.Directive},System.Boolean)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.AllForOneStrategy" /> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeMilliseconds">duration in milliseconds of the time window for <paramref name="maxNrOfRetries"/>, negative values means no window.</param>
            <param name="localOnlyDecider">Mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Int32,System.Int32,Akka.Actor.IDecider,System.Boolean)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.AllForOneStrategy" /> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeMilliseconds">duration in milliseconds of the time window for <paramref name="maxNrOfRetries"/>, negative values means no window.</param>
            <param name="decider">Mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(Akka.Actor.IDecider)">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor">
            <summary>
            Serialization-friendly constructor
            </summary>]
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.Handle(Akka.Actor.IActorRef,System.Exception)">
            <summary>
                Determines what to do with the child when the given exception occurs.
            </summary>
            <param name="child">The child.</param>
            <param name="x">The x.</param>
            <returns>Directive.</returns>
        </member>
        <member name="T:Akka.Actor.Failures">
            <summary>
                Collection of failures, used to keep track of how many times a given actor have failed.
            </summary>
        </member>
        <member name="M:Akka.Actor.Failures.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Failures" /> class.
            </summary>
        </member>
        <member name="P:Akka.Actor.Failures.Entries">
            <summary>
                Gets the entries.
            </summary>
            <value>The entries.</value>
        </member>
        <member name="T:Akka.Actor.Failure">
            <summary>
                Represents a single failure.
            </summary>
        </member>
        <member name="P:Akka.Actor.Failure.Exception">
            <summary>
                The exception that caused the failure.
            </summary>
            <value>The exception.</value>
        </member>
        <member name="P:Akka.Actor.Failure.Timestamp">
            <summary>
                The timestamp when the failure occurred.
            </summary>
            <value>The timestamp.</value>
        </member>
        <member name="T:Akka.Actor.Directive">
            <summary>
                Enum Directive for supervisor actions
            </summary>
        </member>
        <member name="F:Akka.Actor.Directive.Resume">
            <summary>
                Resumes message processing for the failed Actor
            </summary>
        </member>
        <member name="F:Akka.Actor.Directive.Restart">
            <summary>
                Discards the old Actor instance and replaces it with a new,
                then resumes message processing.
            </summary>
        </member>
        <member name="F:Akka.Actor.Directive.Escalate">
            <summary>
                Escalates the failure to the supervisor of the supervisor,
                by rethrowing the cause of the failure, i.e. the supervisor fails with
                the same exception as the child.
            </summary>
        </member>
        <member name="F:Akka.Actor.Directive.Stop">
            <summary>
                Stops the Actor
            </summary>
        </member>
        <member name="T:Akka.Actor.UntypedActor">
            <summary>
            Class UntypedActor.
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActor.OnReceive(System.Object)">
            <summary>
            To be implemented by concrete UntypedActor, this defines the behavior of the UntypedActor.
            This method is called for every message received by the actor.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Actor.UntypedActor.Become(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.UntypedActor.BecomeStacked(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="!:IUntypedActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.UntypedActor.BecomeStacked(Akka.Actor.UntypedReceive)"/>
            is matched with a call to <see cref="!:IUntypedActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.#ctor(Akka.Actor.ActorSystem,Akka.Actor.Props,Akka.Dispatch.MessageDispatcher,System.Func{Akka.Dispatch.Mailbox},Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath,System.Func{Akka.Actor.LocalActorRef,Akka.Actor.ActorCell})">
            <summary>
            Inheritors should only call this constructor
            </summary>
        </member>
        <member name="T:Akka.Actor.Envelope">
            <summary>
                Envelope class, represents a message and the sender of the message.    
            </summary>
        </member>
        <member name="P:Akka.Actor.Envelope.Sender">
            <summary>
                Gets or sets the sender.
            </summary>
            <value>The sender.</value>
        </member>
        <member name="P:Akka.Actor.Envelope.Message">
            <summary>
                Gets or sets the message.
            </summary>
            <value>The message.</value>
        </member>
        <member name="T:Akka.Actor.UntypedReceive">
            <summary>
                Delegate UntypedReceive
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Actor.IHandle`1">
            <summary>
                Interface IHandle
            </summary>
            <typeparam name="TMessage">The type of the t message.</typeparam>
        </member>
        <member name="M:Akka.Actor.IHandle`1.Handle(`0)">
            <summary>
                Handles the specified message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Actor.TypedActor">
            <summary>
                Class TypedActor.
            </summary>
        </member>
        <member name="M:Akka.Actor.TypedActor.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Configuration.ConfigurationException">
            <summary>
            The exception that is thrown when a configuration is invalid.
            </summary>
        </member>
        <member name="M:Akka.Configuration.ConfigurationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.ConfigurationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Configuration.ConfigurationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.ConfigurationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="exception">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Configuration.ConfigurationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.ConfigurationException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Configuration.ConfigurationFactory">
            <summary>
            This class contains methods used to retrieve configuration information
            from a variety of sources including user-supplied strings, configuration
            files and assembly resources.
            </summary>
        </member>
        <member name="P:Akka.Configuration.ConfigurationFactory.Empty">
            <summary>
            Generates an empty configuration.
            </summary>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.ParseString(System.String,System.Func{System.String,Akka.Configuration.Hocon.HoconRoot})">
            <summary>
            Generates a configuration defined in the supplied
            HOCON (Human-Optimized Config Object Notation) string.
            </summary>
            <param name="hocon">A string that contains configuration options to use.</param>
            <param name="includeCallback">callback used to resolve includes</param>
            <returns>The configuration defined in the supplied HOCON string.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.ParseString(System.String)">
            <summary>
            Generates a configuration defined in the supplied
            HOCON (Human-Optimized Config Object Notation) string.
            </summary>
            <param name="hocon">A string that contains configuration options to use.</param>
            <returns>The configuration defined in the supplied HOCON string.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.Load">
            <summary>
            Loads a configuration defined in the current application's
            configuration file, e.g. app.config or web.config
            </summary>
            <returns>The configuration defined in the configuration file.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.Default">
            <summary>
            Retrieves the default configuration that Akka.NET uses
            when no configuration has been defined.
            </summary>
            <returns>The configuration that contains default values for all options.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.FromResource(System.String)">
            <summary>
            Retrieves a configuration defined in a resource of the
            current executing assembly.
            </summary>
            <param name="resourceName">The name of the resource that contains the configuration.</param>
            <returns>The configuration defined in the current executing assembly.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.FromResource(System.String,System.Object)">
            <summary>
            Retrieves a configuration defined in a resource of the
            assembly containing the supplied instance object.
            </summary>
            <param name="resourceName">The name of the resource that contains the configuration.</param>
            <param name="instanceInAssembly">An instance object located in the assembly to search.</param>
            <returns>The configuration defined in the assembly that contains the instanced object.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.FromResource``1(System.String)">
            <summary>
            Retrieves a configuration defined in a resource of the assembly
            containing the supplied type <typeparamref name="TAssembly"/>.
            </summary>
            <typeparam name="TAssembly">A type located in the assembly to search.</typeparam>
            <param name="resourceName">The name of the resource that contains the configuration.</param>
            <returns>The configuration defined in the assembly that contains the type <typeparamref name="TAssembly"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.FromResource(System.String,System.Reflection.Assembly)">
            <summary>
            Retrieves a configuration defined in a resource of the supplied assembly.
            </summary>
            <param name="resourceName">The name of the resource that contains the configuration.</param>
            <param name="assembly">The assembly that contains the given resource.</param>
            <returns>The configuration defined in the assembly that contains the given resource.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.FromObject(System.Object)">
            <summary>
            Creates a configuration based on the supplied source object
            </summary>
            <param name="source">The source object</param>
            <returns>The configuration created from the source object</returns>
        </member>
        <member name="T:Akka.Configuration.Config">
            <summary>
            This class represents the main configuration object used by Akka.NET
            when configuring objects within the system. To put it simply, it's
            the internal representation of a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Config.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Config"/> class.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Config.#ctor(Akka.Configuration.Hocon.HoconRoot)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Config"/> class.
            </summary>
            <param name="root">The root node to base this configuration.</param>
            <exception cref="T:System.ArgumentNullException">"The root value cannot be null."</exception>
        </member>
        <member name="M:Akka.Configuration.Config.#ctor(Akka.Configuration.Config,Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Config"/> class.
            </summary>
            <param name="source">The configuration to use as the primary source.</param>
            <param name="fallback">The configuration to use as a secondary source.</param>
            <exception cref="T:System.ArgumentNullException">The source configuration cannot be null.</exception>
        </member>
        <member name="P:Akka.Configuration.Config.Fallback">
            <summary>
            The configuration used as a secondary source.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Config.IsEmpty">
            <summary>
            Determines if this root node contains any values
            </summary>
        </member>
        <member name="P:Akka.Configuration.Config.Root">
            <summary>
            The root node of this configuration section
            </summary>
        </member>
        <member name="P:Akka.Configuration.Config.Substitutions">
            <summary>
            An enumeration of substitutions values
            </summary>
        </member>
        <member name="M:Akka.Configuration.Config.Copy">
            <summary>
            Generates a deep clone of the current configuration.
            </summary>
            <returns>A deep clone of the current configuration</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetBoolean(System.String,System.Boolean)">
            <summary>
            Retrieves a boolean value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <returns>The boolean value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetByteSize(System.String)">
            <summary>
            Retrieves a long value, optionally suffixed with a 'b', from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <returns>The long value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetInt(System.String,System.Int32)">
            <summary>
            Retrieves an integer value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <returns>The integer value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetLong(System.String,System.Int64)">
            <summary>
            Retrieves a long value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <returns>The long value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetString(System.String,System.String)">
            <summary>
            Retrieves a string value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <returns>The string value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetFloat(System.String,System.Single)">
            <summary>
            Retrieves a float value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <returns>The float value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetDecimal(System.String,System.Decimal)">
            <summary>
            Retrieves a decimal value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <returns>The decimal value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetDouble(System.String,System.Double)">
            <summary>
            Retrieves a double value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <returns>The double value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetBooleanList(System.String)">
            <summary>
            Retrieves a list of boolean values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <returns>The list of boolean values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetDecimalList(System.String)">
            <summary>
            Retrieves a list of decimal values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <returns>The list of decimal values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetFloatList(System.String)">
            <summary>
            Retrieves a list of float values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <returns>The list of float values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetDoubleList(System.String)">
            <summary>
            Retrieves a list of double values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <returns>The list of double values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetIntList(System.String)">
            <summary>
            Retrieves a list of int values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <returns>The list of int values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetLongList(System.String)">
            <summary>
            Retrieves a list of long values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <returns>The list of long values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetByteList(System.String)">
            <summary>
            Retrieves a list of byte values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <returns>The list of byte values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetStringList(System.String)">
            <summary>
            Retrieves a list of string values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <returns>The list of string values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetConfig(System.String)">
            <summary>
            Retrieves a new configuration from the current configuration
            with the root node being the supplied path.
            </summary>
            <param name="path">The path that contains the configuration to retrieve.</param>
            <returns>A new configuration with the root node being the supplied path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetValue(System.String)">
            <summary>
            Retrieves a <see cref="T:Akka.Configuration.Hocon.HoconValue"/> from a specific path.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <returns>The <see cref="T:Akka.Configuration.Hocon.HoconValue"/> found at the location if one exists, otherwise <c>null</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetTimeSpan(System.String,System.Nullable{System.TimeSpan},System.Boolean)">
            <summary>
            Retrieves a <see cref="T:System.TimeSpan"/> value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <param name="allowInfinite"><c>true</c> if infinite timespans are allowed; otherwise <c>false</c>.</param>
            <returns>The <see cref="T:System.TimeSpan"/> value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.ToString">
            <summary>
            Converts the current configuration to a string.
            </summary>
            <returns>A string containing the current configuration.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.ToString(System.Boolean)">
            <summary>
            Converts the current configuration to a string 
            </summary>
            <param name="includeFallback">if true returns string with current config combined with fallback key-values else only current config key-values</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Configuration.Config.WithFallback(Akka.Configuration.Config)">
            <summary>
            Configure the current configuration with a secondary source.
            </summary>
            <param name="fallback">The configuration to use as a secondary source.</param>
            <returns>The current configuration configured with the specified fallback.</returns>
            <exception cref="T:System.ArgumentException">Config can not have itself as fallback.</exception>
        </member>
        <member name="M:Akka.Configuration.Config.HasPath(System.String)">
            <summary>
            Determine if a HOCON configuration element exists at the specified location
            </summary>
            <param name="path">The location to check for a configuration value.</param>
            <returns><c>true</c> if a value was found, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.op_Addition(Akka.Configuration.Config,System.String)">
            <summary>
            Adds the supplied configuration string as a fallback to the supplied configuration.
            </summary>
            <param name="config">The configuration used as the source.</param>
            <param name="fallback">The string used as the fallback configuration.</param>
            <returns>The supplied configuration configured with the supplied fallback.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.op_Addition(System.String,Akka.Configuration.Config)">
            <summary>
            Adds the supplied configuration as a fallback to the supplied configuration string.
            </summary>
            <param name="configHocon">The configuration string used as the source.</param>
            <param name="fallbackConfig">The configuration used as the fallback.</param>
            <returns>A configuration configured with the supplied fallback.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.op_Implicit(System.String)~Akka.Configuration.Config">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Akka.Configuration.Config"/>.
            </summary>
            <param name="str">The string that contains a configuration.</param>
            <returns>A configuration based on the supplied string.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.AsEnumerable">
            <summary>
            Retrieves an enumerable key value pair representation of the current configuration.
            </summary>
            <returns>The current configuration represented as an enumerable key value pair.</returns>
        </member>
        <member name="F:Akka.Configuration.Config.Empty">
            <summary>
            A static "Empty" configuration we can use instead of <c>null</c> in some key areas.
            </summary>
        </member>
        <member name="T:Akka.Configuration.ConfigExtensions">
            <summary>
            This class contains convenience methods for working with <see cref="T:Akka.Configuration.Config"/>.
            </summary>
        </member>
        <member name="M:Akka.Configuration.ConfigExtensions.SafeWithFallback(Akka.Configuration.Config,Akka.Configuration.Config)">
            <summary>
            Retrieves the current configuration or the fallback
            configuration if the current one is null.
            </summary>
            <param name="config">The configuration used as the source.</param>
            <param name="fallback">The configuration to use as a secondary source.</param>
            <returns>The current configuration or the fallback configuration if the current one is null.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigExtensions.IsNullOrEmpty(Akka.Configuration.Config)">
            <summary>
            Determines if the supplied configuration has any usable content period.
            </summary>
            <param name="config">The configuration used as the source.</param>
            <returns><c>true></c> if the <see cref="T:Akka.Configuration.Config" /> is null or <see cref="P:Akka.Configuration.Config.IsEmpty" />; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.AkkaConfigurationSection">
            <summary>
            This class represents a custom akka node within a configuration file.
            <code>
            <![CDATA[
            <?xml version="1.0" encoding="utf-8" ?>
            <configuration>
              <configSections>
                <section name="akka" type="Akka.Configuration.Hocon.AkkaConfigurationSection, Akka" />
              </configSections>
              <akka>
              ...
              </akka>
            </configuration>
            ]]>
            </code>
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.AkkaConfigurationSection.AkkaConfig">
            <summary>
            Retrieves a <see cref="T:Akka.Configuration.Config"/> from the contents of the
            custom akka node within a configuration file.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Akka.Configuration.Hocon.AkkaConfigurationSection.Hocon" -->
        <member name="T:Akka.Configuration.Hocon.CDataConfigurationElement">
            <summary>
            This class represents the base implementation for retrieving text from
            an XML CDATA node within a configuration file.
            <code>
            <![CDATA[
            <?xml version="1.0" encoding="utf-8" ?>
            <configuration>
              <configSections>
                <section name="akka" type="Akka.Configuration.Hocon.AkkaConfigurationSection, Akka" />
              </configSections>
              <akka>
                <hocon>
                  &lt;![CDATA[
                  ...
                  ]]&gt;
                </hocon>
              </akka>
            </configuration>
            ]]>
            </code>
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.CDataConfigurationElement.DeserializeElement(System.Xml.XmlReader,System.Boolean)">
            <summary>
            Deserializes the text located in a CDATA node of the configuration file.
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader" /> that reads from the configuration file.</param>
            <param name="serializeCollectionKey">true to serialize only the collection key properties; otherwise, false.</param>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconArray">
            <summary>
            This class represents an array element in a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            <code>
            akka {
              cluster {
                seed-nodes = [
                  "akka.tcp://ClusterSystem@127.0.0.1:2551",
                  "akka.tcp://ClusterSystem@127.0.0.1:2552"]
              }
            }
            </code>
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.IsString">
            <summary>
            Determines whether this element is a string.
            </summary>
            <returns><c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.GetString">
            <summary>
            Retrieves the string representation of this element.
            </summary>
            <returns>
            The string representation of this element.
            </returns>
            <exception cref="T:System.NotImplementedException">
            This element is an array. It is not a string.
            Therefore this method will throw an exception.
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.IsArray">
            <summary>
            Determines whether this element is an array.
            </summary>
            <returns><c>true</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.GetArray">
            <summary>
            Retrieves a list of elements associated with this element.
            </summary>
            <returns>
            A list of elements associated with this element.
            </returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.ToString">
            <summary>
            Returns a HOCON string representation of this element.
            </summary>
            <returns>A HOCON string representation of this element.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconConfigurationElement">
            <summary>
            This class represents a custom HOCON (Human-Optimized Config Object Notation)
            node within a configuration file.
            <code>
            <![CDATA[
            <?xml version="1.0" encoding="utf-8" ?>
            <configuration>
              <configSections>
                <section name="akka" type="Akka.Configuration.Hocon.AkkaConfigurationSection, Akka" />
              </configSections>
              <akka>
                <hocon>
                ...
                </hocon>
              </akka>
            </configuration>
            ]]>
            </code>
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconConfigurationElement.Content">
            <summary>
            Gets or sets the HOCON configuration string contained in the hocon node.
            </summary>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconLiteral">
            <summary>
            This class represents a string literal element in a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            <code>
            akka {  
              actor {
                provider = "Akka.Remote.RemoteActorRefProvider, Akka.Remote"
              }
            }
            </code>
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconLiteral.Value">
            <summary>
            Gets or sets the value of this element.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconLiteral.IsString">
            <summary>
            Determines whether this element is a string.
            </summary>
            <returns><c>true</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconLiteral.GetString">
            <summary>
            Retrieves the string representation of this element.
            </summary>
            <returns>The value of this element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconLiteral.IsArray">
            <summary>
            Determines whether this element is an array.
            </summary>
            <returns><c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconLiteral.GetArray">
            <summary>
            Retrieves a list of elements associated with this element.
            </summary>
            <returns>
            A list of elements associated with this element.
            </returns>
            <exception cref="T:System.NotImplementedException">
            This element is a string literal. It is not an array.
            Therefore this method will throw an exception.
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconLiteral.ToString">
            <summary>
            Returns the string representation of this element.
            </summary>
            <returns>The value of this element.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconObject">
            <summary>
            This class represents an object element in a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            <code>
            akka {  
              actor {
                debug {  
                  receive = on 
                  autoreceive = on
                  lifecycle = on
                  event-stream = on
                  unhandled = on
                }
              }
            }
            </code>
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconObject"/> class.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconObject.Unwrapped">
            <summary>
            Retrieves the underlying map that contains the barebones
            object values.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconObject.Items">
            <summary>
            Retrieves the underlying map that this element is based on.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.IsString">
            <summary>
            Determines whether this element is a string.
            </summary>
            <returns><c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.GetString">
            <summary>
            Retrieves the string representation of this element.
            </summary>
            <returns>The string representation of this element.</returns>
            <exception cref="T:System.NotImplementedException">
            This element is an object. It is not a string.
            Therefore this method will throw an exception.
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.IsArray">
            <summary>
            Determines whether this element is an array.
            </summary>
            <returns><c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.GetArray">
            <summary>
            Retrieves a list of elements associated with this element.
            </summary>
            <returns>A list of elements associated with this element.</returns>
            <exception cref="T:System.NotImplementedException">
            This element is an object. It is not an array.
            Therefore this method will throw an exception.
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.GetKey(System.String)">
            <summary>
            Retrieves the value associated with the supplied key.
            </summary>
            <param name="key">The key associated with the value to retrieve.</param>
            <returns>
            The value associated with the supplied key or null
            if they key does not exist.
            </returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.GetOrCreateKey(System.String)">
            <summary>
            Retrieves the value associated with the supplied key.
            If the supplied key is not found, then one is created
            with a blank value.
            </summary>
            <param name="key">The key associated with the value to retrieve.</param>
            <returns>The value associated with the supplied key.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.ToString">
            <summary>
            Returns a HOCON string representation of this element.
            </summary>
            <returns>A HOCON string representation of this element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.ToString(System.Int32)">
            <summary>
            Returns a HOCON string representation of this element.
            </summary>
            <param name="indent">The number of spaces to indent the string.</param>
            <returns>A HOCON string representation of this element.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.Parser">
            <summary>
            This class contains methods used to parse HOCON (Human-Optimized Config Object Notation)
            configuration strings.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.Parse(System.String,System.Func{System.String,Akka.Configuration.Hocon.HoconRoot})">
            <summary>
            Parses the supplied HOCON configuration string into a root element.
            </summary>
            <param name="text">The string that contains a HOCON configuration string.</param>
            <param name="includeCallback">Callback used to resolve includes</param>
            <returns>The root element created from the supplied HOCON configuration string.</returns>
            <exception cref="T:System.Exception">
            This exception is thrown when an unresolved substitution is encountered.
            It also occurs when the end of the file has been reached while trying
            to read a value.
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.ParseValue(Akka.Configuration.Hocon.HoconValue,System.String)">
            <summary>
            Retrieves the next value token from the tokenizer and appends it
            to the supplied element <paramref name="owner"/>.
            </summary>
            <param name="owner">The element to append the next token.</param>
            <exception cref="T:System.Exception">End of file reached while trying to read a value</exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.ParseArray(System.String)">
            <summary>
            Retrieves the next array token from the tokenizer.
            </summary>
            <returns>An array of elements retrieved from the token.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconRoot">
            <summary>
            This class represents the root element in a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconRoot.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconRoot"/> class.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconRoot.#ctor(Akka.Configuration.Hocon.HoconValue,System.Collections.Generic.IEnumerable{Akka.Configuration.Hocon.HoconSubstitution})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconRoot"/> class.
            </summary>
            <param name="value">The value to associate with this element.</param>
            <param name="substitutions">An enumeration of substitutions to associate with this element.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconRoot.#ctor(Akka.Configuration.Hocon.HoconValue)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconRoot"/> class.
            </summary>
            <param name="value">The value to associate with this element.</param>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconRoot.Value">
            <summary>
            Retrieves the value associated with this element.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconRoot.Substitutions">
            <summary>
            Retrieves an enumeration of substitutions associated with this element.
            </summary>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconSubstitution">
            <summary>
            This class represents a substitution element in a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            <code>
            akka {  
              defaultInstances = 10
              deployment{
                /user/time{
                  nr-of-instances = $defaultInstances
                }
              }
            }
            </code>
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconSubstitution"/> class.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconSubstitution" /> class.
            </summary>
            <param name="path">The path.</param>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconSubstitution.Path">
            <summary>
                The full path to the value which should substitute this instance.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconSubstitution.ResolvedValue">
            <summary>
                The evaluated value from the Path property
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.IsString">
            <summary>
            Determines whether this element is a string.
            </summary>
            <returns><c>true</c> if this element is a string; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.GetString">
            <summary>
            Retrieves the string representation of this element.
            </summary>
            <returns>The string representation of this element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.IsArray">
            <summary>
            Determines whether this element is an array.
            </summary>
            <returns><c>true</c> if this element is aan array; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.GetArray">
            <summary>
            Retrieves a list of elements associated with this element.
            </summary>
            <returns>A list of elements associated with this element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.IsObject">
            <summary>
            Determines whether this element is a HOCON object.
            </summary>
            <returns><c>true</c> if this element is a HOCON object; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.GetObject">
            <summary>
            Retrieves the HOCON object representation of this element.
            </summary>
            <returns>The HOCON object representation of this element.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.TokenType">
            <summary>
            This enumeration defines the different types of tokens found within
            a HOCON (Human-Optimized Config Object Notation) configuration string.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Comment">
            <summary>
            This token type represents a comment.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Key">
            <summary>
            This token type represents the key portion of a key-value pair.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.LiteralValue">
            <summary>
            This token type represents the value portion of a key-value pair.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Assign">
            <summary>
            This token type represents the assignment operator, <c>=</c> or <c>:</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.ObjectStart">
            <summary>
            This token type represents the beginning of an object, <c>{</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.ObjectEnd">
            <summary>
            This token type represents the end of an object, <c>}</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Dot">
            <summary>
            This token type represents a namespace separator, <c>.</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.EoF">
            <summary>
            This token type represents the end of the configuration string.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.ArrayStart">
            <summary>
            This token type represents the beginning of an array, <c>[</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.ArrayEnd">
            <summary>
            This token type represents the end of an array, <c>]</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Comma">
            <summary>
            This token type represents the separator in an array, <c>,</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Substitute">
            <summary>
            This token type represents a replacement variable, <c>$foo</c> .
            </summary>
        </member>
        <member name="T:Akka.Configuration.Hocon.Token">
            <summary>
            This class represents a token within a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.Token"/> class.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.#ctor(Akka.Configuration.Hocon.TokenType)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.Token"/> class.
            </summary>
            <param name="type">The type of token to associate with.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.Token"/> class.
            </summary>
            <param name="value">The string literal value to associate with this token.</param>
        </member>
        <member name="P:Akka.Configuration.Hocon.Token.Value">
            <summary>
            The value associated with this token. If this token is
            a <see cref="F:Akka.Configuration.Hocon.TokenType.LiteralValue"/>, then this property
            holds the string literal.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.Token.Type">
            <summary>
            The type that represents this token.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.Key(System.String)">
            <summary>
            Creates a key token with a given <paramref name="key"/>.
            </summary>
            <param name="key">The key to associate with this token.</param>
            <returns>A key token with the given key.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.Substitution(System.String)">
            <summary>
            Creates a substitution token with a given <paramref name="path"/>.
            </summary>
            <param name="path">The path to associate with this token.</param>
            <returns>A substitution token with the given path.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.LiteralValue(System.String)">
            <summary>
            Creates a string literal token with a given <paramref name="value"/>.
            </summary>
            <param name="value">The value to associate with this token.</param>
            <returns>A string literal token with the given value.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.Tokenizer">
            <summary>
            This class contains methods used to tokenize a string.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.Tokenizer"/> class.
            </summary>
            <param name="text">The string that contains the text to tokenize.</param>
        </member>
        <member name="P:Akka.Configuration.Hocon.Tokenizer.EoF">
            <summary>
            A value indicating whether the tokenizer has reached the end of the string.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Matches(System.String)">
            <summary>
            Determines whether the given pattern matches the value at the current
            position of the tokenizer.
            </summary>
            <param name="pattern">The string that contains the characters to match.</param>
            <returns><c>true</c> if the pattern matches, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Take(System.Int32)">
            <summary>
            Retrieves a string of the given length from the current position of the tokenizer.
            </summary>
            <param name="length">The length of the string to return.</param>
            <returns>
            The string of the given length. If the length exceeds where the
            current index is located, then null is returned.
            </returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Matches(System.String[])">
            <summary>
            Determines whether any of the given patterns match the value at the current
            position of the tokenizer.
            </summary>
            <param name="patterns">The string array that contains the characters to match.</param>
            <returns><c>true</c> if any one of the patterns match, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Peek">
            <summary>
            Retrieves the next character in the tokenizer without advancing its position.
            </summary>
            <returns>The character at the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Take">
            <summary>
            Retrieves the next character in the tokenizer.
            </summary>
            <returns>The character at the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.PullWhitespace">
            <summary>
            Advances the tokenizer to the next non-whitespace character.
            </summary>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconTokenizer">
            <summary>
            This class contains methods used to tokenize HOCON (Human-Optimized Config Object Notation)
            configuration strings.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconTokenizer"/> class.
            </summary>
            <param name="text">The string that contains the text to tokenize.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullWhitespaceAndComments">
            <summary>
            Advances the tokenizer to the next non-whitespace, non-comment token.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullRestOfLine">
            <summary>
            Retrieves the current line from where the current token
            is located in the string.
            </summary>
            <returns>The current line from where the current token is located.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullNext">
            <summary>
            Retrieves the next token from the string.
            </summary>
            <returns>The next token contained in the string.</returns>
            <exception cref="T:System.FormatException">
            This exception is thrown when an unknown token is encountered.
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullArrayEnd">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.ArrayEnd"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.ArrayEnd"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsArrayEnd">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.ArrayEnd"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsArrayStart">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.ArrayStart"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullArrayStart">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.ArrayStart"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.ArrayStart"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullDot">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.Dot"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Dot"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullComma">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.Comma"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Comma"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullStartOfObject">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.ObjectStart"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.ObjectStart"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullEndOfObject">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.ObjectEnd"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.ObjectEnd"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullAssignment">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.Assign"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Assign"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsComma">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.Comma"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsDot">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.Dot"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsObjectStart">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.ObjectStart"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsEndOfObject">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.ObjectEnd"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsAssignment">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.Assign"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsStartOfQuotedText">
            <summary>
            Determines whether the current token matches the start of a quoted string.
            </summary>
            <returns><c>true</c> if token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsStartOfTripleQuotedText">
            <summary>
            Determines whether the current token matches the start of a triple quoted string.
            </summary>
            <returns><c>true</c> if token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullComment">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.Comment"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Comment"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullUnquotedKey">
            <summary>
            Retrieves an unquoted <see cref="F:Akka.Configuration.Hocon.TokenType.Key"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Key"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsUnquotedKey">
            <summary>
            Determines whether the current token is an unquoted key.
            </summary>
            <returns><c>true</c> if token is an unquoted key; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsUnquotedKeyStart">
            <summary>
            Determines whether the current token is the start of an unquoted key.
            </summary>
            <returns><c>true</c> if token is the start of an unquoted key; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullTripleQuotedText">
            <summary>
            Retrieves a triple quoted <see cref="F:Akka.Configuration.Hocon.TokenType.LiteralValue"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.LiteralValue"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullQuotedText">
            <summary>
            Retrieves a quoted <see cref="F:Akka.Configuration.Hocon.TokenType.LiteralValue"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.LiteralValue"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullQuotedKey">
            <summary>
            Retrieves a quoted <see cref="F:Akka.Configuration.Hocon.TokenType.Key"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Key"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullValue">
            <summary>
            Retrieves a value token from the tokenizer's current position.
            </summary>
            <returns>A value token from the tokenizer's current position.</returns>
            <exception cref="T:System.FormatException">
            Expected value: Null literal, Array, Quoted Text, Unquoted Text,
                Triple quoted Text, Object or End of array
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsSubstitutionStart">
            <summary>
            Determines whether the current token is the start of a substitution.
            </summary>
            <returns><c>true</c> if token is the start of a substitution; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullSubstitution">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.Substitute"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Substitute"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsSpaceOrTab">
            <summary>
            Determines whether the current token is a space or a tab.
            </summary>
            <returns><c>true</c> if token is the start of a space or a tab; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsStartSimpleValue">
            <summary>
            Determines whether the current token is the start of an unquoted string literal.
            </summary>
            <returns><c>true</c> if token is the start of an unquoted string literal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullSpaceOrTab">
            <summary>
            Retrieves the current token, including whitespace and tabs, as a string literal token.
            </summary>
            <returns>A token that contains the string literal value.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullSimpleValue">
            <summary>
            Retrieves the current token as a string literal token.
            </summary>
            <returns>A token that contains the string literal value.</returns>
            <exception cref="T:System.FormatException">
            This exception is thrown when the tokenizer cannot find
            a string literal value from the current token.
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsValue">
            <summary>
            Determines whether the current token is a value.
            </summary>
            <returns><c>true</c> if the current token is a value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconValue">
            <summary>
            This class represents the root type for a HOCON (Human-Optimized Config Object Notation)
            configuration object.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconValue"/> class.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconValue.IsEmpty">
            <summary>
            Returns true if this HOCON value doesn't contain any elements
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconValue.Values">
            <summary>
            The list of elements inside this HOCON value
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.AtKey(System.String)">
            <summary>
            Wraps this <see cref="T:Akka.Configuration.Hocon.HoconValue"/> into a new <see cref="T:Akka.Configuration.Config"/> object at the specified key.
            </summary>
            <param name="key">The key designated to be the new root element.</param>
            <returns>A <see cref="T:Akka.Configuration.Config"/> with the given key as the root element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetObject">
            <summary>
            Retrieves the <see cref="T:Akka.Configuration.Hocon.HoconObject"/> from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The <see cref="T:Akka.Configuration.Hocon.HoconObject"/> that represents this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.IsObject">
            <summary>
            Determines if this <see cref="T:Akka.Configuration.Hocon.HoconValue"/> is a <see cref="T:Akka.Configuration.Hocon.HoconObject"/>.
            </summary>
            <returns><c>true</c> if this value is a <see cref="T:Akka.Configuration.Hocon.HoconObject"/>, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.AppendValue(Akka.Configuration.Hocon.IHoconElement)">
            <summary>
            Adds the given element to the list of elements inside this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <param name="value">The element to add to the list.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.Clear">
            <summary>
            Clears the list of elements inside this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.NewValue(Akka.Configuration.Hocon.IHoconElement)">
            <summary>
            Creates a fresh list of elements inside this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>
            and adds the given value to the list.
            </summary>
            <param name="value">The element to add to the list.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.IsString">
            <summary>
            Determines whether all the elements inside this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>
            are a string.
            </summary>
            <returns>
              <c>true</c>if all elements inside this <see cref="T:Akka.Configuration.Hocon.HoconValue"/> are a string; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetChildObject(System.String)">
            <summary>
            Retrieves the child object located at the given key.
            </summary>
            <param name="key">The key used to retrieve the child object.</param>
            <returns>The element at the given key.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetBoolean">
            <summary>
            Retrieves the boolean value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The boolean value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
            <exception cref="T:System.NotSupportedException">
            This exception occurs when the <see cref="T:Akka.Configuration.Hocon.HoconValue"/> doesn't
            conform to the standard boolean values: "on", "off", "true", or "false"
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetString">
            <summary>
            Retrieves the string value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The string value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetDecimal">
            <summary>
            Retrieves the decimal value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The decimal value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetFloat">
            <summary>
            Retrieves the float value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The float value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetDouble">
            <summary>
            Retrieves the double value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The double value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetLong">
            <summary>
            Retrieves the long value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The long value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetInt">
            <summary>
            Retrieves the integer value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The integer value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetByte">
            <summary>
            Retrieves the byte value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The byte value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetByteList">
            <summary>
            Retrieves a list of byte values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of byte values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetIntList">
            <summary>
            Retrieves a list of integer values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of integer values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetLongList">
            <summary>
            Retrieves a list of long values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of long values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetBooleanList">
            <summary>
            Retrieves a list of boolean values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of boolean values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetFloatList">
            <summary>
            Retrieves a list of float values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of float values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetDoubleList">
            <summary>
            Retrieves a list of double values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of double values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetDecimalList">
            <summary>
            Retrieves a list of decimal values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of decimal values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetStringList">
            <summary>
            Retrieves a list of string values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of string values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetArray">
            <summary>
            Retrieves a list of values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.IsArray">
            <summary>
            Determines whether this <see cref="T:Akka.Configuration.Hocon.HoconValue"/> is an array.
            </summary>
            <returns>
              <c>true</c> if this <see cref="T:Akka.Configuration.Hocon.HoconValue"/> is an array; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetTimeSpan(System.Boolean)">
            <summary>
            Retrieves the time span value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <param name="allowInfinite">A flag used to set inifinite durations.</param>
            <returns>The time span value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetByteSize">
            <summary>
            Retrieves the long value, optionally suffixed with a 'b', from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The long value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.ToString">
            <summary>
            Returns a HOCON string representation of this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A HOCON string representation of this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.ToString(System.Int32)">
            <summary>
            Returns a HOCON string representation of this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <param name="indent">The number of spaces to indent the string.</param>
            <returns>A HOCON string representation of this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.IMightBeAHoconObject">
            <summary>
            Marker interface to make it easier to retrieve HOCON
            (Human-Optimized Config Object Notation) objects for
            substitutions.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.IMightBeAHoconObject.IsObject">
            <summary>
            Determines whether this element is a HOCON object.
            </summary>
            <returns><c>true</c> if this element is a HOCON object; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.IMightBeAHoconObject.GetObject">
            <summary>
            Retrieves the HOCON object representation of this element.
            </summary>
            <returns>The HOCON object representation of this element.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.IHoconElement">
            <summary>
            This interface defines the contract needed to implement
            a HOCON (Human-Optimized Config Object Notation) element.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.IHoconElement.IsString">
            <summary>
            Determines whether this element is a string.
            </summary>
            <returns><c>true</c> if this element is a string; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.IHoconElement.GetString">
            <summary>
            Retrieves the string representation of this element.
            </summary>
            <returns>The string representation of this element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.IHoconElement.IsArray">
            <summary>
            Determines whether this element is an array.
            </summary>
            <returns><c>true</c> if this element is aan array; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.IHoconElement.GetArray">
            <summary>
            Retrieves a list of elements associated with this element.
            </summary>
            <returns>A list of elements associated with this element.</returns>
        </member>
        <member name="T:Akka.Dispatch.IDispatcherPrerequisites">
            <summary>
            Contextual information that's useful for dispatchers
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IDispatcherPrerequisites.EventStream">
            <summary>
            The <see cref="P:Akka.Dispatch.IDispatcherPrerequisites.EventStream"/> that belongs to the current <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IDispatcherPrerequisites.Scheduler">
            <summary>
            The <see cref="T:Akka.Actor.IScheduler"/> that belongs to the current <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IDispatcherPrerequisites.Settings">
            <summary>
            The <see cref="P:Akka.Dispatch.IDispatcherPrerequisites.Settings"/> for the current <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IDispatcherPrerequisites.Mailboxes">
            <summary>
            The list of registered <see cref="P:Akka.Dispatch.IDispatcherPrerequisites.Mailboxes"/> for the current <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.DefaultDispatcherPrerequisites">
            <summary>
            The default set of contextual data needed for <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/>s
            </summary>
        </member>
        <member name="M:Akka.Dispatch.DefaultDispatcherPrerequisites.#ctor(Akka.Event.EventStream,Akka.Actor.IScheduler,Akka.Actor.Settings,Akka.Dispatch.Mailboxes)">
            <summary>
            Default constructor...
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageDispatcherConfigurator">
            <summary>
            Base class used for hooking new <see cref="T:Akka.Dispatch.MessageDispatcher"/> types into <see cref="T:Akka.Dispatch.Dispatchers"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcherConfigurator.#ctor(Akka.Configuration.Config,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            Takes a <see cref="P:Akka.Dispatch.MessageDispatcherConfigurator.Config"/> object, usually passed in via <see cref="P:Akka.Actor.Settings.Config"/>
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcherConfigurator.Config">
            <summary>
            System-wide configuration
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcherConfigurator.Prerequisites">
            <summary>
            The system prerequisites needed for this dispatcher to do its job
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcherConfigurator.Dispatcher">
            <summary>
            Returns a <see cref="M:Akka.Dispatch.MessageDispatcherConfigurator.Dispatcher"/> instance.
            
            Whether or not this <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> returns a new instance 
            or returns a reference to an existing instance is an implementation detail of the
            underlying implementation.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akka.Dispatch.ThreadPoolDispatcherConfigurator">
            <summary>
            Used to create instances of the <see cref="T:Akka.Dispatch.ThreadPoolDispatcher"/>.
            
            <remarks>
            Always returns the same instance, since the <see cref="T:System.Threading.ThreadPool"/> is global.
            This is also the default dispatcher for all actors.
            </remarks>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.TaskDispatcherConfigurator">
            <summary>
            Used to create instances of the <see cref="T:Akka.Dispatch.TaskDispatcher"/>.
            
            <remarks>
            Always returns the same instance.
            </remarks>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.CurrentSynchronizationContextDispatcherConfigurator">
            <summary>
            Used to create instances of the <see cref="T:Akka.Dispatch.CurrentSynchronizationContextDispatcher"/>.
            
            <remarks>
            Always returns the a new instance.
            </remarks>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageDispatcher">
            <summary>
            Class responsible for pushing messages from an actor's mailbox into its
            receive methods. Comes in many different flavors.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.MessageDispatcher.DefaultThroughput">
            <summary>
                The default throughput
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.Configurator">
            <summary>
            The configurator used to configure this message dispatcher.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.#ctor(Akka.Dispatch.MessageDispatcherConfigurator)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.MessageDispatcher" /> class.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.Id">
            <summary>
            The ID for this dispatcher.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.ThroughputDeadlineTime">
            <summary>
                Gets or sets the throughput deadline time.
            </summary>
            <value>The throughput deadline time.</value>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.Throughput">
            <summary>
                Gets or sets the throughput.
            </summary>
            <value>The throughput.</value>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Schedule(System.Action)">
            <summary>
                Schedules the specified run.
            </summary>
            <param name="run">The run.</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Dispatch(Akka.Actor.ActorCell,Akka.Actor.Envelope)">
            <summary>
            Dispatches a user-defined message from a mailbox to an <see cref="T:Akka.Actor.ActorCell"/>        
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.SystemDispatch(Akka.Actor.ActorCell,Akka.Actor.Envelope)">
            <summary>
            Dispatches a <see cref="T:Akka.Dispatch.SysMsg.ISystemMessage"/> from a mailbox to an <see cref="T:Akka.Actor.ActorCell"/>        
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Attach(Akka.Actor.ActorCell)">
            <summary>
            Attaches the dispatcher to the <see cref="T:Akka.Actor.ActorCell"/>
            
            <remarks>
            Practically, doesn't do very much right now - dispatchers aren't responsible for creating
            mailboxes in Akka.NET
            </remarks>
            </summary>
            <param name="cell">The ActorCell belonging to the actor who's attaching to this dispatcher.</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Detach(Akka.Actor.ActorCell)">
            <summary>
            Detaches the dispatcher to the <see cref="T:Akka.Actor.ActorCell"/>
            
            <remarks>
            Only really used in dispatchers with 1:1 relationship with dispatcher.
            </remarks>
            </summary>
            <param name="cell">The ActorCell belonging to the actor who's detaching from this dispatcher.</param>
        </member>
        <member name="T:Akka.Dispatch.BoundedDequeBasedMailbox">
            <summary>
            Mailbox with support for EnqueueFirst
            </summary>
        </member>
        <member name="T:Akka.Dispatch.CachingConfig">
            <summary>
            INTERNAL API
            
            A <see cref="T:Akka.Dispatch.CachingConfig"/> is a <see cref="T:Akka.Configuration.Config"/> that wraps another <see cref="T:Akka.Configuration.Config"/> and is used to
            cache path lookup and string retrieval, which we happen to do in some critical paths of the actor creation
            and mailbox selection code.
            
            All other <see cref="T:Akka.Configuration.Config"/> operations are delegated to the wrapped <see cref="T:Akka.Configuration.Config"/>.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ConcurrentQueueMailbox">
            <summary>
            Class ConcurrentQueueMailbox.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ConcurrentQueueMailbox.Schedule">
            <summary>
            Schedules this instance.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ConcurrentQueueMailbox.Post(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <summary>
            Posts the specified envelope.
            </summary>
            <param name="receiver"></param>
            <param name="envelope"> The envelope. </param>
        </member>
        <member name="M:Akka.Dispatch.ConcurrentQueueMailbox.BecomeClosed">
            <summary>
            Stops this instance.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ConcurrentQueueMailbox.Dispose(System.Boolean)">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IDequeBasedMailbox">
            <summary>
            Used for <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/> instances that support double-ended queues.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.IDequeBasedMailbox.EnqueueFirst(Akka.Actor.Envelope)">
            <summary>
            Enqueues an <see cref="T:Akka.Actor.Envelope"/> to the front of
            the <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>. Typically called during
            a <see cref="M:Akka.Actor.IStash.Unstash"/> or <see cref="M:Akka.Actor.IStash.UnstashAll"/>operation.
            </summary>
            <param name="envelope">The message that will be prepended to the queue.</param>
        </member>
        <member name="M:Akka.Dispatch.IDequeBasedMailbox.Post(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <summary>
            Posts a message to the back of the <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
            </summary>
            <param name="receiver">The intended recipient of the message.</param>
            <param name="envelope">The message that will be appended to the queue.</param>
        </member>
        <member name="T:Akka.Dispatch.ForkJoinDispatcherConfigurator">
            <summary>
            <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> for the <see cref="T:Akka.Dispatch.ForkJoinDispatcher"/>.
            
            Creates a single <see cref="T:Akka.Dispatch.ForkJoinDispatcher"/> instance and returns the same instance
            each time <see cref="M:Akka.Dispatch.ForkJoinDispatcherConfigurator.Dispatcher"/> is called.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ForkJoinDispatcher">
            <summary>
            ForkJoinDispatcher - custom multi-threaded dispatcher that runs on top of a 
            <see cref="T:Helios.Concurrency.DedicatedThreadPool"/>, designed to be used for mission-critical actors
            that can't afford <see cref="T:System.Threading.ThreadPool"/> starvation.
            
            Relevant configuration options:
            <code>
                my-forkjoin-dispatcher{
                        type = ForkJoinDispatcher
                        throughput = 100
                        dedicated-thread-pool{ #settings for Helios.DedicatedThreadPool
            	            thread-count = 3 #number of threads
            	            #deadlock-timeout = 3s #optional timeout for deadlock detection
            	            threadtype = background #values can be "background" or "foreground"
                        }
                }
            </code>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.Mailbox`2">
            <summary>
            Class Mailbox of TSys,TUser.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox`2.Schedule">
            <summary>
            Schedules this instance.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox`2.Post(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <summary>
            Posts the specified envelope.
            </summary>
            <param name="receiver"></param>
            <param name="envelope"> The envelope. </param>
        </member>
        <member name="M:Akka.Dispatch.Mailbox`2.BecomeClosed">
            <summary>
            Stops this instance.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox`2.Dispose(System.Boolean)">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.DispatcherExtensions.ScheduleAsync``1(Akka.Dispatch.MessageDispatcher,System.Func{``0})">
            <summary>
            Schedules the specified run and returns a continuation task.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ThreadPoolDispatcher">
            <summary>
                Class ThreadPoolDispatcher.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ThreadPoolDispatcher.#ctor(Akka.Dispatch.MessageDispatcherConfigurator)">
            <summary>
            Takes a <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ThreadPoolDispatcher.Schedule(System.Action)">
            <summary>
                Schedules the specified run.
            </summary>
            <param name="run">The run.</param>
        </member>
        <member name="T:Akka.Dispatch.CurrentSynchronizationContextDispatcher">
            <summary>
                Dispatcher that dispatches messages on the current synchronization context, e.g. WinForms or WPF GUI thread
            </summary>
        </member>
        <member name="F:Akka.Dispatch.CurrentSynchronizationContextDispatcher._scheduler">
            <summary>
                The scheduler
            </summary>
        </member>
        <member name="M:Akka.Dispatch.CurrentSynchronizationContextDispatcher.#ctor(Akka.Dispatch.MessageDispatcherConfigurator)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.CurrentSynchronizationContextDispatcher" /> class.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.CurrentSynchronizationContextDispatcher.Schedule(System.Action)">
            <summary>
                Schedules the specified run.
            </summary>
            <param name="run">The run.</param>
        </member>
        <member name="T:Akka.Dispatch.Dispatchers">
            <summary>
            The registry of all <see cref="T:Akka.Dispatch.MessageDispatcher"/> instances available to this <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId">
            <summary>
                The default dispatcher identifier, also the full key of the configuration of the default dispatcher.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Dispatchers._dispatcherConfigurators">
            <summary>
            The list of all configurators used to create <see cref="T:Akka.Dispatch.MessageDispatcher"/> instances.
            
            Has to be thread-safe, as this collection can be accessed concurrently by many actors.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.#ctor(Akka.Actor.ActorSystem,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>Initializes a new instance of the <see cref="T:Akka.Dispatch.Dispatchers" /> class.</summary>
            <param name="system">The system.</param>
            <param name="prerequisites">The prerequisites required for some <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> instances.</param>
        </member>
        <member name="P:Akka.Dispatch.Dispatchers.DefaultGlobalDispatcher">
            <summary>Gets the one and only default dispatcher.</summary>
        </member>
        <member name="P:Akka.Dispatch.Dispatchers.DefaultDispatcherConfig">
            <summary>
            The <see cref="T:Akka.Configuration.Config"/> for the default dispatcher.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.ReloadPrerequisites(Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            INTERNAL API
            
            Used when a plugin like Akka.Persistence needs to be able to load dispatcher configurations to the chain.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.Dispatchers.Prerequisites">
            <summary>
            The prerequisites required for some <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> instances.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.Lookup(System.String)">
            <summary>
            Returns a dispatcher as specified in configuration. Please note that this method _MAY_
            create and return a new dispatcher on _EVERY_ call.
            </summary>
            <exception cref="T:Akka.Configuration.ConfigurationException">If the specified dispatcher cannot be found in configuration.</exception>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.HasDispatcher(System.String)">
            <summary>
            Checks that configuration provides a section for the given dispatcher.
            This does not guarantee that no <see cref="T:Akka.Configuration.ConfigurationException"/> will be thrown
            when using the dispatcher, because the details can only be checked by trying to
            instantiate it, which might be undesirable when just checking.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.From(Akka.Configuration.Config)">
            <summary>
            INTERNAL API
            
            Creates a dispatcher from a <see cref="T:Akka.Configuration.Config"/>. Internal test purpose only.
            <code>
            From(Config.GetConfig(id));
            </code>
            
            The Config must also contain an `id` property, which is the identifier of the dispatcher.
            </summary>
            <param name="cfg">The provided configuration section.</param>
            <returns>An instance of the <see cref="T:Akka.Dispatch.MessageDispatcher"/>, if valid.</returns>
            <exception cref="T:Akka.Configuration.ConfigurationException">if the `id` property is missing from <paramref name="cfg"/></exception>
            <exception cref="T:System.NotSupportedException">thrown if the dispatcher path or type cannot be resolved.</exception>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.RegisterConfigurator(System.String,Akka.Dispatch.MessageDispatcherConfigurator)">
            <summary>
            Register a <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> that will be used by <see cref="M:Akka.Dispatch.Dispatchers.Lookup(System.String)"/>
            and <see cref="M:Akka.Dispatch.Dispatchers.HasDispatcher(System.String)"/> instead of looking up the configurator from the system
            configuration.
            
            This enables dynamic addition of dispatchers.
            
            <remarks>
            A <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> for a certain id can only be registered once,
            i.e. it can not be replaced. It is safe to call this method multiple times, but only the
            first registration will be used.
            </remarks>
            </summary>
            <returns>This method returns <c>true</c> if the specified configurator was successfully registered.</returns>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.Config(System.String)">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Dispatch.DispatcherConfigurator">
            <summary>
            The cached <see cref="T:Akka.Dispatch.MessageDispatcher"/> factory that gets looked up via configuration
            inside <see cref="T:Akka.Dispatch.Dispatchers"/>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.BlockingMessageQueue">
            <summary> 
            Base class for blocking message queues. Allows non thread safe data structures to be used as message queues. 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.BoundedMessageQueue">
            <summary>An Bounded mailbox message queue.</summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue">
            <summary>
            Message queue for supporting <see cref="T:Akka.Dispatch.IDequeBasedMessageQueueSemantics"/> within <see cref="T:Akka.Dispatch.Mailbox"/> instances.
            
            Uses a <see cref="T:System.Collections.Generic.Stack`1"/> internally - each individual <see cref="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.EnqueueFirst(Akka.Actor.Envelope)"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.#ctor(Akka.Dispatch.MessageQueues.IMessageQueue)">
            <summary>
            Takes another <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/> as an argument - wraps <paramref name="messageQueue"/>
            in order to provide it with prepend (<see cref="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.EnqueueFirst(Akka.Actor.Envelope)"/>) semantics.
            </summary>
            <param name="messageQueue"></param>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.HasMessages">
            <summary>
            Returns true if there are any messages inside the queue.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.Count">
            <summary>
            Returns the number of messages in both the internal message queue
            and the prepend buffer.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.Enqueue(Akka.Actor.Envelope)">
            <summary>
            Enqueue a message to the back of the <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
            </summary>
            <param name="envelope"></param>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.TryDequeue(Akka.Actor.Envelope@)">
            <summary>
            Attempt to dequeue a message from the front of the prepend buffer.
            
            If the prepend buffer is empty, dequeue a message from the normal
            <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/> wrapped but this wrapper.
            </summary>
            <param name="envelope">The message to return, if any</param>
            <returns><c>true</c> if a message was available, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.EnqueueFirst(Akka.Actor.Envelope)">
            <summary>
            Add a message to the front of the queue via the prepend buffer.
            </summary>
            <param name="envelope">The message we wish to append to the front of the queue.</param>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.UnboundedPriorityMessageQueue">
            <summary> 
            Base class message queue that uses a priority generator for messages 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.UnboundedMessageQueue">
            <summary> An unbounded mailbox message queue. </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.IMessageQueue">
            <summary> 
            Interface to be implemented by all mailbox message queues 
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.IMessageQueue.HasMessages">
            <summary> 
            Tests if the message queue contains any messages 
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.IMessageQueue.Count">
            <summary> 
            Returns the count of messages currently in the message queue 
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.IMessageQueue.Enqueue(Akka.Actor.Envelope)">
            <summary> 
            Enqueues an mailbox envelope onto the message queue 
            </summary>
            <param name="envelope"> The envelope to enqueue </param>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.IMessageQueue.TryDequeue(Akka.Actor.Envelope@)">
            <summary> 
            Tries to pull an envelope of the message queue 
            </summary>
            <param name="envelope"> The envelope that was dequeued </param>
            <returns> </returns>
        </member>
        <member name="T:Akka.Dispatch.ISemantics">
            <summary>
            
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IMultipleConsumerSemantics">
            <summary> 
            Semantics for message queues that support multiple consumers 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IUnboundedMessageQueueSemantics">
            <summary> 
            Semantics for message queues that have an unbounded size 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IBoundedMessageQueueSemantics">
            <summary> 
            Semantics for message queues that have a bounded size 
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IBoundedMessageQueueSemantics.PushTimeOut">
            <summary> 
            The enqueue time to wait until message is dropped to deadletters if the message queue is full 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IBlockingMessageQueueSemantics">
            <summary> 
            Semantics for message queues that are blocking 
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IBlockingMessageQueueSemantics.BlockTimeOut">
            <summary> 
            The time to wait on a lock before throwing an timeout exception. 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IDequeBasedMessageQueueSemantics">
            <summary>
            Semantics for message queues that are Double-Ended.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics">
            <summary>
            Semantics for message queues that are Double-Ended and unbounded
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IBoundedDequeBasedMessageQueueSemantics">
            <summary>
            Semantics for message queues that are Double-Ended and bounded
            </summary>
        </member>
        <member name="T:Akka.Dispatch.FutureActor">
            <summary>
                Class FutureActor.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.FutureActor.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.FutureActor" /> class.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.FutureActor.#ctor(System.Threading.Tasks.TaskCompletionSource{System.Object},Akka.Actor.IActorRef)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.FutureActor" /> class.
            </summary>
            <param name="completionSource">The completion source.</param>
            <param name="respondTo">The respond to.</param>
        </member>
        <member name="M:Akka.Dispatch.FutureActor.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Dispatch.Mailbox">
            <summary>
            Mailbox base class
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.DebugPrint(System.String,System.Object[])">
            <summary>
            Prints a message tosStandard out if the Compile symbol "MAILBOXDEBUG" has been set.
            If the symbol is not set all invocations to this method will be removed by the compiler.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.SetActor(Akka.Actor.ActorCell)">
            <summary>
                Attaches an ActorCell to the Mailbox.
            </summary>
            <param name="actorCell"></param>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.Dispose">
            <summary>
                Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.Post(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <summary>
                Posts the specified envelope to the mailbox.
            </summary>
            <param name="receiver"></param>
            <param name="envelope">The envelope.</param>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.BecomeClosed">
            <summary>
                Stops this instance.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.Setup(Akka.Dispatch.MessageDispatcher)">
            <summary>
                Attaches a MessageDispatcher to the Mailbox.
            </summary>
            <param name="dispatcher">The dispatcher.</param>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.hasUnscheduledMessages">
            <summary>
                The has unscheduled messages
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.status">
            <summary>
                The mailbox status (busy or idle)
            </summary>
        </member>
        <member name="T:Akka.Dispatch.Mailbox.MailboxStatus">
            <summary>
                Class MailboxStatus.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.MailboxStatus.Idle">
            <summary>
                The idle
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.MailboxStatus.Busy">
            <summary>
                The busy
            </summary>
        </member>
        <member name="T:Akka.Dispatch.Mailboxes">
            <summary>
                Class Mailboxes.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailboxes._system">
            <summary>
                The system
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.#ctor(Akka.Actor.ActorSystem)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.Mailboxes" /> class.
            </summary>
            <param name="system">The system.</param>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.FromConfig(System.String)">
            <summary>
            Creates a mailbox from a configuration path.
            </summary>
            <param name="path">The path.</param>
            <returns>Mailbox.</returns>
        </member>
        <member name="T:Akka.Dispatch.PinnedDispatcherConfigurator">
            <summary>
            Used to create instances of the <see cref="T:Akka.Dispatch.SingleThreadDispatcher"/>. 
            
            Each actor created using the pinned dispatcher gets its own unique thread.
            <remarks>
            Always returns a new instance.
            </remarks>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SingleThreadDispatcher">
            <summary>
            Used to power the <see cref="T:Akka.Dispatch.PinnedDispatcherConfigurator"/>.
            
            Guaranteed to provide one new thread instance per actor.
            
            Uses <see cref="T:Helios.Concurrency.DedicatedThreadPool"/> with 1 thread in order 
            to take advantage of standard cleanup / teardown / queueing mechanics.
            
            /// Relevant configuration options:
            <code>
                my-forkjoin-dispatcher{
                        type = PinnedDispatcher
                        throughput = 100
                        dedicated-thread-pool{ #settings for Helios.DedicatedThreadPool
            	            #deadlock-timeout = 3s #optional timeout for deadlock detection
            	            threadtype = background #values can be "background" or "foreground"
                            apartment = mta # values can be "mta" or "sta" or empty
                        }
                }
            
                my-other-forkjoin-dispatcher{
                        type = PinnedDispatcher
                        # dedicated-thread-pool section is optional
                }
            </code>
            <remarks>
            Worth noting that unlike the <see cref="T:Akka.Dispatch.ForkJoinDispatcher"/>, the <see cref="T:Akka.Dispatch.SingleThreadDispatcher"/>
            does not respect the <c>dedicated-thread-pool.thread-count</c> property in configuration. That value is
            always equal to 1 in the <see cref="T:Akka.Dispatch.SingleThreadDispatcher"/>.
            </remarks>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SingleThreadDispatcher.Schedule(System.Action)">
            <summary>
                Schedules the specified run.
            </summary>
            <param name="run">The run.</param>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.ISystemMessage">
            <summary>
                Class ISystemMessage.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.NoMessage">
            <summary>
                Class NoMessage.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.DeathWatchNotification">
            <summary>
                Class DeathWatchNotification.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.DeathWatchNotification.#ctor(Akka.Actor.IActorRef,System.Boolean,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.DeathWatchNotification" /> class.
            </summary>
            <param name="actor">The actor.</param>
            <param name="existenceConfirmed">if set to <c>true</c> [existence confirmed].</param>
            <param name="addressTerminated">if set to <c>true</c> [address terminated].</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.DeathWatchNotification.Actor">
            <summary>
                Gets the actor.
            </summary>
            <value>The actor.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.DeathWatchNotification.ExistenceConfirmed">
            <summary>
                Gets a value indicating whether [existence confirmed].
            </summary>
            <value><c>true</c> if [existence confirmed]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.DeathWatchNotification.AddressTerminated">
            <summary>
                Gets a value indicating whether [address terminated].
            </summary>
            <value><c>true</c> if [address terminated]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Failed">
            <summary>
                Class Failed.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Failed.#ctor(Akka.Actor.IActorRef,System.Exception,System.Int64)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Failed" /> class.
            </summary>
            <param name="child">The child.</param>
            <param name="cause">The cause.</param>
            <param name="uid">The uid</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Failed.Child">
            <summary>
                Gets the child.
            </summary>
            <value>The child.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Failed.Cause">
            <summary>
                Gets the cause.
            </summary>
            <value>The cause.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Supervise">
            <summary>
                Class Supervise.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Supervise.#ctor(Akka.Actor.IActorRef,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Supervise" /> class.
            </summary>
            <param name="child">The child.</param>
            <param name="async">if set to <c>true</c> [asynchronous].</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Supervise.Async">
            <summary>
                Gets a value indicating whether this <see cref="T:Akka.Dispatch.SysMsg.Supervise" /> is asynchronous.
            </summary>
            <value><c>true</c> if asynchronous; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Supervise.Child">
            <summary>
                Gets the child.
            </summary>
            <value>The child.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Watch">
            <summary>
                Class Watch.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Watch.#ctor(Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Watch" /> class.
            </summary>
            <param name="watchee">The watchee.</param>
            <param name="watcher">The watcher.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Watch.Watchee">
            <summary>
                Gets the watchee.
            </summary>
            <value>The watchee.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Watch.Watcher">
            <summary>
                Gets the watcher.
            </summary>
            <value>The watcher.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Unwatch">
            <summary>
                Class Unwatch.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Unwatch.#ctor(Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Unwatch" /> class.
            </summary>
            <param name="watchee">The watchee.</param>
            <param name="watcher">The watcher.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Unwatch.Watchee">
            <summary>
                Gets the watchee.
            </summary>
            <value>The watchee.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Unwatch.Watcher">
            <summary>
                Gets the watcher.
            </summary>
            <value>The watcher.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.ActorTask">
            <summary>
                Class ActorTask.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.ActorTask.#ctor(System.Threading.Tasks.Task)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.ActorTask" /> class.
            </summary>
            <param name="task">The task.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.ActorTask.Task">
            <summary>
                Gets the task.
            </summary>
            <value>The task.</value>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage.#ctor(Akka.Dispatch.ActorTaskScheduler,System.Threading.Tasks.Task,System.Object)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage" /> class.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage.#ctor(System.Exception,System.Object)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage" /> class.
            </summary>
            <param name="exception">The exception.</param>
            <param name="message">The message causing the exception</param>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Restart">
            <summary>
                Class Restart.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Recreate">
            <summary>
                Class Recreate.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Recreate.#ctor(System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Recreate" /> class.
            </summary>
            <param name="cause">The cause.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Recreate.Cause">
            <summary>
                Gets the cause.
            </summary>
            <value>The cause.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Resume">
            <summary>
                Class Resume.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Resume.#ctor(System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Resume" /> class.
            </summary>
            <param name="causedByFailure">The caused by failure.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Resume.CausedByFailure">
            <summary>
                Gets or sets the caused by failure.
            </summary>
            <value>The caused by failure.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Suspend">
            <summary>
                Class Suspend.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Stop">
            <summary>
                Class Stop.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.StopChild">
            <summary>
                INTERNAL
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.StopChild.#ctor(Akka.Actor.IActorRef)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.StopChild" /> class.
            </summary>
            <param name="child">The child.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.StopChild.Child">
            <summary>
                Gets the child.
            </summary>
            <value>The child.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Escalate">
            <summary>
                Class Escalate.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Escalate.#ctor(System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Escalate" /> class.
            </summary>
            <param name="reason">The reason.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Escalate.Reason">
            <summary>
                Gets the reason.
            </summary>
            <value>The reason.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Terminate">
            <summary>
                Class Terminate.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.TerminationHookDone">
            <summary>
                Class Terminate.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.TaskDispatcher">
            <summary>
            Task based dispatcher
            </summary>
        </member>
        <member name="M:Akka.Dispatch.TaskDispatcher.#ctor(Akka.Dispatch.MessageDispatcherConfigurator)">
            <summary>
            Takes a <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.DedicatedThreadPoolConfigHelpers">
            <summary>
            <see cref="T:Akka.Configuration.Config"/> helper class for configuring <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/>
            instances who depend on the Helios <see cref="T:Helios.Concurrency.DedicatedThreadPool"/>.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.DedicatedThreadPoolConfigHelpers.DefaultSingleThreadPoolSettings">
            <summary>
            Default settings for <see cref="T:Akka.Dispatch.SingleThreadDispatcher"/> instances.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ThreadPoolConfig">
            <summary>
            Used inside Akka.Remote for constructing the low-level Helios threadpool, but inside
            vanilla Akka it's also used for constructing custom fixed-size-threadpool dispatchers.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.UnboundedDequeBasedMailbox">
            <summary>
            Mailbox with support for EnqueueFirst. Used primarily for <see cref="T:Akka.Actor.IStash"/> support.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.UnboundedDequeBasedMailbox.CreateSystemMessagesQueue">
            <summary>
            Intended for system messages, creates an <see cref="T:Akka.Dispatch.MessageQueues.UnboundedMessageQueue"/> to be used 
            inside the <see cref="T:Akka.Dispatch.Mailbox"/>.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.UnboundedDequeBasedMailbox.CreateUserMessagesQueue">
            <summary>
            Used for user-defined messages within a <see cref="T:Akka.Dispatch.Mailbox"/>; creates a new <see cref="T:Akka.Dispatch.MessageQueues.UnboundedDequeMessageQueue"/>
            which means that any actor with a <see cref="T:Akka.Actor.IStash"/> can unstash messages to the front of the queue.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akka.Dispatch.UnboundedMailbox">
            <summary>
            Alias for concurrent queue mailbox
            </summary>
        </member>
        <member name="T:Akka.Event.ActorEventBus`2">
            <summary>
            Represents an EventBus where the Subscriber type is ActorRef.
            </summary>
            <typeparam name="TEvent">The event type.</typeparam>
            <typeparam name="TClassifier">The classifier type.</typeparam>
        </member>
        <member name="T:Akka.Event.AddressTerminatedTopic">
            <summary>
            INTERNAL API.
            
            Watchers of remote actor references register themselves as subscribers of
            <see cref="T:Akka.Actor.AddressTerminated"/> notifications. Remote and cluster death watchers
            publish <see cref="T:Akka.Actor.AddressTerminated"/> when a remote system is deemed dead.
            </summary>
        </member>
        <member name="T:Akka.Event.BusLogging">
            <summary>
            A logging adapter implementation publishing log events to the event stream.
            </summary>
        </member>
        <member name="M:Akka.Event.BusLogging.#ctor(Akka.Event.LoggingBus,System.String,System.Type,Akka.Event.ILogMessageFormatter)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.BusLogging" /> class.
            </summary>
            <param name="bus">The logging bus instance that messages will be published to.</param>
            <param name="logSource">The log source.</param>
            <param name="logClass">The log class.</param>
            <param name="logMessageFormatter">The log message formatter.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyError(System.Object)">
            <summary>
            Publishes the error message onto the LoggingBus.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyError(System.Exception,System.Object)">
            <summary>
            Publishes the error message and exception onto the LoggingBus.
            </summary>
            <param name="cause">The exception that caused this error.</param>
            <param name="message">The error message.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyWarning(System.Object)">
            <summary>
            Publishes the the warning message onto the LoggingBus.
            </summary>
            <param name="message">The warning message.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyInfo(System.Object)">
            <summary>
            Publishes the the info message onto the LoggingBus.
            </summary>
            <param name="message">The info message.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyDebug(System.Object)">
            <summary>
            Publishes the the debug message onto the LoggingBus.
            </summary>
            <param name="message">The debug message.</param>
        </member>
        <member name="T:Akka.Event.DeadLetter">
            <summary>
            Represents a message that could not be delivered to it's recipient. 
            This message wraps the original message, the sender and the intended recipient of the message.
            </summary>
        </member>
        <member name="M:Akka.Event.DeadLetter.#ctor(System.Object,Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.DeadLetter"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="recipient">The recipient.</param>
        </member>
        <member name="P:Akka.Event.DeadLetter.Message">
            <summary>
            Gets the original message that could not be delivered.
            </summary>
            <value>The message.</value>
        </member>
        <member name="P:Akka.Event.DeadLetter.Recipient">
            <summary>
            Gets the recipient of the message.
            </summary>
            <value>The recipient of the message.</value>
        </member>
        <member name="P:Akka.Event.DeadLetter.Sender">
            <summary>
            Gets the sender of the message.
            </summary>
            <value>The sender of the message.</value>
        </member>
        <member name="T:Akka.Event.DeadLetterListener">
            <summary>
            Actor responsible for listening to DeadLetter messages and logging them using the EventStream.
            </summary>
        </member>
        <member name="T:Akka.Event.Debug">
            <summary>
            Represents an Debug log event.
            </summary>
        </member>
        <member name="M:Akka.Event.Debug.#ctor(System.String,System.Type,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Debug" /> class.
            </summary>
            <param name="logSource">The log source.</param>
            <param name="logClass">The log class.</param>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Event.DefaultLogger">
            <summary>
            Default logger implementation that outputs logs to the Console.
            </summary>
        </member>
        <member name="M:Akka.Event.DefaultLogger.Print(Akka.Event.LogEvent)">
            <summary>
            Print the specified log event.
            </summary>
            <param name="logEvent">The log event that is to be output.</param>
        </member>
        <member name="T:Akka.Event.DefaultLogMessageFormatter">
            <summary>
            Default implementation of the ILogMessageFormatter that uses string.Format to format a log message.
            </summary>
        </member>
        <member name="M:Akka.Event.DefaultLogMessageFormatter.Format(System.String,System.Object[])">
            <summary>
            Formats the log message using string.Format providing the format and specified args.
            </summary>
            <param name="format">The format string of the message.</param>
            <param name="args">The arguments used to format the message.</param>
            <returns></returns>
        </member>
        <member name="T:Akka.Event.Error">
            <summary>
            Represents an Error log event.
            </summary>
        </member>
        <member name="M:Akka.Event.Error.#ctor(System.Exception,System.String,System.Type,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Error" /> class.
            </summary>
            <param name="cause">The cause.</param>
            <param name="logSource">The log source.</param>
            <param name="logClass">The log class.</param>
            <param name="message">The message.</param>
        </member>
        <member name="P:Akka.Event.Error.Cause">
            <summary>
            Gets the cause of the error.
            </summary>
            <value>The cause.</value>
        </member>
        <member name="M:Akka.Event.Error.ToString">
            <summary>
            Modifies the <see cref="T:Akka.Event.LogEvent"/> printable error stream to also include
            the details of the <see cref="P:Akka.Event.Error.Cause"/> object itself.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akka.Event.EventBus`3">
            <summary>
            Represents the base event bus, internally manages subscriptions using the event type, classifier type and subscriber type.
            </summary>
            <typeparam name="TEvent">The type of the event.</typeparam>
            <typeparam name="TClassifier">The type of the classifier.</typeparam>
            <typeparam name="TSubscriber">The type of the subscriber.</typeparam>
        </member>
        <member name="M:Akka.Event.EventBus`3.SimpleName(System.Object)">
            <summary>
            Simples the name.
            </summary>
            <param name="source">The source.</param>
            <returns>System.String.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.SimpleName(System.Type)">
            <summary>
            Simples the name.
            </summary>
            <param name="source">The source.</param>
            <returns>System.String.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Subscribe(`2,`1)">
            <summary>
            Subscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="classifier">The classifier.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Unsubscribe(`2)">
            <summary>
            Unsubscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Unsubscribe(`2,`1)">
            <summary>
            Unsubscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="classifier">The classifier.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.ClearCache">
            <summary>
            Clears the cache.
            </summary>
        </member>
        <member name="M:Akka.Event.EventBus`3.IsSubClassification(`1,`1)">
            <summary>
            Determines whether [is sub classification] [the specified parent].
            </summary>
            <param name="parent">The parent.</param>
            <param name="child">The child.</param>
            <returns><c>true</c> if [is sub classification] [the specified parent]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Publish(`0,`2)">
            <summary>
            Publishes the specified event.
            </summary>
            <param name="event">The event.</param>
            <param name="subscriber">The subscriber.</param>
        </member>
        <member name="M:Akka.Event.EventBus`3.Classify(`0,`1)">
            <summary>
            Classifies the specified event.
            </summary>
            <param name="event">The event.</param>
            <param name="classifier">The classifier.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.GetClassifier(`0)">
            <summary>
            Gets the classifier.
            </summary>
            <param name="event">The event.</param>
            <returns>`1.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Publish(`0)">
            <summary>
            Publishes the specified event.
            </summary>
            <param name="event">The event.</param>
        </member>
        <member name="M:Akka.Event.EventBus`3.PublishToSubscribers(`0,System.Collections.Generic.List{`2})">
            <summary>
            Publishes to subscribers.
            </summary>
            <param name="event">The event.</param>
            <param name="cachedSubscribers">The cached subscribers.</param>
        </member>
        <member name="M:Akka.Event.EventBus`3.UpdateCacheForEventClassifier(`0,`1)">
            <summary>
            Updates the cache for event classifier.
            </summary>
            <param name="event">The event.</param>
            <param name="eventClass">The event class.</param>
            <returns>List{`2}.</returns>
        </member>
        <member name="T:Akka.Event.EventStreamUnsubscriber">
            <summary>
            INTERNAL API
            
            Watches all actors which subscribe on the given eventStream, and unsubscribes them from it when they are Terminated.
            
            Assumptions note:
             We do not guarantee happens-before in the EventStream when 2 threads subscribe(a) / unsubscribe(a) on the same actor,
            thus the messages sent to this actor may appear to be reordered - this is fine, because the worst-case is starting to
            needlessly watch the actor which will not cause trouble for the stream. This is a trade-off between slowing down
            subscribe calls * because of the need of linearizing the history message sequence and the possibility of sometimes
            watching a few actors too much - we opt for the 2nd choice here.
            </summary>
        </member>
        <member name="T:Akka.Event.EventStreamUnsubscribersProvider">
            <summary>
            Provides factory for Akka.Event.EventStreamUnsubscriber actors with unique names.
            This is needed if someone spins up more EventStreams using the same ActorSystem,
            each stream gets it's own unsubscriber.
            </summary>
        </member>
        <member name="T:Akka.Event.EventStream">
            <summary>
            The EventStream is a pub-sub stream of events that can be both system and user generated. 
            
            The subscribers are IActorRef instances and events can be any object. Subscriptions are hierarchical meaning that if you listen to
            an event for a particular type you will receive events for that type and any sub types.
            
            If the debug flag is activated any operations on the event stream will be published as debug level events.
            </summary>
        </member>
        <member name="F:Akka.Event.EventStream._debug">
            <summary>
            Determines if subscription logging is enabled.
            </summary>
        </member>
        <member name="M:Akka.Event.EventStream.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.EventStream"/> class.
            </summary>
            <param name="debug">if set to <c>true</c> [debug].</param>
        </member>
        <member name="M:Akka.Event.EventStream.Subscribe(Akka.Actor.IActorRef,System.Type)">
            <summary>
            Subscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="channel">The channel.</param>
            <returns><c>true</c> if subscription was successful, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">subscriber</exception>
        </member>
        <member name="M:Akka.Event.EventStream.Unsubscribe(Akka.Actor.IActorRef,System.Type)">
            <summary>
            Unsubscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="channel">The channel.</param>
            <returns><c>true</c> if unsubscription was successful, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">subscriber</exception>
        </member>
        <member name="M:Akka.Event.EventStream.Unsubscribe(Akka.Actor.IActorRef)">
            <summary>
            Unsubscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <returns><c>true</c> if unsubscription was successful, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">subscriber</exception>
        </member>
        <member name="T:Akka.Event.EventStreamExtensions">
            <summary>
            Extension methods for the EventStream class.
            </summary>
        </member>
        <member name="M:Akka.Event.EventStreamExtensions.Subscribe``1(Akka.Event.EventStream,Akka.Actor.IActorRef)">
            <summary>
            Subscribes the specified subscriber.
            </summary>
            <typeparam name="TChannel">The channel.</typeparam>
            <param name="eventStream">The event stream.</param>
            <param name="subscriber">The subscriber.</param>
            <returns><c>true</c> if subscription was successful, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">subscriber</exception>
        </member>
        <member name="M:Akka.Event.EventStreamExtensions.Unsubscribe``1(Akka.Event.EventStream,Akka.Actor.IActorRef)">
            <summary>
            Unsubscribes the specified subscriber.
            </summary>
            <typeparam name="TChannel">The channel.</typeparam>
            <param name="eventStream">The event stream.</param>
            <param name="subscriber">The subscriber.</param>
            <returns><c>true</c> if unsubscription was successful, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">subscriber</exception>
        </member>
        <member name="T:Akka.Event.ILogMessageFormatter">
            <summary>
            Represents a log message formatter, these are used to format log messages based on a string format and an array of format args.
            </summary>
        </member>
        <member name="M:Akka.Event.ILogMessageFormatter.Format(System.String,System.Object[])">
            <summary>
            Format the specified format string using the format args.
            </summary>
            <param name="format">The format string of the message.</param>
            <param name="args">The format args used to format the message.</param>
            <returns></returns>
        </member>
        <member name="T:Akka.Event.Info">
            <summary>
            Represents an Info log event.
            </summary>
        </member>
        <member name="M:Akka.Event.Info.#ctor(System.String,System.Type,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Info" /> class.
            </summary>
            <param name="logSource">The log source.</param>
            <param name="logClass">The log class.</param>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Event.InitializeLogger">
            <summary>
            Message used to initialize a logger.
            </summary> 
        </member>
        <member name="M:Akka.Event.InitializeLogger.#ctor(Akka.Event.LoggingBus)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.InitializeLogger" /> message.
            </summary>
            <param name="loggingBus">The logging bus.</param>
        </member>
        <member name="P:Akka.Event.InitializeLogger.LoggingBus">
            <summary>
            Gets the logging bus instance.
            </summary>
            <value>The logging bus instance.</value>
        </member>
        <member name="T:Akka.Event.LogEvent">
            <summary>
            Represents a LogEvent in the system.
            </summary>
        </member>
        <member name="M:Akka.Event.LogEvent.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.LogEvent" /> class.
            </summary>
        </member>
        <member name="P:Akka.Event.LogEvent.Timestamp">
            <summary>
            Gets the timestamp of this LogEvent.
            </summary>
            <value>The timestamp.</value>
        </member>
        <member name="P:Akka.Event.LogEvent.Thread">
            <summary>
            Gets the thread of this LogEvent.
            </summary>
            <value>The thread.</value>
        </member>
        <member name="P:Akka.Event.LogEvent.LogSource">
            <summary>
            Gets the log source of this LogEvent.
            </summary>
            <value>The log source.</value>
        </member>
        <member name="P:Akka.Event.LogEvent.LogClass">
            <summary>
            Gets the log class of this LogEvent.
            </summary>
            <value>The log class.</value>
        </member>
        <member name="P:Akka.Event.LogEvent.Message">
            <summary>
            Gets the message of this LogEvent.
            </summary>
            <value>The message.</value>
        </member>
        <member name="M:Akka.Event.LogEvent.LogLevel">
            <summary>
            Gets the specified LogLevel for this LogEvent.
            </summary>
            <returns>LogLevel.</returns>
        </member>
        <member name="M:Akka.Event.LogEvent.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this LogEvent.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this LogEvent.</returns>
        </member>
        <member name="T:Akka.Event.LoggerInitialized">
            <summary>
            Message used to notify that a logger has been initialized.
            </summary>
        </member>
        <member name="T:Akka.Event.DummyClassForStringSources">
            <summary>
            This is a “marker” class which is inserted as originator class into
            <see cref="T:Akka.Event.LogEvent"/> when the string representation was supplied directly.
            </summary>
        </member>
        <member name="T:Akka.Event.Logging">
            <summary>
            Provides the functionality for creating logger instances and helpers for converting to/from LogLevel values.
            </summary>
        </member>
        <member name="F:Akka.Event.Logging.StandardOutLogger">
            <summary>
            Returns an instance of the standard out logger.
            </summary>
        </member>
        <member name="M:Akka.Event.Logging.ClassFor(Akka.Event.LogLevel)">
            <summary>
            Classes for.
            </summary>
            <param name="logLevel">The log level.</param>
            <returns>Type.</returns>
            <exception cref="T:System.ArgumentException">Unknown LogLevel;logLevel</exception>
        </member>
        <member name="M:Akka.Event.Logging.StringFor(Akka.Event.LogLevel)">
            <summary>
            Returns the string representation for a particular LogLevel.
            </summary>
            <param name="logLevel">The log level to get the string representation for.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Akka.Event.Logging.GetLogger(Akka.Actor.IActorContext,Akka.Event.ILogMessageFormatter)">
            <summary>
            Gets an instance of the logger.
            </summary>
            <param name="context">The context.</param>
            <param name="logMessageFormatter">The log message formatter.</param>
            <returns>A logging adapter instance.</returns>
        </member>
        <member name="M:Akka.Event.Logging.GetLogger(Akka.Actor.ActorSystem,System.Object,Akka.Event.ILogMessageFormatter)">
            <summary>
            Gets an instance of the logger.
            </summary>
            <param name="system">The actor system.</param>
            <param name="logSourceObj">The log source object.</param>
            <param name="logMessageFormatter">The log message formatter.</param>
            <returns>A logging adapter instance.</returns>
        </member>
        <member name="M:Akka.Event.Logging.GetLogger(Akka.Event.LoggingBus,System.Object,Akka.Event.ILogMessageFormatter)">
            <summary>
            Gets an instance of the logger.
            </summary>
            <param name="loggingBus">The logging bus this logger will write to.</param>
            <param name="logSourceObj">The log source object.</param>
            <param name="logMessageFormatter">The log message formatter.</param>
            <returns>A logging adapter instance.</returns>
        </member>
        <member name="M:Akka.Event.Logging.LogLevelFor(System.String)">
            <summary>
            Gets the LogLevel for a particular log level string.
            </summary>
            <param name="logLevel">The log level string.</param>
            <returns>The LogLevel mapping to the string based log level.</returns>
            <exception cref="T:System.ArgumentException">Unknown LogLevel;logLevel</exception>
        </member>
        <member name="M:Akka.Event.Logging.LogLevelFor``1">
            <summary>
            Given the type of <see cref="T:Akka.Event.LogEvent"/> returns the corresponding <see cref="T:Akka.Event.LogLevel"/>
            </summary>
            <typeparam name="T"></typeparam>
            <returns>The <see cref="T:Akka.Event.LogLevel"/> that corresponds to the specified type.</returns>
            <exception cref="T:System.ArgumentException">Thrown for unknown types, i.e. when <typeparamref name="T"/> is not
            <see cref="T:Akka.Event.Debug"/>, <see cref="T:Akka.Event.Info"/>, <see cref="T:Akka.Event.Warning"/> or<see cref="T:Akka.Event.Error"/></exception>
        </member>
        <member name="T:Akka.Event.ILoggingAdapter">
            <summary>
            Provides a logging adapter used to log events within the system.
            </summary>
        </member>
        <member name="P:Akka.Event.ILoggingAdapter.IsDebugEnabled">
            <summary>Returns <c>true</c> if Debug level is enabled.</summary>
        </member>
        <member name="P:Akka.Event.ILoggingAdapter.IsInfoEnabled">
            <summary>Returns <c>true</c> if Info level is enabled.</summary>
        </member>
        <member name="P:Akka.Event.ILoggingAdapter.IsWarningEnabled">
            <summary>Returns <c>true</c> if Warning level is enabled.</summary>
        </member>
        <member name="P:Akka.Event.ILoggingAdapter.IsErrorEnabled">
            <summary>Returns <c>true</c> if Error level is enabled.</summary>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.IsEnabled(Akka.Event.LogLevel)">
            <summary>Returns <c>true</c> if the specified level is enabled.</summary>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Debug(System.String,System.Object[])">
            <summary>Logs a message with the Debug level.</summary>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Info(System.String,System.Object[])">
            <summary>Logs a message with the Info level.</summary>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Warn(System.String,System.Object[])">
            <summary>Logs a message with the Warning level.</summary>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Warning(System.String,System.Object[])">
            <summary>Logs a message with the Warning level.</summary>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Error(System.String,System.Object[])">
            <summary>Logs a message with the Error level.</summary>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Error(System.Exception,System.String,System.Object[])">
            <summary>Logs a message with the Error level.</summary>
            <param name="cause">The cause.</param>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Log(Akka.Event.LogLevel,System.String,System.Object[])">
            <summary>Logs a message with the specified level.</summary>
            <param name="logLevel">The log level.</param>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="T:Akka.Event.LoggingAdapterBase">
            <summary>
            Represents a base logging adapter implementation which can be used by logging adapter implementations.
            </summary>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.#ctor(Akka.Event.ILogMessageFormatter)">
            <summary>
            Creates an instance of the LoggingAdapterBase.
            </summary>
            <param name="logMessageFormatter">The log message formatter used by this logging adapter.</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown when the supplied message formatter is null.</exception>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.IsEnabled(Akka.Event.LogLevel)">
            <summary>
            Checks the logging adapter to see if the supplied <paramref name="logLevel"/> is enabled.
            </summary>
            <param name="logLevel">The log level to check if it is enabled in this logging adapter.</param>
            <returns><c>true</c> if the supplied log level is enabled; otherwise <c>false</c></returns>
            <exception cref="T:System.NotSupportedException">This exception is thrown when the supplied log level is unknown.</exception>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.NotifyLog(Akka.Event.LogLevel,System.Object)">
            <summary>
            Handles logging a log event for a particular level if that level is enabled. 
            </summary>
            <param name="logLevel">The log level of the log event.</param>
            <param name="message">The log message of the log event.</param>
            <exception cref="T:System.NotSupportedException">This exception is thrown when the supplied log level is unknown.</exception>
        </member>
        <member name="T:Akka.Event.LoggingBus">
            <summary>
            Represents a logging bus which subscribes loggers to the system LogEvents for the desired minimum level.
            </summary>
        </member>
        <member name="P:Akka.Event.LoggingBus.LogLevel">
            <summary>
            Gets the minimum log level that this LoggingBus will subscribe to, any LogEvents with a log level below will not be subscribed to.
            </summary>
            <value>The log level.</value>
        </member>
        <member name="M:Akka.Event.LoggingBus.IsSubClassification(System.Type,System.Type)">
            <summary>
            Determines whether [is sub classification] [the specified parent].
            </summary>
            <param name="parent">The parent.</param>
            <param name="child">The child.</param>
            <returns><c>true</c> if [is sub classification] [the specified parent]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Event.LoggingBus.Publish(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Publishes the specified event.
            </summary>
            <param name="event">The event.</param>
            <param name="subscriber">The subscriber.</param>
        </member>
        <member name="M:Akka.Event.LoggingBus.Classify(System.Object,System.Type)">
            <summary>
            Classifies the specified event.
            </summary>
            <param name="event">The event.</param>
            <param name="classifier">The classifier.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.LoggingBus.GetClassifier(System.Object)">
            <summary>
            Gets the classifier for the LogEvent.
            </summary>
            <param name="event">The event.</param>
            <returns>Type.</returns>
        </member>
        <member name="M:Akka.Event.LoggingBus.StartDefaultLoggers(Akka.Actor.Internal.ActorSystemImpl)">
            <summary>
            Starts the default loggers.
            </summary>
            <param name="system">The system.</param>
            <exception cref="T:System.Exception">Can not use logger of type: + loggerType</exception>
        </member>
        <member name="M:Akka.Event.LoggingBus.StartStdoutLogger(Akka.Actor.Settings)">
            <summary>
            Starts the StandardOutLogger logger.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Event.LoggingBus.SetUpStdoutLogger(Akka.Actor.Settings)">
            <summary>
            Sets up StandardOutLogger logger.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Event.LoggingBus.SetLogLevel(Akka.Event.LogLevel)">
            <summary>
            Sets the minimum log level for the LoggingBus, any LogEvents below this level will not be listened to.
            </summary>
            <param name="logLevel">The log level.</param>
        </member>
        <member name="T:Akka.Event.LogLevel">
            <summary>
            Enumeration representing the various log levels in the system.
            </summary>
        </member>
        <member name="F:Akka.Event.LogLevel.DebugLevel">
            <summary>
            The debug log level.
            </summary>
        </member>
        <member name="F:Akka.Event.LogLevel.InfoLevel">
            <summary>
            The information log level.
            </summary>
        </member>
        <member name="F:Akka.Event.LogLevel.WarningLevel">
            <summary>
            The warning log level.
            </summary>
        </member>
        <member name="F:Akka.Event.LogLevel.ErrorLevel">
            <summary>
            The error log level.
            </summary>
        </member>
        <member name="T:Akka.Event.LogMessage">
            <summary>
            Represents a log message which is composed of a format string and format args.
            </summary>
        </member>
        <member name="P:Akka.Event.LogMessage.Format">
            <summary>
            Gets the format string of this log message.
            </summary>
        </member>
        <member name="P:Akka.Event.LogMessage.Args">
            <summary>
            Gets the format args of this log message.
            </summary>
        </member>
        <member name="M:Akka.Event.LogMessage.#ctor(Akka.Event.ILogMessageFormatter,System.String,System.Object[])">
            <summary>
            Initializes an instance of the LogMessage with the specified formatter, format and args.
            </summary>
            <param name="formatter">The formatter for the LogMessage.</param>
            <param name="format">The string format of the LogMessage.</param>
            <param name="args">The format args of the LogMessage.</param>
        </member>
        <member name="T:Akka.Event.StandardOutLogger">
            <summary>
            Represents a logger that logs using the StandardOutWriter.
            The logger can also be configured to use colors for the various log event types.
            </summary>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.Provider">
            <summary>
            Gets the provider.
            </summary>
            <exception cref="T:System.NotSupportedException">StandardOutLogger does not provide</exception>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.Path">
            <summary>
            Gets the path of this actor.
            </summary>
        </member>
        <member name="M:Akka.Event.StandardOutLogger.TellInternal(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Handles log events printing them to the Console.
            </summary>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <exception cref="T:System.ArgumentNullException">message</exception>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.DebugColor">
            <summary>
            Gets or Sets the color of Debug events.
            </summary>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.InfoColor">
            <summary>
            Gets or Sets the color of Info events.
            </summary>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.WarningColor">
            <summary>
            Gets or Sets the color of Warning events.
            </summary>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.ErrorColor">
            <summary>
            Gets or Sets the color of Error events. 
            </summary>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.UseColors">
            <summary>
            Gets or Sets whether or not to use colors when printing events.
            </summary>
        </member>
        <member name="M:Akka.Event.StandardOutLogger.PrintLogEvent(Akka.Event.LogEvent)">
            <summary>
            Prints the LogEvent using the StandardOutWriter.
            </summary>
            <param name="logEvent"></param>
        </member>
        <member name="T:Akka.Event.Subscription`2">
            <summary>
            Represents a Subscription to the EventBus.
            </summary>
            <typeparam name="TSubscriber">The type of the subscriber.</typeparam>
            <typeparam name="TClassifier">The type of the classifier.</typeparam>
        </member>
        <member name="M:Akka.Event.Subscription`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Subscription`2"/> class.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="unsubscriptions">The unsubscriptions.</param>
        </member>
        <member name="M:Akka.Event.Subscription`2.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Subscription`2"/> class.
            </summary>
            <param name="subscriber">The subscriber.</param>
        </member>
        <member name="P:Akka.Event.Subscription`2.Subscriber">
            <summary>
            Gets the subscriber attached to this subscription.
            </summary>
            <value>The subscriber.</value>
        </member>
        <member name="P:Akka.Event.Subscription`2.Unsubscriptions">
            <summary>
            Gets the unsubscriptions of this particular subscription.
            </summary>
            <value>The unsubscriptions.</value>
        </member>
        <member name="T:Akka.Event.TraceLogger">
            <summary>
            TraceLogger - writes to System.Trace; useful for systems that use trace listeners.
            
            To activate the TraceLogger, add loggers = [""Akka.Event.TraceLogger, Akka""] to your config
            </summary>
        </member>
        <member name="T:Akka.Event.UnhandledMessage">
            <summary>
            Represents an UnhandledMessage that was not handled by the Recipient.
            </summary>
        </member>
        <member name="M:Akka.Event.UnhandledMessage.#ctor(System.Object,Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.UnhandledMessage" /> class.
            </summary>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="recipient">The recipient.</param>
        </member>
        <member name="P:Akka.Event.UnhandledMessage.Message">
            <summary>
            Gets the original message that could not be handled.
            </summary>
            <value>The message.</value>
        </member>
        <member name="P:Akka.Event.UnhandledMessage.Sender">
            <summary>
            Gets the sender of the message.
            </summary>
            <value>The sender of the message.</value>
        </member>
        <member name="P:Akka.Event.UnhandledMessage.Recipient">
            <summary>
            Gets the recipient of the message.
            </summary>
            <value>The recipient of the message.</value>
        </member>
        <member name="T:Akka.Event.Warning">
            <summary>
            Represents an Warning log event.
            </summary>
        </member>
        <member name="M:Akka.Event.Warning.#ctor(System.String,System.Type,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Warning" /> class.
            </summary>
            <param name="logSource">The log source.</param>
            <param name="logClass">The log class.</param>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Pattern.BackoffSupervisor">
            <summary>
            Actor used to supervise actors with ability to restart them after back-off timeout occurred. 
            It's designed for cases when i.e. persistent actor stops due to journal unavailability or failure. 
            In this case it better to wait before restart.
            </summary>
        </member>
        <member name="T:Akka.Pattern.BackoffSupervisor.GetCurrentChild">
            <summary>
            Request <see cref="T:Akka.Pattern.BackoffSupervisor"/> with this message to receive <see cref="T:Akka.Pattern.BackoffSupervisor.CurrentChild"/> response with current child.
            </summary>
        </member>
        <member name="T:Akka.Pattern.CircuitBreaker">
             <summary>
             Provides circuit breaker functionality to provide stability when working with 
             "dangerous" operations, e.g. calls to remote systems
             
            <list type="bullet">
            <listheader>
                <description>Transitions through three states:</description>
            </listheader>
            <item>
                <term>In *Closed* state, </term>
                <description>calls pass through until the maxFailures count is reached. 
                     This causes the circuit breaker to open. Both exceptions and calls exceeding 
                     callTimeout are considered failures.</description>
            </item>
            <item>
                <term>In *Open* state, </term>
                <description>calls fail-fast with an exception. After resetTimeout, 
                     circuit breaker transitions to half-open state.</description>
            </item>
            <item>
                <term>In *Half-Open* state, </term>
                <description>the first call will be allowed through, if it succeeds 
                     the circuit breaker will reset to closed state. If it fails, the circuit 
                     breaker will re-open to open state. All calls beyond the first that execute 
                     while the first is running will fail-fast with an exception.</description>
            </item>
            </list>
             </summary>
        </member>
        <member name="F:Akka.Pattern.CircuitBreaker._currentState">
            <summary>
            The current state of the breaker -- Closed, Half-Open, or Closed -- *access only via helper methods*
            </summary>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.SwapState(Akka.Util.Internal.AtomicState,Akka.Util.Internal.AtomicState)">
            <summary>
            Helper method for access to the underlying state via Interlocked
            </summary>
            <param name="oldState">Previous state on transition</param>
            <param name="newState">Next state on transition</param>
            <returns>Whether the previous state matched correctly</returns>
        </member>
        <member name="P:Akka.Pattern.CircuitBreaker.CurrentState">
            <summary>
            Helper method for access to the underlying state via Interlocked
            </summary>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.Create(System.Int32,System.TimeSpan,System.TimeSpan)">
            <summary>
            Create a new CircuitBreaker
            </summary>
            <param name="maxFailures">Maximum number of failures before opening the circuit</param>
            <param name="callTimeout"><see cref="T:System.TimeSpan"/> of time after which to consider a call a failure</param>
            <param name="resetTimeout"><see cref="T:System.TimeSpan"/> of time after which to attempt to close the circuit</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.#ctor(System.Int32,System.TimeSpan,System.TimeSpan)">
            <summary>
            Create a new CircuitBreaker
            </summary>
            <param name="maxFailures">Maximum number of failures before opening the circuit</param>
            <param name="callTimeout"><see cref="T:System.TimeSpan"/> of time after which to consider a call a failure</param>
            <param name="resetTimeout"><see cref="T:System.TimeSpan"/> of time after which to attempt to close the circuit</param>
            <returns></returns>
        </member>
        <member name="P:Akka.Pattern.CircuitBreaker.CurrentFailureCount">
            <summary>
            Retrieves current failure count.
            </summary>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.WithCircuitBreaker``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Wraps invocation of asynchronous calls that need to be protected
            </summary>
            <typeparam name="T"></typeparam>
            <param name="body">Call needing protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing the call result</returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.WithCircuitBreaker(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Wraps invocation of asynchronous calls that need to be protected
            </summary>
            <param name="body">Call needing protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.WithSyncCircuitBreaker(System.Action)">
            <summary>
            The failure will be recorded farther down.
            </summary>
            <param name="body"></param>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.WithSyncCircuitBreaker``1(System.Func{``0})">
             <summary>
             Wraps invocations of asynchronous calls that need to be protected
             If this does not complete within the time allotted, it should return default(<typeparamref name="T"/>)
             
             <code>
              Await.result(
                  withCircuitBreaker(try Future.successful(body) catch { case NonFatal(t) ⇒ Future.failed(t) }),
                  callTimeout)
             </code>
            
             </summary>
             <typeparam name="T"></typeparam>
             <param name="body"></param>
             <returns><typeparamref name="T"/> or default(<typeparamref name="T"/>)</returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.OnOpen(System.Action)">
            <summary>
            Adds a callback to execute when circuit breaker opens
            </summary>
            <param name="callback"><see cref="T:System.Action"/> Handler to be invoked on state change</param>
            <returns>CircuitBreaker for fluent usage</returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.OnHalfOpen(System.Action)">
            <summary>
            Adds a callback to execute when circuit breaker transitions to half-open
            </summary>
            <param name="callback"><see cref="T:System.Action"/> Handler to be invoked on state change</param>
            <returns>CircuitBreaker for fluent usage</returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.OnClose(System.Action)">
            <summary>
            Adds a callback to execute when circuit breaker state closes
            </summary>
            <param name="callback"><see cref="T:System.Action"/> Handler to be invoked on state change</param>
            <returns>CircuitBreaker for fluent usage</returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.Transition(Akka.Util.Internal.AtomicState,Akka.Util.Internal.AtomicState)">
            <summary>
            Implements consistent transition between states. Throws IllegalStateException if an invalid transition is attempted.
            </summary>
            <param name="fromState">State being transitioning from</param>
            <param name="toState">State being transitioned to</param>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.TripBreaker(Akka.Util.Internal.AtomicState)">
            <summary>
            Trips breaker to an open state. This is valid from Closed or Half-Open states
            </summary>
            <param name="fromState">State we're coming from (Closed or Half-Open)</param>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.ResetBreaker">
            <summary>
            Resets breaker to a closed state.  This is valid from an Half-Open state only.
            </summary>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.AttemptReset">
            <summary>
            Attempts to reset breaker by transitioning to a half-open state.  This is valid from an Open state only.
            </summary>
        </member>
        <member name="T:Akka.Pattern.Open">
            <summary>
            Concrete implementation of Open state
            </summary>
        </member>
        <member name="M:Akka.Pattern.Open.Invoke``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Fail-fast on any invocation
            </summary>
            <typeparam name="T"></typeparam>
            <param name="body">Implementation of the call that needs protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Pattern.Open.Invoke(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Implementation of invoke, which simply attempts the call
            </summary>
            <param name="body">Implementation of the call that needs protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Pattern.Open.CallFails">
            <summary>
            No-op for open, calls are never executed so cannot succeed or fail
            </summary>
        </member>
        <member name="M:Akka.Pattern.Open.CallSucceeds">
            <summary>
            No-op for open, calls are never executed so cannot succeed or fail
            </summary>
        </member>
        <member name="M:Akka.Pattern.Open.EnterInternal">
            <summary>
            On entering this state, schedule an attempted reset and store the entry time to
            calculate remaining time before attempted reset.
            </summary>
        </member>
        <member name="T:Akka.Pattern.HalfOpen">
            <summary>
            Concrete implementation of half-open state
            </summary>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.Invoke``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Allows a single call through, during which all other callers fail-fast. If the call fails, the breaker reopens.
            If the call succeeds, the breaker closes.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="body">Implementation of the call that needs protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.Invoke(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Allows a single call through, during which all other callers fail-fast. If the call fails, the breaker reopens.
            If the call succeeds, the breaker closes.
            </summary>
            <param name="body">Implementation of the call that needs protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.CallFails">
            <summary>
            Reopen breaker on failed call.
            </summary>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.CallSucceeds">
            <summary>
            Reset breaker on successful call.
            </summary>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.EnterInternal">
            <summary>
            On entry, guard should be reset for that first call to get in
            </summary>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.ToString">
            <summary>
            Override for more descriptive toString
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akka.Pattern.Closed">
            <summary>
            Concrete implementation of Closed state
            </summary>
        </member>
        <member name="M:Akka.Pattern.Closed.Invoke``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Implementation of invoke, which simply attempts the call
            </summary>
            <typeparam name="T"></typeparam>
            <param name="body">Implementation of the call that needs protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Pattern.Closed.Invoke(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Implementation of invoke, which simply attempts the call
            </summary>
            <param name="body">Implementation of the call that needs protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Pattern.Closed.CallFails">
            <summary>
            On failed call, the failure count is incremented.  The count is checked against the configured maxFailures, and
            the breaker is tripped if we have reached maxFailures.
            </summary>
        </member>
        <member name="M:Akka.Pattern.Closed.CallSucceeds">
            <summary>
            On successful call, the failure count is reset to 0
            </summary>
        </member>
        <member name="M:Akka.Pattern.Closed.EnterInternal">
            <summary>
            On entry of this state, failure count is reset.
            </summary>
        </member>
        <member name="M:Akka.Pattern.Closed.ToString">
            <summary>
            Override for more descriptive toString
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akka.Pattern.OpenCircuitException">
            <summary>
            This exception is thrown when the CircuitBreaker is open.
            </summary>
        </member>
        <member name="M:Akka.Pattern.OpenCircuitException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.OpenCircuitException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Pattern.OpenCircuitException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.OpenCircuitException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Pattern.OpenCircuitException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.OpenCircuitException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Pattern.OpenCircuitException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.OpenCircuitException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Pattern.IllegalStateException">
            <summary>
            This exception is thrown when a method has been invoked at an illegal or inappropriate time.
            </summary>
        </member>
        <member name="M:Akka.Pattern.IllegalStateException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.IllegalStateException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Pattern.IllegalStateException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.IllegalStateException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerEx">The inner <see cref="T:System.Exception"/> that was thrown.</param>
        </member>
        <member name="M:Akka.Pattern.IllegalStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.IllegalStateException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.IO.Udp">
             <summary>
             UDP Extension for Akka’s IO layer.
            
             This extension implements the connectionless UDP protocol without
             calling `connect` on the underlying sockets, i.e. without restricting
             from whom data can be received. For “connected” UDP mode see <see cref="T:Akka.IO.UdpConnected"/>.
            
             For a full description of the design and philosophy behind this IO
             implementation please refer to <see href="http://doc.akka.io/">the Akka online documentation</see>.
             </summary>
        </member>
        <member name="T:Akka.IO.Udp.Message">
            <summary>The common interface for <see cref="T:Akka.IO.Udp.Command"/> and <see cref="T:Akka.IO.Udp.Event"/>.</summary>
        </member>
        <member name="T:Akka.IO.Udp.Command">
            <summary>The common type of all commands supported by the UDP implementation.</summary>
        </member>
        <member name="T:Akka.IO.Udp.NoAck">
            <summary>
            Each <see cref="T:Akka.IO.Udp.Send"/> can optionally request a positive acknowledgment to be sent
            to the commanding actor. If such notification is not desired the <see cref="P:Akka.IO.Udp.Send.Ack"/>
            must be set to an instance of this class. The token contained within can be used
            to recognize which write failed when receiving a <see cref="T:Akka.IO.Udp.CommandFailed"/> message.
            </summary>
        </member>
        <member name="F:Akka.IO.Udp.NoAck.Instance">
            <summary>
            Default <see cref="T:Akka.IO.Udp.NoAck"/> instance which is used when no acknowledgment information is
            explicitly provided. Its “token” is `null`.
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.Send">
             <summary>
             This message is understood by the “simple sender” which can be obtained by
             sending the <see cref="T:Akka.IO.Udp.SimpleSender"/> query to the <see cref="P:Akka.IO.UdpExt.Manager"/> as well as by
             the listener actors which are created in response to <see cref="T:Akka.IO.Udp.Bind"/>. It will send
             the given payload data as one UDP datagram to the given target address. The
             UDP actor will respond with <see cref="T:Akka.IO.Udp.CommandFailed"/> if the send could not be
             enqueued to the O/S kernel because the send buffer was full. If the given
             `ack` is not of type <see cref="T:Akka.IO.Udp.NoAck"/> the UDP actor will reply with the given
             object as soon as the datagram has been successfully enqueued to the O/S
             kernel.
            
             The sending UDP socket’s address belongs to the “simple sender” which does
             not handle inbound datagrams and sends from an ephemeral port; therefore
             sending using this mechanism is not suitable if replies are expected, use
             <see cref="T:Akka.IO.Udp.Bind"/> in that case.
             </summary>
        </member>
        <member name="T:Akka.IO.Udp.Bind">
            <summary>
             Send this message to the <see cref="P:Akka.IO.UdpExt.Manager"/> in order to bind to the given
             local port (or an automatically assigned one if the port number is zero).
             The listener actor for the newly bound port will reply with a <see cref="T:Akka.IO.Udp.Bound"/>
             message, or the manager will reply with a <see cref="T:Akka.IO.Udp.CommandFailed"/> message.
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.Unbind">
            <summary>
            Send this message to the listener actor that previously sent a <see cref="T:Akka.IO.Udp.Bound"/>
            message in order to close the listening socket. The recipient will reply
            with an <see cref="T:Akka.IO.Udp.Unbound"/> message.
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.SimpleSender">
             <summary>
             Retrieve a reference to a “simple sender” actor of the UDP extension.
             The newly created “simple sender” will reply with the <see cref="T:Akka.IO.Udp.SimpleSenderReady" /> notification.
            
             The “simple sender” is a convenient service for being able to send datagrams
             when the originating address is meaningless, i.e. when no reply is expected.
            
             The “simple sender” will not stop itself, you will have to send it a <see cref="T:Akka.Actor.PoisonPill"/>
             when you want to close the socket.
             </summary>
        </member>
        <member name="T:Akka.IO.Udp.SuspendReading">
            <summary>
            Send this message to a listener actor (which sent a <see cref="T:Akka.IO.Udp.Bound"/> message) to
            have it stop reading datagrams from the network. If the O/S kernel’s receive
            buffer runs full then subsequent datagrams will be silently discarded.
            Re-enable reading from the socket using the `ResumeReading` command.
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.ResumeReading">
            <summary>
             This message must be sent to the listener actor to re-enable reading from
             the socket after a `SuspendReading` command.
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.Event">
            <summary>The common type of all events emitted by the UDP implementation.</summary>
        </member>
        <member name="T:Akka.IO.Udp.Received">
            <summary>
             When a listener actor receives a datagram from its socket it will send
             it to the handler designated in the <see cref="T:Akka.IO.Udp.Bind"/> message using this message type.
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.CommandFailed">
            <summary>
            When a command fails it will be replied to with this message type,
            wrapping the failing command object.
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.Bound">
            <summary>
            This message is sent by the listener actor in response to a <see cref="T:Akka.IO.Udp.Bind"/> command.
            If the address to bind to specified a port number of zero, then this message
            can be inspected to find out which port was automatically assigned.
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.SimpleSenderReady">
            <summary> The “simple sender” sends this message type in response to a <see cref="T:Akka.IO.Udp.SimpleSender"/> query. </summary>
        </member>
        <member name="T:Akka.IO.Udp.Unbound">
            <summary>
            This message is sent by the listener actor in response to an `Unbind` command
            after the socket has been closed.
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.SO.Broadcast">
             <summary>
             <see cref="T:Akka.IO.Inet.SocketOption"/> to set the SO_BROADCAST option
            
             For more information see cref="System.Net.Sockets.Socket.EnableBroadcast"/>
             </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected">
             <summary>
             UDP Extension for Akka’s IO layer.
            
             This extension implements the connectionless UDP protocol with
             calling `connect` on the underlying sockets, i.e. with restricting
             from whom data can be received. For “unconnected” UDP mode see <see cref="T:Akka.IO.Udp"/>.
            
             For a full description of the design and philosophy behind this IO
             implementation please refer to <see href="http://doc.akka.io/">the Akka online documentation</see>.
             </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Message">
            <summary>
            The common interface for <see cref="T:Akka.IO.UdpConnected.Command"/> and <see cref="T:Akka.IO.UdpConnected.Event"/>.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Command">
            <summary>
            The common type of all commands supported by the UDP implementation.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.NoAck">
            <summary>
            Each <see cref="T:Akka.IO.UdpConnected.Send"/> can optionally request a positive acknowledgment to be sent
            to the commanding actor. If such notification is not desired the <see cref="P:Akka.IO.UdpConnected.Send.Ack"/>
            must be set to an instance of this class. The token contained within can be used
            to recognize which write failed when receiving a <see cref="T:Akka.IO.UdpConnected.CommandFailed"/> message.
            </summary>
        </member>
        <member name="F:Akka.IO.UdpConnected.NoAck.Instance">
            <summary>
            Default <see cref="T:Akka.IO.UdpConnected.NoAck"/> instance which is used when no acknowledgment information is
            explicitly provided. Its “token” is `null`.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Send">
            <summary>
            This message is understood by the connection actors to send data to their
            designated destination. The connection actor will respond with
            <see cref="T:Akka.IO.UdpConnected.CommandFailed"/> if the send could not be enqueued to the O/S kernel
            because the send buffer was full. If the given `ack` is not of type <see cref="T:Akka.IO.UdpConnected.NoAck"/>
            the connection actor will reply with the given object as soon as the datagram
            has been successfully enqueued to the O/S kernel.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Connect">
            <summary>
            Send this message to the <see cref="P:Akka.IO.UdpExt.Manager"/> in order to bind to a local
            port (optionally with the chosen `localAddress`) and create a UDP socket
            which is restricted to sending to and receiving from the given `remoteAddress`.
            All received datagrams will be sent to the designated `handler` actor.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Disconnect">
            <summary>
            Send this message to a connection actor (which had previously sent the
            <see cref="T:Akka.IO.UdpConnected.Connected"/> message) in order to close the socket. The connection actor
            will reply with a <see cref="T:Akka.IO.UdpConnected.Disconnected"/> message.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.SuspendReading">
            <summary>
            Send this message to a listener actor (which sent a <see cref="T:Akka.IO.Udp.Bound"/> message) to
            have it stop reading datagrams from the network. If the O/S kernel’s receive
            buffer runs full then subsequent datagrams will be silently discarded.
            Re-enable reading from the socket using the `ResumeReading` command.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.ResumeReading">
            <summary>
            This message must be sent to the listener actor to re-enable reading from
            the socket after a `SuspendReading` command.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Event">
            <summary>
            The common type of all events emitted by the UDP implementation.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Received">
            <summary>
            When a connection actor receives a datagram from its socket it will send
            it to the handler designated in the <see cref="T:Akka.IO.Udp.Bind"/> message using this message type.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.CommandFailed">
            <summary>
            When a command fails it will be replied to with this message type,
            wrapping the failing command object.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Connected">
            <summary>
            This message is sent by the connection actor to the actor which sent the
            <see cref="T:Akka.IO.UdpConnected.Connect"/> message when the UDP socket has been bound to the local and
            remote addresses given.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Disconnected">
            <summary>
            This message is sent by the connection actor to the actor which sent the
            `Disconnect` message when the UDP socket has been closed.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpManager">
             TODO: CLRify comment
             
             INTERNAL API
            
             UdpManager is a facade for simple fire-and-forget style UDP operations
            
             UdpManager is obtainable by calling {{{ IO(Udp) }}} (see [[akka.io.IO]] and [[akka.io.Udp]])
            
             *Warning!* Udp uses [[java.nio.channels.DatagramChannel#send]] to deliver datagrams, and as a consequence if a
             security manager  has been installed then for each datagram it will verify if the target address and port number are
             permitted. If this performance overhead is undesirable use the connection style Udp extension.
            
             == Bind and send ==
            
             To bind and listen to a local address, a <see cref="T:Akka.IO.Udp.Bind"/> command must be sent to this actor. If the binding
             was successful, the sender of the <see cref="T:Akka.IO.Udp.Bind"/> will be notified with a <see cref="T:Akka.IO.Udp.Bound"/>
             message. The sender of the <see cref="T:Akka.IO.Udp.Bound"/> message is the Listener actor (an internal actor responsible for
             listening to server events). To unbind the port an <see cref="T:Akka.IO.Udp.Unbind"/> message must be sent to the Listener actor.
            
             If the bind request is rejected because the Udp system is not able to register more channels (see the <c>nr-of-selectors</c>
             and <c>max-channels</c> configuration options in the <c>akka.io.udp</c> section of the configuration) the sender will be notified
             with a <see cref="T:Akka.IO.Udp.CommandFailed"/> message. This message contains the original command for reference.
            
             The handler provided in the <see cref="T:Akka.IO.Udp.Bind"/> message will receive inbound datagrams to the bound port
             wrapped in <see cref="T:Akka.IO.Udp.Received"/> messages which contain the payload of the datagram and the sender address.
            
             UDP datagrams can be sent by sending <see cref="T:Akka.IO.Udp.Send"/> messages to the Listener actor. The sender port of the
             outbound datagram will be the port to which the Listener is bound.
            
             == Simple send ==
            
             Udp provides a simple method of sending UDP datagrams if no reply is expected. To acquire the Sender actor
             a SimpleSend message has to be sent to the manager. The sender of the command will be notified by a SimpleSenderReady
             message that the service is available. UDP datagrams can be sent by sending <see cref="T:Akka.IO.Udp.Send"/> messages to the
             sender of SimpleSenderReady. All the datagrams will contain an ephemeral local port as sender and answers will be
             discarded.
            
        </member>
        <member name="T:Akka.IO.DirectByteBufferPool">
             <summary>
             INTERNAL API
             
             A buffer pool which keeps a free list of direct buffers of a specified default
             size in a simple fixed size stack.
            
             If the stack is full the buffer is de-referenced and available to be
             freed by normal garbage collection.
             </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Connect">
            <summary>
            The Connect message is sent to the TCP manager actor, which is obtained via
            <see cref="P:Akka.IO.TcpExt.Manager" />. Either the manager replies with a <see cref="T:Akka.IO.Tcp.CommandFailed" />
            or the actor handling the new connection replies with a <see cref="T:Akka.IO.Tcp.Connected" />
            message.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Bind">
            <summary>
            The Bind message is send to the TCP manager actor, which is obtained via
            <see cref="P:Akka.IO.TcpExt.Manager" /> in order to bind to a listening socket. The manager
            replies either with a <see cref="T:Akka.IO.Tcp.CommandFailed" /> or the actor handling the listen
            socket replies with a <see cref="T:Akka.IO.Tcp.Bound" /> message. If the local port is set to 0 in
            the Bind message, then the <see cref="T:Akka.IO.Tcp.Bound" /> message should be inspected to find
            the actual port which was bound to.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Register">
            <summary>
            This message must be sent to a TCP connection actor after receiving the
            <see cref="T:Akka.IO.Tcp.Connected" /> message. The connection will not read any data from the
            socket until this message is received, because this message defines the
            actor which will receive all inbound data.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Unbind">
            <summary>
            In order to close down a listening socket, send this message to that socket’s
            actor (that is the actor which previously had sent the <see cref="T:Akka.IO.Tcp.Bound" /> message). The
            listener socket actor will reply with a <see cref="T:Akka.IO.Tcp.Unbound" /> message.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.CloseCommand">
            <summary>
            Common interface for all commands which aim to close down an open connection.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Close">
            <summary>
            A normal close operation will first flush pending writes and then close the
            socket. The sender of this command and the registered handler for incoming
            data will both be notified once the socket is closed using a <see cref="T:Akka.IO.Tcp.Closed" />
            message.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ConfirmedClose">
            <summary>
            A confirmed close operation will flush pending writes and half-close the
            connection, waiting for the peer to close the other half. The sender of this
            command and the registered handler for incoming data will both be notified
            once the socket is closed using a <see cref="T:Akka.IO.Tcp.ConfirmedClosed" /> message.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Abort">
            <summary>
            An abort operation will not flush pending writes and will issue a TCP ABORT
            command to the O/S kernel which should result in a TCP_RST packet being sent
            to the peer. The sender of this command and the registered handler for
            incoming data will both be notified once the socket is closed using a
            <see cref="T:Akka.IO.Tcp.Aborted" /> message.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.NoAck">
            <summary>
            Each <see cref="T:Akka.IO.Tcp.WriteCommand" /> can optionally request a positive acknowledgment to be sent
            to the commanding actor. If such notification is not desired the <see cref="!:WriteCommand#ack" />
            must be set to an instance of this class. The token contained within can be used
            to recognize which write failed when receiving a <see cref="T:Akka.IO.Tcp.CommandFailed" /> message.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Write">
            <summary>
            Write data to the TCP connection. If no ack is needed use the special
            `NoAck` object. The connection actor will reply with a <see cref="T:Akka.IO.Tcp.CommandFailed" />
            message if the write could not be enqueued. If <see cref="!:WriteCommand#wantsAck" />
            returns true, the connection actor will reply with the supplied <see cref="!:WriteCommand#ack" />
            token once the write has been successfully enqueued to the O/S kernel.
            <b>Note that this does not in any way guarantee that the data will be
            or have been sent!</b> Unfortunately there is no way to determine whether
            a particular write has been sent by the O/S.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.WriteFile">
            <summary>
            Write `count` bytes starting at `position` from file at `filePath` to the connection.
            The count must be &gt; 0. The connection actor will reply with a <see cref="T:Akka.IO.Tcp.CommandFailed"/>
            message if the write could not be enqueued. If <see cref="P:Akka.IO.Tcp.SimpleWriteCommand.WantsAck"/>
            returns true, the connection actor will reply with the supplied <see cref="P:Akka.IO.Tcp.SimpleWriteCommand.Ack"/>
            token once the write has been successfully enqueued to the O/S kernel.
            <b>Note that this does not in any way guarantee that the data will be
            or have been sent!</b> Unfortunately there is no way to determine whether
            a particular write has been sent by the O/S.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.CompoundWrite">
            <summary>
            A write command which aggregates two other write commands. Using this construct
            you can chain a number of <see cref="T:Akka.IO.Tcp.Write" /> and/or <see cref="T:Akka.IO.Tcp.WriteFile" /> commands together in a way
            that allows them to be handled as a single write which gets written out to the
            network as quickly as possible.
            If the sub commands contain `ack` requests they will be honored as soon as the
            respective write has been written completely.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ResumeWriting">
            <summary>
            When `useResumeWriting` is in effect as was indicated in the <see cref="T:Akka.IO.Tcp.Register" /> message
            then this command needs to be sent to the connection actor in order to re-enable
            writing after a <see cref="T:Akka.IO.Tcp.CommandFailed" /> event. All <see cref="T:Akka.IO.Tcp.WriteCommand" /> processed by the
            connection actor between the first <see cref="T:Akka.IO.Tcp.CommandFailed" /> and subsequent reception of
            this message will also be rejected with <see cref="T:Akka.IO.Tcp.CommandFailed" />.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.SuspendReading">
            <summary>
            Sending this command to the connection actor will disable reading from the TCP
            socket. TCP flow-control will then propagate backpressure to the sender side
            as buffers fill up on either end. To re-enable reading send <see cref="T:Akka.IO.Tcp.ResumeReading" />.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ResumeReading">
            <summary>
            This command needs to be sent to the connection actor after a <see cref="T:Akka.IO.Tcp.SuspendReading" />
            command in order to resume reading from the socket.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ResumeAccepting">
            <summary>
            This message enables the accepting of the next connection if read throttling is enabled
            for connection actors.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Event">
            <summary>
            Common interface for all events generated by the TCP layer actors.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Received">
            <summary>
            Whenever data are read from a socket they will be transferred within this
            class to the handler actor which was designated in the <see cref="T:Akka.IO.Tcp.Register" /> message.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Connected">
            <summary>
            The connection actor sends this message either to the sender of a <see cref="T:Akka.IO.Tcp.Connect" />
            command (for outbound) or to the handler for incoming connections designated
            in the <see cref="T:Akka.IO.Tcp.Bind" /> message. The connection is characterized by the `remoteAddress`
            and `localAddress` TCP endpoints.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.CommandFailed">
            <summary>
            Whenever a command cannot be completed, the queried actor will reply with
            this message, wrapping the original command which failed.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.WritingResumed">
            <summary>
            When `useResumeWriting` is in effect as indicated in the <see cref="T:Akka.IO.Tcp.Register" /> message,
            the <see cref="T:Akka.IO.Tcp.ResumeWriting" /> command will be acknowledged by this message type, upon
            which it is safe to send at least one write. This means that all writes preceding
            the first <see cref="T:Akka.IO.Tcp.CommandFailed" /> message have been enqueued to the O/S kernel at this
            point.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Bound">
            <summary>
            The sender of a <see cref="T:Akka.IO.Tcp.Bind" /> command will—in case of success—receive confirmation
            in this form. If the bind address indicated a 0 port number, then the contained
            `localAddress` can be used to find out which port was automatically assigned.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Unbound">
            <summary>
            The sender of an <see cref="T:Akka.IO.Tcp.Unbind" /> command will receive confirmation through this
            message once the listening socket has been closed.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ConnectionClosed">
            <summary>
            This is the common interface for all events which indicate that a connection
            has been closed or half-closed.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Closed">
            <summary>
            The connection has been closed normally in response to a <see cref="T:Akka.IO.Tcp.Close" /> command.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Aborted">
            <summary>
            The connection has been aborted in response to an <see cref="T:Akka.IO.Tcp.Abort" /> command.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ConfirmedClosed">
            <summary>
            The connection has been half-closed by us and then half-close by the peer
            in response to a <see cref="T:Akka.IO.Tcp.ConfirmedClose" /> command.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.PeerClosed">
            <summary>
            The peer has closed its writing half of the connection.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ErrorClosed">
            <summary>
            The connection has been closed due to an IO error.
            </summary>
        </member>
        <member name="T:Akka.IO.TcpConnection">
              Base class for TcpIncomingConnection and TcpOutgoingConnection.
            
              INTERNAL API
        </member>
        <member name="M:Akka.IO.TcpConnection.WaitingForRegistration(Akka.IO.ChannelRegistration,Akka.Actor.IActorRef)">
            connection established, waiting for registration from user handler 
        </member>
        <member name="M:Akka.IO.TcpConnection.Connected(Akka.IO.TcpConnection.ConnectionInfo)">
            normal connected state 
        </member>
        <member name="M:Akka.IO.TcpConnection.PeerSentEOF(Akka.IO.TcpConnection.ConnectionInfo)">
            the peer sent EOF first, but we may still want to send 
        </member>
        <member name="M:Akka.IO.TcpConnection.ClosingWithPendingWrite(Akka.IO.TcpConnection.ConnectionInfo,Akka.Actor.IActorRef,Akka.IO.Tcp.ConnectionClosed)">
            connection is closing but a write has to be finished first 
        </member>
        <member name="M:Akka.IO.TcpConnection.Closing(Akka.IO.TcpConnection.ConnectionInfo,Akka.Actor.IActorRef)">
            connection is closed on our side and we're waiting from confirmation from the other side 
        </member>
        <member name="M:Akka.IO.TcpConnection.CompleteConnect(Akka.IO.ChannelRegistration,Akka.Actor.IActorRef,System.Collections.Generic.IEnumerable{Akka.IO.Inet.SocketOption})">
            used in subclasses to start the common machinery above once a channel is connected 
        </member>
        <member name="T:Akka.IO.TcpConnection.CloseInformation">
            Used to transport information to the postStop method to notify
            interested party about a connection close.
        </member>
        <member name="T:Akka.IO.TcpConnection.ConnectionInfo">
            Groups required connection-related data that are only available once the connection has been fully established.
        </member>
        <member name="T:Akka.IO.TcpIncomingConnection">
             An actor handling the connection state machine for an incoming, already connected
             SocketChannel.
            
             INTERNAL API
        </member>
        <member name="T:Akka.IO.TcpManager">
             TODO: CLRify comment
             
             INTERNAL API
            
             TcpManager is a facade for accepting commands (<see cref="T:Akka.IO.Tcp.Command"/>) to open client or server TCP connections.
            
             TcpManager is obtainable by calling {{{ IO(Tcp) }}} (see [[akka.io.IO]] and [[akka.io.Tcp]])
            
             == Bind ==
            
             To bind and listen to a local address, a <see cref="T:Akka.IO.Tcp.Bind"/> command must be sent to this actor. If the binding
             was successful, the sender of the <see cref="T:Akka.IO.Tcp.Bind"/> will be notified with a <see cref="T:Akka.IO.Tcp.Bound"/>
             message. The sender() of the <see cref="T:Akka.IO.Tcp.Bound"/> message is the Listener actor (an internal actor responsible for
             listening to server events). To unbind the port an <see cref="T:Akka.IO.Tcp.Unbind"/> message must be sent to the Listener actor.
            
             If the bind request is rejected because the Tcp system is not able to register more channels (see the nr-of-selectors
             and max-channels configuration options in the akka.io.tcp section of the configuration) the sender will be notified
             with a <see cref="T:Akka.IO.Tcp.CommandFailed"/> message. This message contains the original command for reference.
            
             When an inbound TCP connection is established, the handler will be notified by a <see cref="T:Akka.IO.Tcp.Connected"/> message.
             The sender of this message is the Connection actor (an internal actor representing the TCP connection). At this point
             the procedure is the same as for outbound connections (see section below).
            
             == Connect ==
            
             To initiate a connection to a remote server, a <see cref="T:Akka.IO.Tcp.Connect"/> message must be sent to this actor. If the
             connection succeeds, the sender() will be notified with a <see cref="T:Akka.IO.Tcp.Connected"/> message. The sender of the
             <see cref="T:Akka.IO.Tcp.Connected"/> message is the Connection actor (an internal actor representing the TCP connection). Before
             starting to use the connection, a handler must be registered to the Connection actor by sending a <see cref="T:Akka.IO.Tcp.Register"/>
             command message. After a handler has been registered, all incoming data will be sent to the handler in the form of
             <see cref="T:Akka.IO.Tcp.Received"/> messages. To write data to the connection, a <see cref="T:Akka.IO.Tcp.Write"/> message must be sent
             to the Connection actor.
            
             If the connect request is rejected because the Tcp system is not able to register more channels (see the nr-of-selectors
             and max-channels configuration options in the akka.io.tcp section of the configuration) the sender will be notified
             with a <see cref="T:Akka.IO.Tcp.CommandFailed"/> message. This message contains the original command for reference.
            
        </member>
        <member name="T:Akka.IO.ByteString">
            <summary>
            A rope-like immutable data structure containing bytes.
            The goal of this structure is to reduce copying of arrays
            when concatenating and slicing sequences of bytes,
            and also providing a thread safe way of working with bytes.
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.FromArray(System.Byte[])">
            <summary>
            Creates a new ByteString by copying a byte array.
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.FromArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a new ByteString by copying length bytes starting at offset from
            an Array.
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.FromString(System.String)">
            <summary>
            Creates a new ByteString which will contain the UTF-8 representation of the given String
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.FromString(System.String,System.Text.Encoding)">
            <summary>
            Creates a new ByteString which will contain the representation of the given String in the given charset
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingRouter">
            <summary>
            Static class for assisting with <see cref="T:Akka.Routing.ConsistentHashMapping"/> instances
            </summary>
        </member>
        <member name="F:Akka.Routing.ConsistentHashingRouter.EmptyConsistentHashMapping">
            <summary>
            Default empty <see cref="T:Akka.Routing.ConsistentHashMapping"/> implementation
            </summary>
        </member>
        <member name="T:Akka.Routing.IConsistentHashable">
            <summary>
            This interface marks a given class as consistently hashable, for use with
            <see cref="T:Akka.Routing.ConsistentHashingGroup"/> or <see cref="T:Akka.Routing.ConsistentHashingPool"/>
            routers.
            </summary>
        </member>
        <member name="P:Akka.Routing.IConsistentHashable.ConsistentHashKey">
            <summary>
            The consistent hash key of the marked class.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashableEnvelope">
            <summary>
            This class represents a <see cref="T:Akka.Routing.RouterEnvelope"/> that can be wrapped around a message in order to make
            it hashable for use with <see cref="T:Akka.Routing.ConsistentHashingGroup"/> or <see cref="T:Akka.Routing.ConsistentHashingPool"/> routers.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashableEnvelope.#ctor(System.Object,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashableEnvelope"/> class.
            </summary>
            <param name="message">The message that is being wrapped in the envelope.</param>
            <param name="hashKey">The key used as the consistent hash key for the envelope.</param>
        </member>
        <member name="P:Akka.Routing.ConsistentHashableEnvelope.HashKey">
            <summary>
            The key used as the consistent hash key.
            
            <remarks>
            This is the same as the <see cref="P:Akka.Routing.ConsistentHashableEnvelope.ConsistentHashKey"/>
            </remarks>
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashableEnvelope.ConsistentHashKey">
            <summary>
            The consistent hash key of the envelope.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashMapping">
            <summary>
            Delegate for computing the hashkey from any given type of message. Extracts the property / data
            that is going to be used for a given hash, but doesn't actually return the hash values themselves.
            
            If returning a byte[] or string it will be used as is, otherwise the configured
            <see cref="T:Akka.Serialization.Serializer"/> will be applied to the returned data.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingRoutingLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to a <see cref="T:Akka.Routing.Routee"/>
            determined using consistent-hashing. This process has the router select a routee based on a message's
            consistent hash key. There are 3 ways to define the key, which can be used individually or combined
            to form the key. The <see cref="T:Akka.Routing.ConsistentHashMapping"/> is tried first.
            
            <ol>
            <li>
            You can define a <see cref="T:Akka.Routing.ConsistentHashMapping"/> or use <see cref="M:Akka.Routing.ConsistentHashingRoutingLogic.WithHashMapping(Akka.Routing.ConsistentHashMapping)"/>
            of the router to map incoming messages to their consistent hash key.
            This makes the decision transparent for the sender.
            </li>
            <li>
            Messages may implement <see cref="T:Akka.Routing.IConsistentHashable"/>. The hash key is part
            of the message and it's convenient to define it together with the message
            definition.
            </li>
            <li>
            The message can be wrapped in a <see cref="T:Akka.Routing.ConsistentHashableEnvelope"/> to
            define what data to use for the consistent hash key. The sender knows what key
            to use.
            </li>
            </ol>
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingRoutingLogic.#ctor(Akka.Actor.ActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/> class.
            
            <note>
            A <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/> configured in this way uses the
            <see cref="F:Akka.Routing.ConsistentHashingRouter.EmptyConsistentHashMapping"/> as the hash
            mapping function with a virtual node factor of 0 (zero).
            </note>
            </summary>
            <param name="system">The actor system that owns the router with this logic.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingRoutingLogic.#ctor(Akka.Actor.ActorSystem,System.Int32,Akka.Routing.ConsistentHashMapping)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/> class.
            </summary>
            <param name="system">The actor system that owns the router with this logic.</param>
            <param name="virtualNodesFactor">The number of virtual nodes to use on the hash ring.</param>
            <param name="hashMapping">The consistent hash mapping function to use on incoming messages.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks a <see cref="T:Akka.Routing.Routee" /> to receive the <paramref name="message" />.
            </summary>
            <param name="message">The message that is being routed</param>
            <param name="routees">A collection of routees to choose from when receiving the <paramref name="message" />.</param>
            <returns>A <see cref="T:Akka.Routing.Routee" /> that receives the <paramref name="message" />.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingRoutingLogic.WithHashMapping(Akka.Routing.ConsistentHashMapping)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/> router logic with a given <see cref="T:Akka.Routing.ConsistentHashMapping"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="mapping">The <see cref="T:Akka.Routing.ConsistentHashMapping"/> used to configure the new router.</param>
            <returns>A new router logic with the provided <paramref name="mapping"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The mapping can not be null.</exception>
        </member>
        <member name="T:Akka.Routing.ConsistentRoutee">
            <summary>
            INTERNAL API
            
            Important to use ActorRef with full address, with host and port, in the hash ring,
            so that same ring is produced on different nodes.
            The ConsistentHash uses toString of the ring nodes, and the ActorRef itself
            isn't a good representation, because LocalActorRef doesn't include the
            host and port.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingGroup">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Group"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using consistent-hashing.
            Please refer to <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/> for more information on consistent hashing.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingGroup.ConsistentHashingGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.ConsistentHashingGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.ConsistentHashingGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.ConsistentHashingGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.ConsistentHashingGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingGroup.ConsistentHashingGroupSurrogate.Paths">
            <summary>
            The actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingGroup.VirtualNodesFactor">
            <summary>
            Virtual nodes used in the <see cref="T:Akka.Routing.ConsistentHash`1"/>.
            </summary>
        </member>
        <member name="F:Akka.Routing.ConsistentHashingGroup.HashMapping">
            <summary>
            The consistent hash mapping function to use on incoming messages.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingGroup"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            
            <note>
            If 'routees.path' is defined in the provided configuration then those paths will be used by the router.
            'virtual-nodes-factor' defaults to 0 (zero) if it is not defined in the provided configuration.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingGroup"/> class.
            </summary>
            <param name="paths">A list of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Int32,Akka.Routing.ConsistentHashMapping)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingGroup"/> class.
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
            <param name="virtualNodesFactor">The number of virtual nodes to use on the hash ring.</param>
            <param name="hashMapping">The consistent hash mapping function to use on incoming messages.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.#ctor(System.Collections.Generic.IEnumerable{Akka.Actor.IActorRef},System.Int32,Akka.Routing.ConsistentHashMapping)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingGroup"/> class.
            </summary>
            <param name="routees">An enumeration of routees used by the group router.</param>
            <param name="virtualNodesFactor">The number of virtual nodes to use on the hash ring.</param>
            <param name="hashMapping">The consistent hash mapping function to use on incoming messages.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.WithVirtualNodesFactor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingGroup" /> router with a given <see cref="P:Akka.Routing.ConsistentHashingGroup.VirtualNodesFactor"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="vnodes">The <see cref="P:Akka.Routing.ConsistentHashingGroup.VirtualNodesFactor"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="vnodes" />.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.WithHashMapping(Akka.Routing.ConsistentHashMapping)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingGroup"/> router with a given <see cref="T:Akka.Routing.ConsistentHashMapping"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="mapping">The <see cref="T:Akka.Routing.ConsistentHashMapping"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="mapping"/>.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingGroup" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
            <exception cref="T:System.ArgumentException">Expected ConsistentHashingGroup, got <paramref name="routerConfig"/>.</exception>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.ConsistentHashingGroup"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.ConsistentHashingGroup"/>.</returns>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using consistent-hashing.
            Please refer to <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/> for more information on consistent hashing.
            
            <note>
            Using <see cref="T:Akka.Routing.Resizer"/> with <see cref="T:Akka.Routing.ConsistentHashingPool"/> is potentially harmful, as hash ranges
            might change radically during live message processing. This router works best with fixed-sized pools or fixed
            number of routees per node in the event of clustered deployments.
            </note>
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.VirtualNodesFactor">
            <summary>
            Virtual nodes used in the <see cref="T:Akka.Routing.ConsistentHash`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingPool"/> class.
            
            <note>
            'virtual-nodes-factor' defaults to 0 (zero) if it is not defined in the provided configuration.
            </note>
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean,System.Int32,Akka.Routing.ConsistentHashMapping)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
            <param name="virtualNodesFactor">The number of virtual nodes to use on the hash ring.</param>
            <param name="hashMapping">The consistent hash mapping function to use on incoming messages.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithVirtualNodesFactor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingPool" /> router with a given <see cref="P:Akka.Routing.ConsistentHashingPool.VirtualNodesFactor"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="vnodes">The <see cref="P:Akka.Routing.ConsistentHashingPool.VirtualNodesFactor"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="vnodes" />.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithHashMapping(Akka.Routing.ConsistentHashMapping)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingPool"/> router with a given <see cref="T:Akka.Routing.ConsistentHashMapping"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="mapping">The <see cref="T:Akka.Routing.ConsistentHashMapping"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="mapping"/>.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingPool"/> class.
            
            <note>
            A <see cref="T:Akka.Routing.ConsistentHashingPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingPool" /> router with a given <see cref="T:Akka.Actor.SupervisorStrategy" />.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy" />.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingPool" /> router with a given <see cref="T:Akka.Routing.Resizer" />.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            
            <note>
            Using <see cref="T:Akka.Routing.Resizer"/> with <see cref="T:Akka.Routing.ConsistentHashingPool"/> is potentially harmful, as hash ranges
            might change radically during live message processing. This router works best with fixed-sized pools or fixed
            number of routees per node in the event of clustered deployments.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer" />.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingPool" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
            <exception cref="T:System.ArgumentException">routerConfig</exception>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.ConsistentHashingPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.ConsistentHashingPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.ConsistentHashingPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.ConsistentHashingPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.ConsistentHashingPool"/>.</returns>
        </member>
        <member name="T:Akka.Routing.SmallestMailboxRoutingLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to a <see cref="T:Akka.Routing.Routee"/>
            determined using smallest-mailbox. This process has the router select a routee based on the fewest number
            of messages in its routees' mailbox. The selection is done in the following order:
            
            <ul>
            <li>Pick any routee with an empty mailbox.</li>
            <li>Pick a routee with the fewest pending messages in its mailbox.</li>
            <li>Pick any remaining routees.</li>
            </ul>
            <note>
            Remote routees are consider lowest priority, since their mailbox size is unknown.
            </note>
            <note>
            For the case, when all routees are of unpredictable size, the selection process fails back to round-robin.
            </note>
            </summary>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxRoutingLogic.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.SmallestMailboxRoutingLogic"/> class.
            </summary>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxRoutingLogic.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.SmallestMailboxRoutingLogic"/> class.
            </summary>
            <param name="next">Seed value used in the fallback selection process.</param>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks a <see cref="T:Akka.Routing.Routee" /> to receive the <paramref name="message" />.
            </summary>
            <param name="message">The message that is being routed</param>
            <param name="routees">A collection of routees to choose from when receiving the <paramref name="message" />.</param>
            <returns>A <see cref="T:Akka.Routing.Routee" /> that receives the <paramref name="message" />.</returns>
        </member>
        <member name="T:Akka.Routing.SmallestMailboxPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using smallest-mailbox.
            Please refer to <see cref="T:Akka.Routing.SmallestMailboxRoutingLogic"/> for more information on the selection process.
            </summary>
        </member>
        <member name="T:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.SmallestMailboxPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.SmallestMailboxPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.SmallestMailboxPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.SmallestMailboxPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.SmallestMailboxPool"/>.</returns>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.SmallestMailboxPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.SmallestMailboxPool"/> class.
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.SmallestMailboxPool"/> class.
            
            <note>
            A <see cref="T:Akka.Routing.SmallestMailboxPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.SmallestMailboxPool" /> router with a given <see cref="T:Akka.Actor.SupervisorStrategy" />.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy" />.</returns>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.SmallestMailboxPool" /> router with a given <see cref="T:Akka.Routing.Resizer" />.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer" />.</returns>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.SmallestMailboxPool" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information. </returns>
        </member>
        <member name="T:Akka.Routing.TailChoppingRoutingLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to a <see cref="T:Akka.Routing.Routee"/> determined using tail-chopping.
            This process has the router select a random routee, then waits an interval before sending to a different randomly chosen routee.
            The first response is used and the remaining are discarded. If the none of the routees respond within a specified time limit,
            a timeout failure occurs.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingRoutingLogic.#ctor(System.TimeSpan,System.TimeSpan,Akka.Actor.IScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingRoutingLogic"/> class.
            </summary>
            <param name="within">The time within which at least one response is expected.</param>
            <param name="interval">The duration after which the next routee will be picked.</param>
            <param name="scheduler">The <see cref="T:Akka.Actor.IScheduler"/> used to force deadlines.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks all of the provided <paramref name="routees"/> to receive the <paramref name="message" />.
            </summary>
            <param name="message">The message that is being routed</param>
            <param name="routees">A collection of routees used when receiving the <paramref name="message" />.</param>
            <returns>A <see cref="T:Akka.Routing.TailChoppingRoutee" /> that receives the <paramref name="message" />.</returns>
        </member>
        <member name="T:Akka.Routing.TailChoppingRoutee">
            <summary>
            This class represents a single point <see cref="T:Akka.Routing.Routee"/> that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using tail-chopping.
            This process has the routee select a random routee, then waits an interval before sending to a different randomly chosen routee.
            The first response is used and the remaining are discarded. If the none of the routees respond within a specified time limit,
            a timeout failure occurs.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingRoutee.#ctor(Akka.Routing.Routee[],System.TimeSpan,System.TimeSpan,Akka.Actor.IScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingRoutee"/> class.
            </summary>
            <param name="routees">The list of routees that the router uses to send messages.</param>
            <param name="within">The time within which at least one response is expected.</param>
            <param name="interval">The duration after which the next routee will be picked.</param>
            <param name="scheduler">The <see cref="T:Akka.Actor.IScheduler"/> used to force deadlines.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingRoutee.Send(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Sends a message to the collection of routees.
            </summary>
            <param name="message">The message that is being sent.</param>
            <param name="sender">The actor sending the message.</param>
        </member>
        <member name="T:Akka.Routing.TailChoppingPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using tail-chopping.
            This process has the router select a random routee, then waits an interval before sending to a different randomly chosen routee.
            The first response is used and the remaining are discarded. If the none of the routees respond within a specified time limit,
            a timeout failure occurs.
            </summary>
        </member>
        <member name="T:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.TailChoppingPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.TailChoppingPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.TailChoppingPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.Interval">
            The interval to wait before sending to the next routee.
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.Within">
            The amount of time to wait for a response.
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.TailChoppingPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.TailChoppingPool"/>.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.TimeSpan,System.TimeSpan,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="interval">The interval to wait before sending to the next routee.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingPool"/> class.
            
            <note>
            'nr-of-instances', 'within', and 'tail-chopping-router.interval'
            must be defined in the provided configuration.
            </note>
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.#ctor(System.Int32,System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="interval">The interval to wait before sending to the next routee.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.TailChoppingPool"/> router with a given <see cref="T:Akka.Actor.SupervisorStrategy"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy"/>.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.TailChoppingPool"/> router with a given <see cref="T:Akka.Routing.Resizer"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer"/>.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.TailChoppingPool"/> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="T:Akka.Routing.TailChoppingGroup">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Group"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using tail-chopping.
            This process has the router select a random routee, then waits an interval before sending to a different randomly chosen routee.
            The first response is used and the remaining are discarded. If the none of the routees respond within a specified time limit,
            a timeout failure occurs.
            </summary>
        </member>
        <member name="T:Akka.Routing.TailChoppingGroup.TailChoppingGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.TailChoppingGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.TailChoppingGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.TailChoppingGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.TailChoppingGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.TailChoppingGroup.TailChoppingGroupSurrogate.Within">
            The amount of time to wait for a response.
        </member>
        <member name="P:Akka.Routing.TailChoppingGroup.TailChoppingGroupSurrogate.Paths">
            The actor paths used by this router during routee selection.
        </member>
        <member name="P:Akka.Routing.TailChoppingGroup.TailChoppingGroupSurrogate.Interval">
            The interval to wait before sending to the next routee.
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.TailChoppingGroup"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.TailChoppingGroup"/>.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingGroup"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            
            <note>
            If 'routees.path' is defined in the provided configuration then those paths will be used by the router.
            If 'within' is defined in the provided configuration then that will be used as the timeout.
            If 'tail-chopping-router.interval' is defined in the provided configuration then that will be used as the interval.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.#ctor(System.String[],System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingGroup"/> class.
            </summary>
            <param name="routeePaths">The actor paths used by this router during routee selection.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="interval">The interval to wait before sending to the next routee.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.TailChoppingGroup" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="T:Akka.Routing.BroadcastRoutingLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to multiple <see cref="T:Akka.Routing.Routee">routees</see>.
            </summary>
        </member>
        <member name="M:Akka.Routing.BroadcastRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks all the <see cref="T:Akka.Routing.Routee">routees</see> in <paramref name="routees"/> to receive the <paramref name="message"/>.
            </summary>
            <param name="message">The message that is being routed.</param>
            <param name="routees">A collection of routees that receives the <paramref name="message"/>.</param>
            <returns>A <see cref="T:Akka.Routing.Routee"/> that contains all the given <paramref name="routees"/> that receives the <paramref name="message"/>.</returns>
        </member>
        <member name="T:Akka.Routing.BroadcastPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages it receives to all of its <see cref="T:Akka.Routing.Routee">routees</see>.
            </summary>
        </member>
        <member name="T:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.BroadcastPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.BroadcastPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.BroadcastPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.BroadcastPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.BroadcastPool"/>.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastPool"/> class.
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastPool"/> class.
            
            <note>
            A <see cref="T:Akka.Routing.BroadcastPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.BroadcastPool"/> router with a given <see cref="T:Akka.Actor.SupervisorStrategy"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy" />.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.BroadcastPool"/> router with a given <see cref="T:Akka.Routing.Resizer"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer" />.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.BroadcastPool"/> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="T:Akka.Routing.BroadcastGroup">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Group"/> router that sends messages it receives to all of its routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.BroadcastGroup.BroadcastGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.BroadcastGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.BroadcastGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.BroadcastGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.BroadcastGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.BroadcastGroup.BroadcastGroupSurrogate.Paths">
            <summary>
            The actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.BroadcastGroup"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.BroadcastGroup"/>.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastGroup"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            
            <note>
            If 'routees.path' is defined in the provided configuration then those paths will be used by the router.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastGroup"/> class.
            </summary>
            <param name="paths">A list of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastGroup"/> class.
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(System.Collections.Generic.IEnumerable{Akka.Actor.IActorRef})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastGroup"/> class.
            </summary>
            <param name="routees">An enumeration of routees used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.BroadcastGroup" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="T:Akka.Routing.ConsistentHash`1">
            <summary>
            Consistent Hashing node ring implementation.
            
             A good explanation of Consistent Hashing:
            http://weblogs.java.net/blog/tomwhite/archive/2007/11/consistent_hash.html
            
            Note that toString of the ring nodes are used for the node
            hash, i.e. make sure it is different for different nodes.
            </summary>
        </member>
        <member name="F:Akka.Routing.ConsistentHash`1._ring">
            <summary>
            arrays for fast binary search access
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHash`1.NodeHashRing">
            <summary>
            Sorted hash values of the nodes
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHash`1.NodeRing">
            <summary>
            NodeRing is the nodes sorted in the same order as <see cref="P:Akka.Routing.ConsistentHash`1.NodeHashRing"/>, i.e. same index
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.Add(`0)">
            <summary>
            Add a node to the hash ring.
            
            Note that <see cref="T:Akka.Routing.ConsistentHash`1"/> is immutable and
            this operation returns a new instance.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.Remove(`0)">
            <summary>
            Removes a node from the hash ring.
            
            Note that <see cref="T:Akka.Routing.ConsistentHash`1"/> is immutable and
            this operation returns a new instance.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.Idx(System.Int32)">
            <summary>
            Converts the result of <see cref="M:System.Array.BinarySearch``1(``0[],``0)"/> into an index in the 
            <see cref="P:Akka.Routing.ConsistentHash`1.RingTuple"/> array.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.NodeFor(System.Byte[])">
            <summary>
            Get the node responsible for the data key.
            Can only be used if nodes exist in the node ring.
            Otherwise throws <see cref="T:System.ArgumentException"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.NodeFor(System.String)">
            <summary>
            Get the node responsible for the data key.
            Can only be used if nodes exist in the node ring.
            Otherwise throws <see cref="T:System.ArgumentException"/>.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHash`1.IsEmpty">
            <summary>
            Is the node ring empty? i.e. no nodes added or all removed
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.op_Addition(Akka.Routing.ConsistentHash{`0},`0)">
            <summary>
            Add a node to the hash ring.
            
            Note that <see cref="T:Akka.Routing.ConsistentHash`1"/> is immutable and
            this operation returns a new instance.
            </summary>s
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.op_Subtraction(Akka.Routing.ConsistentHash{`0},`0)">
            <summary>
            Removes a node from the hash ring.
            
            Note that <see cref="T:Akka.Routing.ConsistentHash`1"/> is immutable and
            this operation returns a new instance.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHash">
            <summary>
            Static helper class for creating <see cref="T:Akka.Routing.ConsistentHash`1"/> instances.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash.Create``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Factory method to create a <see cref="T:Akka.Routing.ConsistentHash`1"/> instance.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash.ToBytesOrObject(System.Object)">
            <summary>
            Translate the offered object into a byte array, or returns the original object
            if it needs to be serialized first.
            </summary>
            <param name="obj">An arbitrary .NET object</param>
            <returns>The object encoded into bytes - in the case of custom classes, the hashcode may be used.</returns>
        </member>
        <member name="T:Akka.Routing.IListeners">
            <summary>
            This interface is needed to implement listening capabilities on an actor.
            
            <remarks>
            <ul>
            <li>Use the <see cref="M:Akka.Routing.ListenerSupport.Gossip(System.Object)"/> method to send a message to the listeners.</li>
            <li>Send <code>Listen(Self)</code> to another Actor to start listening.</li>
            <li>Send <code>Deafen(Self)</code> to another Actor to stop listening.</li>
            <li>Send <code>WithListeners(delegate)</code> to traverse the current listeners.</li>
            </ul>
            </remarks>
            </summary>
        </member>
        <member name="P:Akka.Routing.IListeners.Listeners">
            <summary>
            Retrieves the support needed to interact with an actor's listeners.
            </summary>
        </member>
        <member name="T:Akka.Routing.ListenerMessage">
            <summary>
            This class represents a message sent by an actor to another actor that is listening to it.
            </summary>
        </member>
        <member name="T:Akka.Routing.Listen">
            <summary>
            The class represents a <see cref="T:Akka.Routing.ListenerMessage"/> sent by an <see cref="T:Akka.Actor.IActorRef"/> to another <see cref="T:Akka.Actor.IActorRef"/>
            instructing the second actor to start listening for messages sent by the first actor.
            </summary>
        </member>
        <member name="M:Akka.Routing.Listen.#ctor(Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.Listen"/> class.
            </summary>
            <param name="listener">The actor that receives the message.</param>
        </member>
        <member name="P:Akka.Routing.Listen.Listener">
            <summary>
            The actor that receives the message.
            </summary>
        </member>
        <member name="T:Akka.Routing.Deafen">
            <summary>
            The class represents a <see cref="T:Akka.Routing.ListenerMessage"/> sent by an <see cref="T:Akka.Actor.IActorRef"/> to another <see cref="T:Akka.Actor.IActorRef"/>
            instructing the second actor to stop listening for messages sent by the first actor.
            </summary>
        </member>
        <member name="M:Akka.Routing.Deafen.#ctor(Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.Deafen"/> class.
            </summary>
            <param name="listener">The actor that no longer receives the message.</param>
        </member>
        <member name="P:Akka.Routing.Deafen.Listener">
            <summary>
            The actor that no longer receives the message.
            </summary>
        </member>
        <member name="T:Akka.Routing.WithListeners">
            <summary>
            This class represents a <see cref="T:Akka.Routing.ListenerMessage"/> instructing an <see cref="T:Akka.Actor.IActorRef"/>
            to perform a supplied <see cref="T:System.Action`1"/> for all of its listeners.
            </summary>
        </member>
        <member name="M:Akka.Routing.WithListeners.#ctor(System.Action{Akka.Actor.IActorRef})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.WithListeners"/> class.
            </summary>
            <param name="listenerFunction">The action to perform for all of an actor's listeners.</param>
        </member>
        <member name="P:Akka.Routing.WithListeners.ListenerFunction">
            <summary>
            The action to perform for all of an actor's listeners.
            </summary>
        </member>
        <member name="T:Akka.Routing.ListenerSupport">
            <summary>
            This class adds <see cref="T:Akka.Routing.IListeners"/> capabilities to an actor.
            
            <note>
            <see cref="P:Akka.Routing.ListenerSupport.ListenerReceive"/> must be wired manually into the actor's
            <see cref="M:Akka.Actor.UntypedActor.OnReceive(System.Object)"/> method.
            </note>
            </summary>
        </member>
        <member name="F:Akka.Routing.ListenerSupport.Listeners">
            <summary>
            The collection of registered listeners that is listening for messages from an actor.
            </summary>
        </member>
        <member name="P:Akka.Routing.ListenerSupport.ListenerReceive">
            <summary>
            Retrieves the wiring needed to implement listening functionality.
            
            <note>
            This needs to be chained into the actor's <see cref="M:Akka.Actor.UntypedActor.OnReceive(System.Object)"/> method.
            </note>
            </summary>
        </member>
        <member name="M:Akka.Routing.ListenerSupport.Add(Akka.Actor.IActorRef)">
            <summary>
            Adds the specified actor to the collection of registered listeners.
            </summary>
            <param name="actor">The actor to add to the collection of registered listeners.</param>
        </member>
        <member name="M:Akka.Routing.ListenerSupport.Remove(Akka.Actor.IActorRef)">
            <summary>
            Removes the specified actor from the collection of registered listeners.
            </summary>
            <param name="actor">The actor to remove from the collection of registered listeners.</param>
        </member>
        <member name="M:Akka.Routing.ListenerSupport.Gossip(System.Object)">
            <summary>
            Sends the supplied message to all registered listeners.
            
            <note>
            Messages sent this way use <see cref="F:Akka.Actor.ActorRefs.NoSender"/> as the sender.
            </note>
            </summary>
            <param name="message">The message sent to all registered listeners.</param>
        </member>
        <member name="M:Akka.Routing.ListenerSupport.Gossip(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Sends the supplied message to all registered listeners.
            </summary>
            <param name="message">The message sent to all registered listeners.</param>
            <param name="sender">The actor that sends the message.</param>
        </member>
        <member name="T:Akka.Routing.RandomLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to a random <see cref="T:Akka.Routing.Routee"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.RandomLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks a random <see cref="T:Akka.Routing.Routee"/> to receive the <paramref name="message"/>.
            </summary>
            <param name="message">The message that is being routed.</param>
            <param name="routees">A collection of routees to randomly choose from when receiving the <paramref name="message"/>.</param>
            <returns>A <see cref="T:Akka.Routing.Routee" /> that receives the <paramref name="message"/>.</returns>
        </member>
        <member name="T:Akka.Routing.RandomGroup">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Group"/> router that sends messages to a random <see cref="T:Akka.Routing.Routee"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.RandomGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomGroup"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            
            <note>
            If 'routees.path' is defined in the provided configuration then those paths will be used by the router.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.RandomGroup.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomGroup"/> class.
            </summary>
            <param name="paths">A list of paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.RandomGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomGroup"/> class.
            </summary>
            <param name="paths">An enumeration of paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.RandomGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.RandomGroup"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.RandomGroup"/>.</returns>
        </member>
        <member name="M:Akka.Routing.RandomGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.RandomGroup.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RandomGroup" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="T:Akka.Routing.RandomGroup.RandomGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.RandomGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="P:Akka.Routing.RandomGroup.RandomGroupSurrogate.Paths">
            <summary>
            The actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="M:Akka.Routing.RandomGroup.RandomGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.RandomGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.RandomGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="T:Akka.Routing.RandomPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages to a random <see cref="T:Akka.Routing.Routee"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.RandomPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Akka.Routing.RandomPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomPool"/> class.
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="M:Akka.Routing.RandomPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomPool"/> class.
            
            <note>
            A <see cref="T:Akka.Routing.RandomPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
        </member>
        <member name="M:Akka.Routing.RandomPool.#ctor(System.Int32,Akka.Routing.Resizer)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomPool"/> class.
            
            <note>
            A <see cref="T:Akka.Routing.RandomPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
        </member>
        <member name="M:Akka.Routing.RandomPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.RandomPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.RandomPool"/>.</returns>
        </member>
        <member name="M:Akka.Routing.RandomPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="T:Akka.Routing.RandomPool.RandomPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.RandomPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="P:Akka.Routing.RandomPool.RandomPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.RandomPool.RandomPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.RandomPool.RandomPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.RandomPool.RandomPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.RandomPool.RandomPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="M:Akka.Routing.RandomPool.RandomPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.RandomPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.RandomPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="M:Akka.Routing.RandomPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RandomPool" /> router with a given <see cref="T:Akka.Actor.SupervisorStrategy" />.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy" />.</returns>
        </member>
        <member name="M:Akka.Routing.RandomPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RandomPool" /> router with a given <see cref="T:Akka.Routing.Resizer" />.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer" />.</returns>
        </member>
        <member name="M:Akka.Routing.RandomPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RandomPool" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.RandomPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="T:Akka.Routing.ResizablePoolActor">
            <summary>
            INTERNAL API.
            
            Defines <see cref="T:Akka.Routing.Pool"/> routers who can resize the number of routees
            they use based on a defined <see cref="T:Akka.Routing.Resizer"/>
            </summary>
        </member>
        <member name="T:Akka.Routing.Resize">
            <summary>
            Command used to resize a <see cref="T:Akka.Routing.ResizablePoolActor"/>
            </summary>
        </member>
        <member name="T:Akka.Routing.ResizablePoolCell">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Routing.ResizablePoolCell._resizeInProgress">
            <summary>
            must always use ResizeInProgressState static class to compare or assign values
            </summary>
        </member>
        <member name="T:Akka.Routing.Resizer">
            <summary>
            <see cref="T:Akka.Routing.Pool"/> routers with dynamically resizable number of routees are implemented by providing a Resizer
            implementation in the <see cref="T:Akka.Routing.Pool"/> configuration
            </summary>
        </member>
        <member name="M:Akka.Routing.Resizer.IsTimeForResize(System.Int64)">
            <summary>
            Is it time for resizing. Typically implemented with modulo of nth message, but
            could be based on elapsed time or something else. The messageCounter starts with 0
            for the initial resize and continues with 1 for the first message. Make sure to perform
            initial resize before first message (messageCounter == 0), because there is no guarantee
            that resize will be done when concurrent messages are in play.
            
            CAUTION: this method is invoked from the thread which tries to send a
            message to the pool, i.e. the ActorRef.!() method, hence it may be called
            concurrently.
            </summary>
            <param name="messageCounter"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Routing.Resizer.Resize(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
             <summary>
             Decide if the capacity of the router need to be changed. Will be invoked when `isTimeForResize`
             returns true and no other resize is in progress.
            
             Return the number of routees to add or remove. Negative value will remove that number of routees.
             Positive value will add that number of routess. 0 will not change the routees.
            
             This method is invoked only in the context of the Router actor.
             </summary>
             <param name="currentRoutees"></param>
             <returns></returns>
        </member>
        <member name="T:Akka.Routing.DefaultResizer">
            <summary>
            Implementation of <see cref="T:Akka.Routing.Resizer"/> that adjust the <see cref="T:Akka.Routing.Pool"/> based on specified thresholds.
            </summary>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.#ctor(Akka.Configuration.Config)">
            <summary>
            Creates a new DefaultResizer from the given configuration
            </summary>
            <param name="resizerConfig"></param>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Capacity(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
            <summary>
            Returns the overall desired change in resizer capacity. Positive value will
            add routees to the resizer. Negative value will remove routees from the
            resizer
            </summary>
            <param name="currentRoutees">The current actor in the resizer</param>
            <returns>the number of routees by which the resizer should be adjusted (positive, negative or zero)</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Filter(System.Int32,System.Int32)">
            <summary>
            This method can be used to smooth the capacity delta by considering
            the current pressure and current capacity.
            </summary>
            <param name="pressure">pressure current number of busy routees</param>
            <param name="capacity">capacity current number of routees</param>
            <returns>proposed change in the capacity</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Backoff(System.Int32,System.Int32)">
            <summary>
            Computes a proposed negative (or zero) capacity delta using
            the configured `backoffThreshold` and `backoffRate`
            </summary>
            <param name="pressure">pressure current number of busy routees</param>
            <param name="capacity">capacity current number of routees</param>
            <returns>proposed decrease in capacity (as a negative number)</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Rampup(System.Int32,System.Int32)">
            <summary>
            Computes a proposed positive (or zero) capacity delta using
            the configured `rampupRate`.
            </summary>
            <param name="pressure">the current number of busy routees</param>
            <param name="capacity">the current number of total routees</param>
            <returns>proposed increase in capacity</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Pressure(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
             <summary>
             Number of routees considered busy, or above 'pressure level'.
            
             Implementation depends on the value of `pressureThreshold`
             (default is 1).
             <ul>
             <li> 0:   number of routees currently processing a message.</li>
             <li> 1:   number of routees currently processing a message has
                       some messages in mailbox.</li>
             <li> > 1: number of routees with at least the configured `pressureThreshold`
                       messages in their mailbox. Note that estimating mailbox size of
                       default UnboundedMailbox is O(N) operation.</li>
             </ul>
             </summary>
             <param name="currentRoutees"></param>
             <returns></returns>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.LowerBound">
            <summary>
            The fewest number of routees the router should ever have.
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.UpperBound">
            <summary>
            The most number of routees the router should ever have. 
            Must be greater than or equal to `lowerBound`.
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.PressureThreshold">
            <summary>
            * Threshold to evaluate if routee is considered to be busy (under pressure).
            Implementation depends on this value (default is 1).
            <ul>
            <li> 0:   number of routees currently processing a message.</li>
            <li> 1:   number of routees currently processing a message has
                      some messages in mailbox.</li>
            <li> > 1: number of routees with at least the configured `pressureThreshold`
                      messages in their mailbox. Note that estimating mailbox size of
                      default UnboundedMailbox is O(N) operation.</li>
            </ul>
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.RampupRate">
            <summary>
            Percentage to increase capacity whenever all routees are busy.
            For example, 0.2 would increase 20% (rounded up), i.e. if current
            capacity is 6 it will request an increase of 2 more routees.
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.BackoffThreshold">
             <summary>
             Minimum fraction of busy routees before backing off.
             For example, if this is 0.3, then we'll remove some routees only when
             less than 30% of routees are busy, i.e. if current capacity is 10 and
             3 are busy then the capacity is unchanged, but if 2 or less are busy
             the capacity is decreased.
            
             Use 0.0 or negative to avoid removal of routees.
             </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.BackoffRate">
            <summary>
            Fraction of routees to be removed when the resizer reaches the
            backoffThreshold.
            For example, 0.1 would decrease 10% (rounded up), i.e. if current
            capacity is 9 it will request an decrease of 1 routee.
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.MessagesPerResize">
            <summary>
            Number of messages between resize operation.
            Use 1 to resize before each message.
            </summary>
        </member>
        <member name="T:Akka.Routing.RoundRobinRoutingLogic">
             <summary>
             This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to a <see cref="T:Akka.Routing.Routee"/> determined using round-robin.
             This process has the router select from a list of routees in sequential order. When the list has been exhausted, the router iterates
             again from the beginning of the list.
            
             <note>
             For concurrent calls, round robin is just a best effort.
             </note>
             </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinRoutingLogic.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinRoutingLogic"/> class.
            </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinRoutingLogic.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinRoutingLogic"/> class.
            </summary>
            <param name="next">The index to use when starting the selection process. Note that it will start at (next + 1).</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks the next <see cref="T:Akka.Routing.Routee"/> in the collection to receive the <paramref name="message"/>.
            </summary>
            <param name="message">The message that is being routed.</param>
            <param name="routees">A collection of routees to choose from when receiving the <paramref name="message"/>.</param>
            <returns>A <see cref="T:Akka.Routing.Routee" /> that is receives the <paramref name="message"/>.</returns>
        </member>
        <member name="T:Akka.Routing.RoundRobinGroup">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Group"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using round-robin.
            This process has the router select from a list of routees in sequential order. When the list has been exhausted, the router
            iterates again from the beginning of the list.
            
            <note>
            For concurrent calls, round robin is just a best effort.
            </note>
            
            <note>
            The configuration parameter trumps the constructor arguments. This means that
            if you provide `paths` during instantiation they will be ignored if
            the router is defined in the configuration file for the actor being used.
            </note>
            </summary>
        </member>
        <member name="T:Akka.Routing.RoundRobinGroup.RoundRobinGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.RoundRobinGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.RoundRobinGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.RoundRobinGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.RoundRobinGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.RoundRobinGroup.RoundRobinGroupSurrogate.Paths">
            <summary>
            The actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.RoundRobinGroup"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.RoundRobinGroup"/>.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinGroup"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            
            <note>
            If 'routees.path' is defined in the provided configuration then those paths will be used by the router.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinGroup"/> class.
            </summary>
            <param name="paths">A list of paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinGroup"/> class.
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(System.Collections.Generic.IEnumerable{Akka.Actor.IActorRef})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinGroup"/> class.
            </summary>
            <param name="routees">An enumeration of routees used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RoundRobinGroup"/> router with a given dispatcher id.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="T:Akka.Routing.RoundRobinPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using round-robin.
            This process has the router select from a list of routees in sequential order. When the list has been exhausted, the router
            iterates again from the beginning of the list.
            
            <note>
            For concurrent calls, round robin is just a best effort.
            </note>
            </summary>
        </member>
        <member name="T:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.RoundRobinPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.RoundRobinPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.RoundRobinPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.RoundRobinPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.RoundRobinPool"/>.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinPool"/> class.
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinPool"/> class.
            
            <note>
            A <see cref="T:Akka.Routing.RoundRobinPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.#ctor(System.Int32,Akka.Routing.Resizer)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinPool"/> class.
            
            <note>
            A <see cref="T:Akka.Routing.RoundRobinPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RoundRobinPool"/> router with a given <see cref="T:Akka.Actor.SupervisorStrategy"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy"/>.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RoundRobinPool"/> router with a given <see cref="T:Akka.Routing.Resizer"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer"/>.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RoundRobinPool"/> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="T:Akka.Routing.RoutedActorCell">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.RemoveRoutees(System.Collections.Generic.IList{Akka.Routing.Routee},System.Boolean)">
            <summary>
            Remove routees from <see cref="P:Akka.Routing.RoutedActorCell.Router"/>. Messages in flight may still
            be routed to the old <see cref="P:Akka.Routing.RoutedActorCell.Router"/> instance containing the old routees.
            </summary>
            <param name="affectedRoutees"></param>
            <param name="stopChild"></param>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.StopIfChild(Akka.Routing.Routee)">
            <summary>
            Used to stop child routees - typically used in resizable <see cref="T:Akka.Routing.Pool"/> routers
            </summary>
            <param name="routee"></param>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.PreSuperStart">
            <summary>
            Called when <see cref="P:Akka.Routing.RoutedActorCell.Router"/> is initialized but before the base class' <see cref="M:Akka.Routing.RoutedActorCell.Start"/> to
            be able to do extra initialization in a subclass.
            </summary>
        </member>
        <member name="T:Akka.Routing.RoutingLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route messages to one or more actors.
            These actors are known in the system as a <see cref="T:Akka.Routing.Routee"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.RoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks a <see cref="T:Akka.Routing.Routee"/> to receive the <paramref name="message"/>.
            <note>
            Normally it picks one of the passed routees, but it is up to the implementation
            to return whatever <see cref="T:Akka.Routing.Routee"/> to use for sending a specific message.
            </note>
            </summary>
            <param name="message">The message that is being routed</param>
            <param name="routees">A collection of routees to choose from when receiving the <paramref name="message"/>.</param>
            <returns>A <see cref="T:Akka.Routing.Routee"/> that receives the <paramref name="message"/>.</returns>
        </member>
        <member name="M:Akka.Routing.Router.WithRoutees(Akka.Routing.Routee[])">
            <summary>
            Create a new instance with the specified routees and the same <see cref="P:Akka.Routing.Router.RoutingLogic"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.Router.AddRoutee(Akka.Routing.Routee)">
            <summary>
            Create a new instance with one more routee and the same <see cref="P:Akka.Routing.Router.RoutingLogic"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.Router.AddRoutee(Akka.Actor.IActorRef)">
            <summary>
            Create a new instance with one more routee and the same <see cref="P:Akka.Routing.Router.RoutingLogic"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.Router.AddRoutee(Akka.Actor.ActorSelection)">
            <summary>
            Create a new instance with one more routee and the same <see cref="P:Akka.Routing.Router.RoutingLogic"/>.
            </summary>  
        </member>
        <member name="M:Akka.Routing.Router.RemoveRoutee(Akka.Routing.Routee)">
            <summary>
            Create a new instance without the specified routee.
            </summary>
        </member>
        <member name="M:Akka.Routing.Router.RemoveRoutee(Akka.Actor.IActorRef)">
            <summary>
            Create a new instance without the specified routee.
            </summary>
        </member>
        <member name="M:Akka.Routing.Router.RemoveRoutee(Akka.Actor.ActorSelection)">
            <summary>
            Create a new instance without the specified routee.
            </summary>
        </member>
        <member name="T:Akka.Routing.RouterActor">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Routing.RouterConfig">
            <summary>
            This class provides base functionality used in the creation and configuration of the various routers in the system.
            </summary>
        </member>
        <member name="F:Akka.Routing.RouterConfig.NoRouter">
            <summary>
            A configuration that specifies that no router is to be used.
            </summary>
        </member>
        <member name="P:Akka.Routing.RouterConfig.RouterDispatcher">
            <summary>
            The id of the dispatcher that the router uses to pass messages to its routees.
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterConfig.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            
            <note>
            This method defaults to ignoring the supplied router and returning itself.
            </note>
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="M:Akka.Routing.RouterConfig.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.RouterConfig.GetRoutees(Akka.Routing.RoutedActorCell)">
            <summary>
            Retrieves an enumeration of <see cref="T:Akka.Routing.Routee">routees</see> that belong to the provided <paramref name="routedActorCell"/>.
            </summary>
            <param name="routedActorCell">The router to query for a list of its routees.</param>
            <returns>The enumeration of routees that belong to the provided <paramref name="routedActorCell"/>.</returns>
        </member>
        <member name="M:Akka.Routing.RouterConfig.IsManagementMessage(System.Object)">
            <summary>
            Determines whether a provided message is handled by the router.
            </summary>
            <param name="message">The message to inspect.</param>
            <returns><c>true</c> if this message is handled by the router; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Routing.RouterConfig.Equals(Akka.Routing.RouterConfig)">
            <summary>
            Determines whether the specified router, is equal to this instance.
            </summary>
            <param name="other">The router to compare.</param>
            <returns><c>true</c> if the specified router is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Routing.RouterConfig.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current router.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current router.</returns>
        </member>
        <member name="M:Akka.Routing.RouterConfig.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RouterConfig"/> class.
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterConfig.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RouterConfig"/> class.
            
            <note>
            This method defaults to setting the dispatcher to use the <see cref="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId"/>.
            </note>
            </summary>
            <param name="routerDispatcher">The dispatcher to use when passing messages to routees.</param>
        </member>
        <member name="T:Akka.Routing.RouterConfigExtensions">
            <summary>
            This class contains extension methods used by <see cref="T:Akka.Routing.RouterConfig"/>s.
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterConfigExtensions.NoRouter(Akka.Routing.RouterConfig)">
            <summary>
            Determines whether or not the provided router is a <see cref="T:Akka.Routing.NoRouter"/>.
            </summary>
            <param name="config">The router to check.</param>
            <returns><c>true</c> if the provided router is a <see cref="T:Akka.Routing.NoRouter"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Akka.Routing.NoRouter">
            <summary>
            This class represents a router that does not route messages.
            </summary>
        </member>
        <member name="P:Akka.Routing.NoRouter.RouterDispatcher">
            <summary>
            The id of the dispatcher that the router uses to pass messages to its routees.
            
            <note>
            THIS METHOD IS NOT IMPLEMENTED.
            </note>
            </summary>
            <exception cref="T:System.NotSupportedException">NoRouter has no router</exception>
        </member>
        <member name="M:Akka.Routing.NoRouter.CreateRouter(Akka.Actor.ActorSystem)">
             <summary>
             Creates a router that is responsible for routing messages to routees within the provided <paramref name="system"/>.
            
             <note>
             THIS METHOD IS NOT IMPLEMENTED.
             </note>
             </summary>
             <param name="system">The actor system that owns this router.</param>
             <returns>
             The newly created router tied to the given system.
             </returns>
             <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Akka.Routing.NoRouter.GetRoutees(Akka.Routing.RoutedActorCell)">
            <summary>
            Retrieves an enumeration of <see cref="T:Akka.Routing.Routee">routees</see> that belong to the provided <paramref name="routedActorCell"/>.
            
            <note>
            THIS METHOD IS NOT IMPLEMENTED.
            </note>
            </summary>
            <param name="routedActorCell">The router to query for a list of its routees.</param>
            <returns>
            The enumeration of routees that belong to the provided <paramref name="routedActorCell"/>.
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:Akka.Routing.NoRouter.NoRouterSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.NoRouter"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.NoRouter.NoRouterSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.NoRouter"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.NoRouter"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="M:Akka.Routing.NoRouter.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.NoRouter"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.NoRouter"/>.</returns>
        </member>
        <member name="M:Akka.Routing.NoRouter.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            
            <note>
            This method returns the provided <paramref name="routerConfig"/>.
            </note>
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="T:Akka.Routing.Group">
            <summary>
            This class provides base functionality for all group routers in the system.
            Group routers are routers that use already created routees. These routees
            are supplied to the router and are addressed through <see cref="T:Akka.Actor.ActorSelection"/>
            paths.
            </summary>
        </member>
        <member name="M:Akka.Routing.Group.Equals(Akka.Routing.Group)">
            <summary>
            Determines whether the specified <see cref="T:Akka.Routing.Group"/>, is equal to this instance.
            </summary>
            <param name="other">The group to compare.</param>
            <returns><c>true</c> if the specified <see cref="T:Akka.Routing.Group"/> is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Routing.Group.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/>, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Routing.Group.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="P:Akka.Routing.Group.Paths">
            <summary>
            Retrieves the actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="M:Akka.Routing.Group.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.Group"/> class.
            
            <note>
            This constructor sets up the group to use the default dispatcher <see cref="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId"/>.
            </note>
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.Group.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.Group"/> class.
            
            <note>
            If a <paramref name="routerDispatcher"/> is not provided, this constructor sets up
            the pool to use the default dispatcher <see cref="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId"/>.
            </note>
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
        </member>
        <member name="M:Akka.Routing.Group.#ctor(System.Collections.Generic.IEnumerable{Akka.Actor.IActorRef})">
             <summary>
             Initializes a new instance of the <see cref="T:Akka.Routing.Group"/> class.
            
             <note>
             This constructor sets up the group to use the default dispatcher <see cref="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId"/>.
             </note>
             </summary>
             <param name="routees">An enumeration of routees used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.Group.Props">
            <summary>
            Adds the current router to an empty <see cref="T:Akka.Actor.Props"/>.
            </summary>
            <returns>An empty <see cref="T:Akka.Actor.Props"/> configured to use the current router.</returns>
        </member>
        <member name="M:Akka.Routing.Group.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system"/>.
            
            <note>
            THIS METHOD IS NOT IMPLEMENTED.
            </note>
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>
            The newly created router tied to the given system.
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Akka.Routing.Group.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.Group"/> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.Group.GetRoutees(Akka.Routing.RoutedActorCell)">
            <summary>
            Retrieves an enumeration of <see cref="T:Akka.Routing.Routee">routees</see> that belong to the provided <paramref name="routedActorCell"/>.
            </summary>
            <param name="routedActorCell">The router to query for a list of its routees.</param>
            <returns>
            The enumeration of routees that belong to the provided <paramref name="routedActorCell"/>.
            </returns>
        </member>
        <member name="M:Akka.Routing.Group.Equals(Akka.Routing.RouterConfig)">
            <summary>
            Determines whether the specified router, is equal to this instance.
            </summary>
            <param name="other">The router to compare.</param>
            <returns>
              <c>true</c> if the specified router is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Akka.Routing.Pool">
            <summary>
            This class provides base functionality for all pool routers in the system.
            Pool routers are routers that create their own routees based on the provided
            configuration.
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.Equals(Akka.Routing.Pool)">
            <summary>
            Determines whether the specified <see cref="T:Akka.Routing.Pool"/>, is equal to this instance.
            </summary>
            <param name="other">The pool to compare.</param>
            <returns><c>true</c> if the specified <see cref="T:Akka.Routing.Pool"/> is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Routing.Pool.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/>, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Routing.Pool.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Akka.Routing.Pool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.Pool"/> class.
            
            <note>
            If a <paramref name="routerDispatcher"/> is not provided, this constructor sets up
            the pool to use the default dispatcher <see cref="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId"/>.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Akka.Routing.Pool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.Pool"/> class.
            
            <note>
            This constructor sets up the pool to use the default dispatcher <see cref="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId"/>.
            </note>
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="P:Akka.Routing.Pool.NrOfInstances">
            <summary>
            Retrieves the number of routees associated with this pool.
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.GetNrOfInstances(Akka.Actor.ActorSystem)">
            <summary>
            Used by the <see cref="T:Akka.Routing.RoutedActorCell"/> to determine the initial number of routees.
            
            <note>
            Needs to be connected to an <see cref="T:Akka.Actor.ActorSystem"/> for clustered deployment scenarios.
            </note>
            </summary>
            <param name="system"></param>
            <returns>The number of routees associated with this pool.</returns>
        </member>
        <member name="P:Akka.Routing.Pool.UsePoolDispatcher">
            <summary>
            Retrieve whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.Pool.Resizer">
            <summary>
            Retrieve the resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.Pool.SupervisorStrategy">
            <summary>
            Retrieve the strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.NewRoutee(Akka.Actor.Props,Akka.Actor.IActorContext)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.Routee"/> configured to use the provided <paramref name="routeeProps"/>
            and the pool dispatcher if enabled.
            </summary>
            <param name="routeeProps">The <see cref="T:Akka.Actor.Props"/> to configure with the pool dispatcher.</param>
            <param name="context">The context for the provided <paramref name="routeeProps"/>.</param>
            <returns>
            A new <see cref="T:Akka.Routing.Routee"/> configured to use the provided <paramref name="routeeProps"/>
            and the pool dispatcher if enabled.
            </returns>
        </member>
        <member name="M:Akka.Routing.Pool.Props(Akka.Actor.Props)">
            <summary>
            Adds the current router to the provided <paramref name="routeeProps"/>.
            </summary>
            <param name="routeeProps">The <see cref="T:Akka.Actor.Props"/> to configure with the current router.</param>
            <returns>The provided <paramref name="routeeProps"/> configured to use the current router.</returns>
        </member>
        <member name="M:Akka.Routing.Pool.GetRoutees(Akka.Routing.RoutedActorCell)">
            <summary>
            Retrieves an enumeration of <see cref="T:Akka.Routing.Routee">routees</see> that belong to the provided <paramref name="routedActorCell"/>.
            </summary>
            <param name="routedActorCell">The router to query for a list of its routees.</param>
            <returns>
            The enumeration of routees that belong to the provided <paramref name="routedActorCell"/>.
            </returns>
        </member>
        <member name="M:Akka.Routing.Pool.OverrideUnsetConfig(Akka.Routing.RouterConfig)">
            <summary>
            Overrides the settings of the current router with those in the provided configuration.
            </summary>
            <param name="other">The configuration whose settings are used to overwrite the current router.</param>
            <returns>The current router whose settings have been overwritten.</returns>
        </member>
        <member name="M:Akka.Routing.Pool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.Pool"/> router with a given <see cref="T:Akka.Actor.SupervisorStrategy"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy"/>.</returns>
        </member>
        <member name="M:Akka.Routing.Pool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.Pool"/> router with a given <see cref="T:Akka.Routing.Resizer"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer"/>.</returns>
        </member>
        <member name="M:Akka.Routing.Pool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.Pool"/> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="P:Akka.Routing.Pool.DefaultStrategy">
            <summary>
            Retrieves the default <see cref="T:Akka.Actor.SupervisorStrategy"/> used by this router when one has not been specified.
            When supervisorStrategy is not specified for an actor this
            is used by default.
            
            <note>
            The default strategy used is <see cref="T:Akka.Actor.OneForOneStrategy"/> with an <see cref="F:Akka.Actor.Directive.Escalate"/> decider.
            </note>
            </summary>
        </member>
        <member name="T:Akka.Routing.FromConfig">
            <summary>
            This class represents a router that gets it's configuration from the system.
            
            For example:
            <code>
            IActorRef router1 = Sys.ActorOf(Props.Create{Echo}().WithRouter(FromConfig.Instance), "router1");
            </code>
            </summary>
        </member>
        <member name="M:Akka.Routing.FromConfig.Props(Akka.Actor.Props)">
            <summary>
            Enriches a <see cref="T:Akka.Actor.Props"/> with what what's stored in the router configuration.
            <note>
            This is semantically the same as:
                <code>
                    props.WithRouter(FromConfig.Instance)
                </code>
            </note>
            </summary>
            <param name="props">The Props to enrich</param>
            <returns></returns>
        </member>
        <member name="P:Akka.Routing.FromConfig.Instance">
            <summary>
            Retrieves a <see cref="T:Akka.Routing.RouterConfig"/> based on what's stored in the configuration.
            
            <note>
            This router is set to use the default dispatcher <see cref="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId"/>.
            </note>
            </summary>
        </member>
        <member name="M:Akka.Routing.FromConfig.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system"/>.
            
            <note>
            THIS METHOD IS NOT SUPPORTED.
            </note>
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>
            The newly created router tied to the given system.
            </returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Akka.Routing.FromConfig.GetRoutees(Akka.Routing.RoutedActorCell)">
            <summary>
            Retrieves an enumeration of routees that belong to a provided <paramref name="routedActorCell"/>.
            
            <note>
            THIS METHOD IS NOT SUPPORTED.
            </note>
            </summary>
            <param name="routedActorCell">The router to query for a list of its routees.</param>
            <returns>
            The enumeration of routees that belong to the provided <paramref name="routedActorCell"/>.
            </returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="T:Akka.Routing.FromConfig.FromConfigSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.FromConfig"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.FromConfig.FromConfigSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.FromConfig"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.FromConfig"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="M:Akka.Routing.FromConfig.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.FromConfig"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.FromConfig"/>.</returns>
        </member>
        <member name="T:Akka.Routing.RouterMessage">
            <summary>
            This class contains convenience methods used to send messages to a <see cref="T:Akka.Routing.Router"/>.
            </summary>
        </member>
        <member name="F:Akka.Routing.RouterMessage.GetRoutees">
            <summary>
            Sends a <see cref="T:Akka.Routing.RouterManagementMessage"/> to a <see cref="T:Akka.Routing.Router"/>
            to retrieve a list of routees that the router is currently using.
            </summary>
        </member>
        <member name="T:Akka.Routing.RouterManagementMessage">
            <summary>
            This class represents a non-routed message that is processed by the <see cref="T:Akka.Routing.Router"/>.
            These types of messages are for managing the router itself, like adding routees, deleting
            routees, etc.
            </summary>
        </member>
        <member name="T:Akka.Routing.GetRoutees">
            <summary>
            This class represents a <see cref="T:Akka.Routing.RouterManagementMessage"/> sent to a <see cref="T:Akka.Routing.Router"/> instructing
            it to send a <see cref="T:Akka.Routing.Routees"/> message back to the requestor that lists the routees that the router
            is currently using.
            </summary>
        </member>
        <member name="T:Akka.Routing.Routees">
            <summary>
            This class represents a message used to carry information about what routees a <see cref="T:Akka.Routing.Router"/> is currently using.
            </summary>
        </member>
        <member name="M:Akka.Routing.Routees.#ctor(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.Routees"/> class.
            </summary>
            <param name="routees">The routees that a <see cref="T:Akka.Routing.Router"/> is currently using.</param>
        </member>
        <member name="P:Akka.Routing.Routees.Members">
            <summary>
            An enumeration of routees that a <see cref="T:Akka.Routing.Router"/> is currently using.
            </summary>
        </member>
        <member name="T:Akka.Routing.RemoveRoutee">
            <summary>
            This class represents a <see cref="T:Akka.Routing.RouterManagementMessage"/> sent to a <see cref="T:Akka.Routing.Router"/> instructing
            it to remove a specific routee from the router's collection of routees. It may be handled after other messages.
            
            <note>
            For a pool with child routees the routee is stopped by sending a <see cref="T:Akka.Actor.PoisonPill"/>
            to the routee. Precautions are taken to reduce the risk of dropping messages that are concurrently
            being routed to the remove routee, but there are no guarantees. 
            </note>
            </summary>
        </member>
        <member name="M:Akka.Routing.RemoveRoutee.#ctor(Akka.Routing.Routee)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RemoveRoutee"/> class.
            </summary>
            <param name="routee">The routee to remove from the router's collection of routees.</param>
        </member>
        <member name="P:Akka.Routing.RemoveRoutee.Routee">
            <summary>
            The routee removed from the router's collection of routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.AddRoutee">
            <summary>
            This class represents a <see cref="T:Akka.Routing.RouterManagementMessage"/> sent to a <see cref="T:Akka.Routing.Router"/> instructing
            it to add a specific routee to the router's collection of routees. It may be handled after other messages.
            </summary>
        </member>
        <member name="M:Akka.Routing.AddRoutee.#ctor(Akka.Routing.Routee)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.AddRoutee"/> class.
            </summary>
            <param name="routee">The routee added to the router's collection of routees.</param>
        </member>
        <member name="P:Akka.Routing.AddRoutee.Routee">
            <summary>
            The routee added to the router's collection of routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.AdjustPoolSize">
            <summary>
            This class represents a <see cref="T:Akka.Routing.RouterManagementMessage"/> sent to a <see cref="T:Akka.Routing.Pool"/> router instructing
            it to increase or decrease the number of alloted routees the router can use. It may be handled after other messages.
            
            <remarks>
            Positive <see cref="P:Akka.Routing.AdjustPoolSize.Change"/> will add that number of routees to the <see cref="T:Akka.Routing.Pool"/>.
            Negative <see cref="P:Akka.Routing.AdjustPoolSize.Change"/> will remove that number of routees from the <see cref="T:Akka.Routing.Pool"/>.
            </remarks>
             <notes>
            Routees are stopped by sending a <see cref="T:Akka.Actor.PoisonPill"/> to the routee.
            Precautions are taken to reduce the risk of dropping messages that are concurrently
            being routed to the remove routee, but there are no guarantees. 
            </notes>
            </summary>
        </member>
        <member name="M:Akka.Routing.AdjustPoolSize.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.AdjustPoolSize"/> class.
            </summary>
            <param name="change">The number of routees to add or subtract from the <see cref="T:Akka.Routing.Pool"/>.</param>
        </member>
        <member name="P:Akka.Routing.AdjustPoolSize.Change">
            <summary>
            The number of routees added or subtracted from the <see cref="T:Akka.Routing.Pool"/>.
            </summary>
        </member>
        <member name="T:Akka.Routing.RouterPoolActor">
            <summary>
            INTERNAL API
            
            Actor implementation for <see cref="P:Akka.Routing.RouterPoolActor.Pool"/> routers.
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterPoolActor.#ctor(Akka.Actor.SupervisorStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RouterPoolActor"/> class.
            </summary>
            <param name="supervisorStrategy">The supervisor strategy.</param>
        </member>
        <member name="M:Akka.Routing.RouterPoolActor.OnReceive(System.Object)">
            <summary>
            Called when [receive].
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedRoutingLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to a <see cref="T:Akka.Routing.Routee"/> determined
            using scatter-gather-first-completed. This process has the router send a message to all of its routees. The first
            response is used and the remaining are discarded. If the none of the routees respond within a specified time
            limit, a timeout failure occurs.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedRoutingLogic.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedRoutingLogic"/> class.
            </summary>
            <param name="within">The amount of time to wait for a response.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks all the provided <paramref name="routees"/> to receive the <paramref name="message" />.
            </summary>
            <param name="message">The message that is being routed</param>
            <param name="routees">A collection of routees to choose from when receiving the <paramref name="message" />.</param>
            <returns>A <see cref="T:Akka.Routing.ScatterGatherFirstCompletedRoutees" /> that receives the <paramref name="message" />.</returns>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedRoutees">
            <summary>
            This class represents a single point <see cref="T:Akka.Routing.Routee"/> that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined
            using scatter-gather-first-completed. This process has the router send a message to all of its routees. The first
            response is used and the remaining are discarded. If the none of the routees respond within a specified time limit,
            a timeout failure occurs.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedRoutees.#ctor(Akka.Routing.Routee[],System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedRoutees"/> class.
            </summary>
            <param name="routees">The list of routees that the router uses to send messages.</param>
            <param name="within">The time within which at least one response is expected.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedRoutees.Send(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Sends a message to the collection of routees.
            </summary>
            <param name="message">The message that is being sent.</param>
            <param name="sender">The actor sending the message.</param>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedGroup">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Group"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using scatter-gather-first-completed.
            This process has the router send a message to all of its routees. The first response is used and the remaining are discarded. If the none of the
            routees respond within a specified time limit, a timeout failure occurs.
            </summary>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedGroup.ScatterGatherFirstCompletedGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.ScatterGatherFirstCompletedGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedGroup.ScatterGatherFirstCompletedGroupSurrogate.Within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedGroup.ScatterGatherFirstCompletedGroupSurrogate.Paths">
            <summary>
            The actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/>.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            
            <note>
            If 'routees.path' is defined in the provided configuration then those paths will be used by the router.
            If 'within' is defined in the provided configuration then that will be used as the interval.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(System.TimeSpan,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup" /> class.
            </summary>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="paths">A list of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup" /> class.
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
            <param name="within">The amount of time to wait for a response.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(System.Collections.Generic.IEnumerable{Akka.Actor.IActorRef},System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> class.
            </summary>
            <param name="routees">An enumeration of routees used by the group router.</param>
            <param name="within">The amount of time to wait for a response.</param>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedGroup.Within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup" /> router with a given dispatcher id.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using scatter-gather-first-completed.
            This process has the router send a message to all of its routees. The first response is used and the remaining are discarded. If the none of the
            routees respond within a specified time limit, a timeout failure occurs.
            </summary>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.Within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creeates a surrogate representation of the current <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/>.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.TimeSpan,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="within">The amount of time to wait for a response.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            
            <note>
            'within' must be defined in the provided configuration.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> class.
            
            <note>
            A <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool" /> router with a given <see cref="T:Akka.Actor.SupervisorStrategy" />.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy" />.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool" /> router with a given <see cref="T:Akka.Routing.Resizer" />.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer" />.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="T:Akka.Serialization.JavaSerializer">
            <summary>
            This is a special <see cref="T:Akka.Serialization.Serializer"/> that serializes and deserializes Java objects only.
            </summary>
        </member>
        <member name="M:Akka.Serialization.JavaSerializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Serialization.JavaSerializer" /> class.
            </summary>
            <param name="system">The actor system to associate with this serializer. </param>
        </member>
        <member name="P:Akka.Serialization.JavaSerializer.Identifier">
            <summary>
            Completely unique value to identify this implementation of the <see cref="T:Akka.Serialization.Serializer"/> used to optimize network traffic
            </summary>
        </member>
        <member name="P:Akka.Serialization.JavaSerializer.IncludeManifest">
            <summary>
            Returns whether this serializer needs a manifest in the fromBinary method
            </summary>
        </member>
        <member name="M:Akka.Serialization.JavaSerializer.ToBinary(System.Object)">
            <summary>
            Serializes the given object into a byte array
            </summary>
            <param name="obj">The object to serialize </param>
            <returns>A byte array containing the serialized object</returns>
        </member>
        <member name="M:Akka.Serialization.JavaSerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a byte array into an object of type <paramref name="type"/>
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <param name="type">The type of object contained in the array</param>
            <returns>The object contained in the array</returns>
        </member>
        <member name="T:Akka.Serialization.ByteArraySerializer">
            <summary>
            This is a special <see cref="T:Akka.Serialization.Serializer"/> that serializes and deserializes byte arrays only
            (just returns the byte array unchanged/uncopied).
            </summary>
        </member>
        <member name="M:Akka.Serialization.ByteArraySerializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Serialization.ByteArraySerializer" /> class.
            </summary>
            <param name="system">The actor system to associate with this serializer. </param>
        </member>
        <member name="P:Akka.Serialization.ByteArraySerializer.Identifier">
            <summary>
            Completely unique value to identify this implementation of the <see cref="T:Akka.Serialization.Serializer"/> used to optimize network traffic
            </summary>
        </member>
        <member name="P:Akka.Serialization.ByteArraySerializer.IncludeManifest">
            <summary>
            Returns whether this serializer needs a manifest in the fromBinary method
            </summary>
        </member>
        <member name="M:Akka.Serialization.ByteArraySerializer.ToBinary(System.Object)">
            <summary>
            Serializes the given object into a byte array
            </summary>
            <param name="obj">The object to serialize </param>
            <returns>A byte array containing the serialized object</returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Akka.Serialization.ByteArraySerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a byte array into an object of type <paramref name="type"/>.
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <param name="type">The type of object contained in the array</param>
            <returns>The object contained in the array</returns>
        </member>
        <member name="T:Akka.Serialization.NewtonSoftJsonSerializer">
            <summary>
            This is a special <see cref="P:Akka.Serialization.NewtonSoftJsonSerializer.Serializer"/> that serializes and deserializes javascript objects only.
            These objects need to be in the JavaScript Object Notation (JSON) format.
            </summary>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Serialization.NewtonSoftJsonSerializer" /> class.
            </summary>
            <param name="system">The actor system to associate with this serializer. </param>
        </member>
        <member name="P:Akka.Serialization.NewtonSoftJsonSerializer.Identifier">
            <summary>
            Completely unique value to identify this implementation of the <see cref="P:Akka.Serialization.NewtonSoftJsonSerializer.Serializer"/> used to optimize network traffic
            </summary>
        </member>
        <member name="P:Akka.Serialization.NewtonSoftJsonSerializer.IncludeManifest">
            <summary>
            Returns whether this serializer needs a manifest in the fromBinary method
            </summary>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.ToBinary(System.Object)">
            <summary>
            Serializes the given object into a byte array
            </summary>
            <param name="obj">The object to serialize </param>
            <returns>A byte array containing the serialized object</returns>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a byte array into an object of type <paramref name="type"/>.
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <param name="type">The type of object contained in the array</param>
            <returns>The object contained in the array</returns>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.SurrogateConverter.CanConvert(System.Type)">
            <summary>
                Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns><c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.SurrogateConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
                Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.SurrogateConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
                Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="T:Akka.Serialization.NullSerializer">
            <summary>
            This is a special <see cref="T:Akka.Serialization.Serializer"/> that serializes and deserializes nulls only
            </summary>
        </member>
        <member name="M:Akka.Serialization.NullSerializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Serialization.NullSerializer" /> class.
            </summary>
            <param name="system">The actor system to associate with this serializer. </param>
        </member>
        <member name="P:Akka.Serialization.NullSerializer.Identifier">
            <summary>
            Completely unique value to identify this implementation of the <see cref="T:Akka.Serialization.Serializer"/> used to optimize network traffic
            </summary>
        </member>
        <member name="P:Akka.Serialization.NullSerializer.IncludeManifest">
            <summary>
            Returns whether this serializer needs a manifest in the fromBinary method
            </summary>
        </member>
        <member name="M:Akka.Serialization.NullSerializer.ToBinary(System.Object)">
            <summary>
            Serializes the given object into a byte array
            </summary>
            <param name="obj">The object to serialize </param>
            <returns>A byte array containing the serialized object</returns>
        </member>
        <member name="M:Akka.Serialization.NullSerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a byte array into an object of type <paramref name="type"/>
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <param name="type">The type of object contained in the array</param>
            <returns>The object contained in the array</returns>
        </member>
        <member name="T:Akka.Serialization.Serializer">
             <summary>
             A Serializer represents a bimap between an object and an array of bytes representing that object.
            
             Serializers are loaded using reflection during <see cref="T:Akka.Actor.ActorSystem"/>
             start-up, where two constructors are tried in order:
            
             <ul>
             <li>taking exactly one argument of type <see cref="T:Akka.Actor.ExtendedActorSystem"/>;
             this should be the preferred one because all reflective loading of classes
             during deserialization should use ExtendedActorSystem.dynamicAccess (see
             [[akka.actor.DynamicAccess]]), and</li>
             <li>without arguments, which is only an option if the serializer does not
             load classes using reflection.</li>
             </ul>
            
             <b>Be sure to always use the PropertyManager for loading classes!</b> This is necessary to
             avoid strange match errors and inequalities which arise from different class loaders loading
             the same class.
             </summary>
        </member>
        <member name="F:Akka.Serialization.Serializer.system">
            <summary>
            The actor system to associate with this serializer.
            </summary>
        </member>
        <member name="M:Akka.Serialization.Serializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Serialization.Serializer" /> class.
            </summary>
            <param name="system">The actor system to associate with this serializer. </param>
        </member>
        <member name="P:Akka.Serialization.Serializer.Identifier">
            <summary>
            Completely unique value to identify this implementation of Serializer, used to optimize network traffic
            Values from 0 to 16 is reserved for Akka internal usage
            </summary>
        </member>
        <member name="P:Akka.Serialization.Serializer.IncludeManifest">
            <summary>
            Returns whether this serializer needs a manifest in the fromBinary method
            </summary>
        </member>
        <member name="M:Akka.Serialization.Serializer.ToBinary(System.Object)">
            <summary>
            Serializes the given object into a byte array
            </summary>
            <param name="obj">The object to serialize </param>
            <returns>A byte array containing the serialized object</returns>
        </member>
        <member name="M:Akka.Serialization.Serializer.ToBinaryWithAddress(Akka.Actor.Address,System.Object)">
            <summary>
            Serializes the given object into a byte array and uses the given address to decorate serialized ActorRef's
            </summary>
            <param name="address">The address to use when serializing local ActorRef´s</param>
            <param name="obj">The object to serialize</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Serialization.Serializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a byte array into an object of type <paramref name="type"/>.
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <param name="type">The type of object contained in the array</param>
            <returns>The object contained in the array</returns>
        </member>
        <member name="M:Akka.Serialization.Serializer.TypeQualifiedNameForManifest(System.Type)">
            <summary>
            Utility to be used by implementors to create a manifest from the type.
            The manifest is used to look up the type on deserialization.
            Returns the type qualified name including namespace and assembly, but not assembly version.
            </summary>
            <remarks>
            See <see cref="M:System.Type.GetType(System.String)"/> for details on how a type is looked up
            from a name. In particular, if the (partial) assembly name is not included
            only the assembly calling <see cref="M:System.Type.GetType(System.String)"/> is searched.
            If the (partial) assembly name is included, it searches in the specified assembly.
            </remarks>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Serialization.SerializerWithStringManifest.FromBinary(System.Byte[],System.String)">
            <summary>
            Produces an object from an array of bytes, with an optional type-hint.
            </summary>
        </member>
        <member name="M:Akka.Serialization.SerializerWithStringManifest.Manifest(System.Object)">
            <summary>
            Return the manifest (type hint) that will be provided in the fromBinary method.
            Return <see cref="F:System.String.Empty"/> if not needed.
            </summary>
        </member>
        <member name="T:Akka.Serialization.SerializerIdentifierHelper">
            <summary>
            INTERNAL API.
            </summary>
        </member>
        <member name="M:Akka.Util.ByteIterator.GetByte">
            <summary>Get a single Byte from this iterator. Identical to next().</summary>
        </member>
        <member name="M:Akka.Util.ByteIterator.GetShort(Akka.IO.ByteOrder)">
            <summary>Get a single Short from this iterator.</summary>
        </member>
        <member name="M:Akka.Util.ByteIterator.GetInt(Akka.IO.ByteOrder)">
            <summary>Get a single Int from this iterator.</summary>
        </member>
        <member name="M:Akka.Util.ByteIterator.GetLong(Akka.IO.ByteOrder)">
            <summary>Get a single Long from this iterator.</summary>
        </member>
        <member name="T:Akka.Util.ContinuousEnumerator`1">
            <summary>
            Implements a circular <see cref="T:System.Collections.Generic.IEnumerator`1"/> around an existing <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            
            This allows for continuous read-only iteration over a set.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Akka.Util.ContinuousEnumerator`1._internalEnumerator">
            <summary>
            The raw iterator from some <see cref="T:System.Collections.Generic.IEnumerable`1"/> object
            </summary>
        </member>
        <member name="T:Akka.Util.ContinuousEnumeratorExtensions">
            <summary>
            Extension method class for adding <see cref="T:Akka.Util.ContinuousEnumerator`1"/> support to any <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            instance within Akka.NET
            </summary>
        </member>
        <member name="M:Akka.Util.ContinuousEnumeratorExtensions.GetContinuousEnumerator``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Provides a <see cref="T:Akka.Util.ContinuousEnumerator`1"/> instance for <paramref name="collection"/>.
            
            Internally, it just wraps <paramref name="collection"/>'s internal iterator with circular iteration behavior.
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.AtomicState">
            <summary>
            Internal state abstraction
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.AddListener(System.Action)">
            <summary>
            Add a listener function which is invoked on state entry
            </summary>
            <param name="listener">listener implementation</param>
        </member>
        <member name="P:Akka.Util.Internal.AtomicState.HasListeners">
            <summary>
            Test for whether listeners exist
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.NotifyTransitionListeners">
            <summary>
            Notifies the listeners of the transition event via a 
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.CallThrough``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Shared implementation of call across all states.  Thrown exception or execution of the call beyond the allowed
            call timeout is counted as a failed call, otherwise a successful call
            
            NOTE: In .Net there is no way to cancel an uncancellable task. We are merely cancelling the wait and marking this
            as a failure.
            
            see http://blogs.msdn.com/b/pfxteam/archive/2011/11/10/10235834.aspx 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="task">Implementation of the call</param>
            <returns>result of the call</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.CallThrough(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Shared implementation of call across all states.  Thrown exception or execution of the call beyond the allowed
            call timeout is counted as a failed call, otherwise a successful call
            
            NOTE: In .Net there is no way to cancel an uncancellable task. We are merely cancelling the wait and marking this
            as a failure.
            
            see http://blogs.msdn.com/b/pfxteam/archive/2011/11/10/10235834.aspx 
            </summary>
            <param name="task"><see cref="T:System.Threading.Tasks.Task"/> Implementation of the call</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.Invoke``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Abstract entry point for all states
            </summary>
            <typeparam name="T"></typeparam>
            <param name="body">Implementation of the call that needs protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.Invoke(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Abstract entry point for all states
            </summary>
            <param name="body">Implementation of the call that needs protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.CallFails">
            <summary>
            Invoked when call fails
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.CallSucceeds">
            <summary>
            Invoked when call succeeds
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.EnterInternal">
            <summary>
            Invoked on the transitioned-to state during transition. Notifies listeners after invoking subclass template method _enter
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.Enter">
            <summary>
            Enter the state. NotifyTransitionListeners is not awaited -- its "fire and forget". 
            It is up to the user to handle any errors that occur in this state.
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.IAtomicState">
            <summary>
            This interface represents the parts of the internal circuit breaker state; the behavior stack, watched by, watching and termination queue
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.ImmutabilityUtils">
            <summary>
            Utility class for adding some basic immutable behaviors
            to specific types of collections without having to reference
            the entire BCL.Immutability NuGet package.
            
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.InterlockedSpin">
            <summary>INTERNAL!
            Implements helpers for performing Compare-and-swap operations using <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.InterlockedSpin.Swap``1(``0@,System.Func{``0,``0})">
            <summary>INTERNAL!
            Atomically updates the object <paramref name="reference"/> by calling <paramref name="updater"/> to get the new value.
            Note that <paramref name="updater"/> may be called many times so it should be idempotent.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
            <returns>The updated value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.InterlockedSpin.ConditionallySwap``2(``0@,System.Func{``0,System.Tuple{System.Boolean,``0,``1}})">
            <summary>INTERNAL!
            Atomically updates the int <paramref name="reference"/> by calling <paramref name="updateIfTrue"/> to get the new value.
            <paramref name="updateIfTrue"/> returns a Tuple&lt;should update, the new int value, the return value&gt;
            If the first item in the tuple is true, the value is updated, and the third value of the tuple is returned.
            Note that <paramref name="updateIfTrue"/> may be called many times so it should be idempotent.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
            <returns>The third value from the tuple return by <paramref name="updateIfTrue"/>.</returns>
        </member>
        <member name="T:Akka.Util.Internal.StringBuilderExtensions">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.Drop``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Scala alias for Skip
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.Head``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Scala alias for FirstOrDefault
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.AddOrSet``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Dictionary helper that allows for idempotent updates. You don't need to care whether or not
            this item is already in the collection in order to update it.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.TakeRight``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Selects last n elements.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:Akka.Util.Internal.ArrayExtensions">
            <summary>
            Provides extension utilities to arrays.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.IsNullOrEmpty(System.Array)">
            <summary>
            Determines if an array is null or empty.
            </summary>
            <param name="obj">The array to check.</param>
            <returns>True if null or empty, false otherwise.</returns>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.NonEmpty(System.Array)">
            <summary>
            Determines if an array is not null or empty.
            </summary>
            <param name="obj">The array to check.</param>
            <returns>True if not null or empty, false otherwise.</returns>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.Shuffle``1(``0[])">
            <summary>
            Shuffles an array of objects.
            </summary>
            <typeparam name="T">The type of the array to sort.</typeparam>
            <param name="array">The array to sort.</param>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.ZipWithIndex``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Implementation of Scala's ZipWithIndex method.
            
            Folds a collection into a Dictionary where the original value (of type T) acts as the key
            and the index of the item in the array acts as the value.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Grabs a subset of an IEnumerable based on a starting index and position
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The array of items to slice</param>
            <param name="startIndex">The starting position to begin the slice</param>
            <param name="count">The number of items to take</param>
            <returns>A slice of size <paramref name="count"/> beginning from position <sparamref name="startIndex"/> in <paramref name="items"/>.</returns>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.From``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Select all the items in this array beginning with <paramref name="startingItem"/> and up until the end of the array.
            
            <note>
            If <paramref name="startingItem"/> is not found in the array, From will return an empty set.
            If <paramref name="startingItem"/> is found at the end of the array, From will return the entire original array.
            </note>
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.Until``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Select all the items in this array from the beginning until (but not including) <paramref name="startingItem"/>
            <note>
            If <paramref name="startingItem"/> is not found in the array, Until will select all items.
            If <paramref name="startingItem"/> is the first item in the array, an empty array will be returned.
            </note>
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.AtomicCounter">
            <summary>
            An atomic 32 bit integer counter.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.#ctor(System.Int32)">
            <summary>
            Creates an instance of an AtomicCounter.
            </summary>
            <param name="initialValue">The initial value of this counter.</param>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.#ctor">
            <summary>
            Creates an instance of an AtomicCounter with a starting value of -1.
            </summary>
        </member>
        <member name="F:Akka.Util.Internal.AtomicCounter._value">
            <summary>
            The current value of the atomic counter.
            </summary>
        </member>
        <member name="P:Akka.Util.Internal.AtomicCounter.Current">
            <summary>
            Retrieves the current value of the counter
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.Next">
            <summary>
            Increments the counter and returns the next value
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.GetAndIncrement">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.IncrementAndGet">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The new value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.GetAndAdd(System.Int32)">
            <summary>
            Returns the current value and adds the specified value to the counter.
            </summary>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The original value before additions.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.AddAndGet(System.Int32)">
            <summary>
            Adds the specified value to the counter and returns the new value.
            </summary>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The new value after additions.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.Reset">
            <summary>
            Resets the counter to zero.
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.AtomicCounterLong">
            <summary>
            An atomic 64 bit integer counter.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.#ctor(System.Int64)">
            <summary>
            Creates an instance of an AtomicCounterLong.
            </summary>
            <param name="value">The initial value of this counter.</param>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.#ctor">
            <summary>
            Creates an instance of an AtomicCounterLong with a starting value of -1.
            </summary>
        </member>
        <member name="F:Akka.Util.Internal.AtomicCounterLong._value">
            <summary>
            The current value for this counter.
            </summary>
        </member>
        <member name="P:Akka.Util.Internal.AtomicCounterLong.Current">
            <summary>
            Retrieves the current value of the counter
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.Next">
            <summary>
            Increments the counter and returns the next value.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.GetAndIncrement">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.IncrementAndGet">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The new value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.GetAndAdd(System.Int64)">
            <summary>
            Gets the current value of the counter and adds an amount to it.
            </summary>
            <remarks>This uses a CAS loop as Interlocked.Increment is not atomic for longs on 32bit systems.</remarks>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.AddAndGet(System.Int64)">
            <summary>
            Adds an amount to the counter and returns the new value.
            </summary>
            <remarks>This uses a CAS loop as Interlocked.Increment is not atomic for longs on 32bit systems.</remarks>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The new counter value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.Reset">
            <summary>
            Resets the counter to zero.
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.IAtomicCounter`1">
            <summary>
            An interface that describes a numeric counter.
            </summary>
            <typeparam name="T">The type of the numeric.</typeparam>
        </member>
        <member name="P:Akka.Util.Internal.IAtomicCounter`1.Current">
            <summary>
            The current value of this counter.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.Next">
            <summary>
            Increments the counter and gets the next value. This is exactly the same as calling <see cref="M:Akka.Util.Internal.IAtomicCounter`1.IncrementAndGet"/>.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.GetAndIncrement">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.IncrementAndGet">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The new value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.GetAndAdd(`0)">
            <summary>
            Returns the current value and adds the specified value to the counter.
            </summary>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The original value before additions.</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.AddAndGet(`0)">
            <summary>
            Adds the specified value to the counter and returns the new value.
            </summary>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The new value after additions.</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.Reset">
            <summary>
            Resets the counter to zero.
            </summary>
        </member>
        <member name="M:Akka.Util.MonotonicClock.ToNanos(System.Int64)">
            <summary>
            Ticks represent 100 nanos. https://msdn.microsoft.com/en-us/library/system.datetime.ticks(v=vs.110).aspx
            
            This extension method converts a Ticks value to nano seconds.
            </summary>
        </member>
        <member name="M:Akka.Util.MonotonicClock.ToTicks(System.Int64)">
            <summary>
            Ticks represent 100 nanos. https://msdn.microsoft.com/en-us/library/system.datetime.ticks(v=vs.110).aspx
            
            This extension method converts a nano seconds value to Ticks.
            </summary>
        </member>
        <member name="M:Akka.Util.Reflection.TypeCache.GetType(System.String)">
            <summary>
            Gets the <see cref="T:System.Type"/> with the specified name, performing a case-sensitive search and throw an exception if the type is not found.
            </summary>
            
            <returns>
            The type with the specified name. If the type is not found, an exception is thrown.
            </returns>
            <param name="typeName">
            The assembly-qualified name of the type to get. See <see cref="P:System.Type.AssemblyQualifiedName"/>.
            If the type is in Akka.dll or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.
            </param>
        </member>
        <member name="T:Akka.Util.StandardOutWriter">
            <summary>
            This class contains methods for thread safe writing to the standard output stream.
             </summary>
        </member>
        <member name="M:Akka.Util.StandardOutWriter.Write(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the specified <see cref="T:System.String"/> value to the standard output stream. Optionally 
            you may specify which colors should be used.
            </summary>
            <param name="message">The <see cref="T:System.String"/> value to write</param>
            <param name="foregroundColor">Optional: The foreground color</param>
            <param name="backgroundColor">Optional: The background color</param>
        </member>
        <member name="M:Akka.Util.StandardOutWriter.WriteLine(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the specified <see cref="T:System.String"/> value, followed by the current line terminator,
            to the standard output stream. Optionally you may specify which colors should be used.
            </summary>
            <param name="message">The <see cref="T:System.String"/> value to write</param>
            <param name="foregroundColor">Optional: The foreground color</param>
            <param name="backgroundColor">Optional: The background color</param>
        </member>
        <member name="T:Akka.Util.AtomicReference`1">
            <summary>
            Implementation of the java.concurrent.util AtomicReference type.
            
            Uses <see cref="T:System.Threading.Volatile"/> internally to enforce ordering of writes
            without any explicit locking. .NET's strong memory on write guarantees might already enforce
            this ordering, but the addition of the Volatile guarantees it.
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.#ctor(`0)">
            <summary>
            Sets the initial value of this <see cref="T:Akka.Util.AtomicReference`1"/> to <paramref name="originalValue"/>.
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Akka.Util.AtomicReference`1.Value">
            <summary>
            The current value of this <see cref="T:Akka.Util.AtomicReference`1"/>
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.CompareAndSet(`0,`0)">
            <summary>
            If <see cref="P:Akka.Util.AtomicReference`1.Value"/> equals <paramref name="expected"/>, then set the Value to
            <paramref name="newValue"/>.
            </summary>
            <returns><c>true</c> if <paramref name="newValue"/> was set</returns>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.GetAndSet(`0)">
            <summary>
            Atomically sets the <see cref="P:Akka.Util.AtomicReference`1.Value"/> to <paramref name="newValue"/> and returns the old <see cref="P:Akka.Util.AtomicReference`1.Value"/>.
            </summary>
            <param name="newValue">The new value</param>
            <returns>The old value</returns>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.op_Implicit(Akka.Util.AtomicReference{`0})~`0">
            <summary>
            Implicit conversion operator = automatically casts the <see cref="T:Akka.Util.AtomicReference`1"/> to an instance of <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.op_Implicit(`0)~Akka.Util.AtomicReference{`0}">
            <summary>
            Implicit conversion operator = allows us to cast any type directly into a <see cref="T:Akka.Util.AtomicReference`1"/> instance.
            </summary>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="T:Akka.Util.AtomicBoolean">
            <summary>
            Implementation of the java.concurrent.util.AtomicBoolean type.
            
            Uses <see cref="M:System.Threading.Interlocked.MemoryBarrier"/> internally to enforce ordering of writes
            without any explicit locking. .NET's strong memory on write guarantees might already enforce
            this ordering, but the addition of the MemoryBarrier guarantees it.
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.#ctor(System.Boolean)">
            <summary>
            Sets the initial value of this <see cref="T:Akka.Util.AtomicBoolean"/> to <paramref name="initialValue"/>.
            </summary>
        </member>
        <member name="P:Akka.Util.AtomicBoolean.Value">
            <summary>
            The current value of this <see cref="T:Akka.Util.AtomicReference`1"/>
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.CompareAndSet(System.Boolean,System.Boolean)">
            <summary>
            If <see cref="P:Akka.Util.AtomicBoolean.Value"/> equals <paramref name="expected"/>, then set the Value to
            <paramref name="newValue"/>.
            </summary>
            <returns><c>true</c> if <paramref name="newValue"/> was set</returns>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.op_Implicit(Akka.Util.AtomicBoolean)~System.Boolean">
            <summary>
            Implicit conversion operator = automatically casts the <see cref="T:Akka.Util.AtomicBoolean"/> to a <see cref="T:System.Boolean"/>
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.op_Implicit(System.Boolean)~Akka.Util.AtomicBoolean">
            <summary>
            Implicit conversion operator = allows us to cast any bool directly into a <see cref="T:Akka.Util.AtomicBoolean"/> instance.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Akka.Util.ListPriorityQueue">
            <summary>
            Priority queue implemented using a simple list with binary search for inserts.
            This specific implementation is cheap in terms of memory but weak in terms of performance.
            See http://visualstudiomagazine.com/articles/2012/11/01/priority-queues-with-c.aspx for original implementation
            This specific version is adapted for Envelopes only and calculates a priority of envelope.Message
            </summary>
        </member>
        <member name="T:Akka.Util.MurmurHash">
            <summary>
            Murmur3 Hash implementation
            </summary>
        </member>
        <member name="F:Akka.Util.MurmurHash.StoredMagicA">
            The first 23 magic integers from the first stream are stored here 
        </member>
        <member name="F:Akka.Util.MurmurHash.StoredMagicB">
            The first 23 magic integers from the second stream are stored here 
        </member>
        <member name="F:Akka.Util.MurmurHash.StartMagicA">
            <summary>
            The initial magic integer in the first stream.
            </summary>
        </member>
        <member name="F:Akka.Util.MurmurHash.StartMagicB">
            <summary>
            The initial magic integer in the second stream.
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.StartHash(System.UInt32)">
            <summary>
            Begin a new hash with a seed value.
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.NextMagicA(System.UInt32)">
            <summary>
            Given a magic integer from the first stream, compute the next
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.NextMagicB(System.UInt32)">
            <summary>
            Given a magic integer from the second stream, compute the next
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.ExtendHash(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Incorporates a new value into an existing hash
            </summary>
            <param name="hash">The prior hash value</param>
            <param name="value">The new value to incorporate</param>
            <param name="magicA">A magic integer from the left of the stream</param>
            <param name="magicB">A magic integer from a different stream</param>
            <returns>The updated hash value</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.FinalizeHash(System.UInt32)">
            <summary>
            Once all hashes have been incorporated, this performs a final mixing.
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.RotateLeft32(System.UInt32,System.Int32)">
            <summary>
            Rotate a 32-bit unsigned integer to the left by <paramref name="shift"/> bits
            </summary>
            <param name="original">Original value</param>
            <param name="shift">The shift value</param>
            <returns>The rotated 32-bit integer</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.RotateLeft64(System.UInt64,System.Int32)">
            <summary>
            Rotate a 64-bit unsigned integer to the left by <paramref name="shift"/> bits
            </summary>
            <param name="original">Original value</param>
            <param name="shift">The shift value</param>
            <returns>The rotated 64-bit integer</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.ByteHash(System.Byte[])">
            <summary>
            Compute a high-quality hash of a byte array
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.ArrayHash``1(``0[])">
            <summary>
            Compute a high-quality hash of an array
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.StringHash(System.String)">
            <summary>
            Compute high-quality hash of a string
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.SymmetricHash``1(System.Collections.Generic.IEnumerable{``0},System.UInt32)">
            <summary>
            Compute a hash that is symmetric in its arguments--that is,
            where the order of appearance of elements does not matter.
            This is useful for hashing sets, for example.
            </summary>
        </member>
        <member name="T:Akka.Util.BitArrayHelpers">
            <summary>
            Extension method class to make it easier to work with <see cref="T:System.Collections.BitArray"/> instances
            </summary>
        </member>
        <member name="M:Akka.Util.BitArrayHelpers.ToBytes(System.Collections.BitArray)">
            <summary>
            Converts a <see cref="T:System.Collections.BitArray"/> into an array of <see cref="T:System.Byte"/>
            </summary>
        </member>
        <member name="T:Akka.Util.ThreadLocalRandom">
            <summary>
            Create random numbers with Thread-specific seeds.
            
            Borrowed form Jon Skeet's brilliant C# in Depth: http://csharpindepth.com/Articles/Chapter12/Random.aspx
            </summary>
        </member>
        <member name="P:Akka.Util.ThreadLocalRandom.Current">
            <summary>
            The current random number seed available to this thread
            </summary>
        </member>
        <member name="T:Akka.Util.WildcardTree`1">
            <summary>
            A searchable nested dictionary, represents a searchable tree structure underneath
            </summary>
        </member>
        <member name="M:Akka.Util.StringFormat.SafeJoin(System.String,System.Object[])">
            <summary>
            Concatenates the values, using the specified separator between the elements.
            This method is similar to <see cref="M:System.String.Join(System.String,System.Object[])"/> except it
            formats null values as &lt;null&gt;
            </summary>
            <param name="separator">The separator.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="T:Akka.Util.Switch">
            <summary>
            An atomic switch that can be either on or off
            </summary>
        </member>
        <member name="M:Akka.Util.Switch.SwitchOff(System.Action)">
            <summary>
            Executes the provided action if the lock is on. This is done under a lock so be _very_ careful with longrunning/blocking operations in it.
            Only executes the action if the switch is on, and switches it off immediately after obtaining the lock.
            Will switch it back on if the provided action throws an exception.
            </summary>
            <returns>Returns <c>true</c> if the switch was switched off</returns>
        </member>
        <member name="M:Akka.Util.Switch.SwitchOn(System.Action)">
            <summary>
            Executes the provided action if the lock is off. This is done under a lock so be _very_ careful with longrunning/blocking operations in it.
            Only executes the action if the switch is off, and switches it on immediately after obtaining the lock.
            Will switch it back off if the provided action throws an exception.
            </summary>
            <returns>Returns <c>true</c> if the switch was switched on</returns>
        </member>
        <member name="M:Akka.Util.Switch.SwitchOff">
            <summary>
            Switches the switch off (if on). Uses locking.
            </summary>
            <returns>Returns <c>true</c> if the switch was switched off</returns>
        </member>
        <member name="M:Akka.Util.Switch.SwitchOn">
            <summary>
            Switches the switch on (if off). Uses locking.
            </summary>
            <returns>Returns <c>true</c> if the switch was switched on</returns>
        </member>
        <member name="M:Akka.Util.Switch.IfOn(System.Action)">
            <summary>
            Executes the provided action and returns if the action was executed or not, if the switch is IMMEDIATELY on (i.e. no lock involved)
            </summary>
            <param name="action">The action.</param>
            <returns>Return <c>true</c> if the switch was on</returns>
        </member>
        <member name="M:Akka.Util.Switch.IfOff(System.Action)">
            <summary>
            Executes the provided action and returns if the action was executed or not, if the switch is IMMEDIATELY off (i.e. no lock involved)
            </summary>
            <param name="action">The action.</param>
            <returns>Return <c>true</c> if the switch was off</returns>
        </member>
        <member name="M:Akka.Util.Switch.WhileOn(System.Action)">
            <summary>
            Executes the provided action and returns if the action was executed or not, if the switch is on, waiting for any pending changes to happen before (locking)
            Be careful of longrunning or blocking within the provided action as it can lead to deadlocks or bad performance
            </summary>
        </member>
        <member name="M:Akka.Util.Switch.WhileOff(System.Action)">
            <summary>
            Executes the provided action and returns if the action was executed or not, if the switch is off, waiting for any pending changes to happen before (locking)
            Be careful of longrunning or blocking within the provided action as it can lead to deadlocks or bad performance
            </summary>
        </member>
        <member name="P:Akka.Util.Switch.IsOn">
            <summary>
            Gets a value indicating whether this switch is on. No locking.
            </summary>
            <value>
              <c>true</c> if this instance is on; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Akka.Util.Switch.IsOff">
            <summary>
            Gets a value indicating whether this switch is off. No locking.
            </summary>
            <value>
              <c>true</c> if this instance is off; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Akka.Util.TypeExtensions">
            <summary>
            Class TypeExtensions.
            </summary>
        </member>
        <member name="M:Akka.Util.TypeExtensions.Implements``1(System.Type)">
            <summary>
            Returns true if <paramref name="type" /> implements/inherits <typeparamref name="T" />.
            <example><para>typeof(object[]).Implements&lt;IEnumerable&gt;() --&gt; true</para></example>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type">The type.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Util.TypeExtensions.Implements(System.Type,System.Type)">
            <summary>
            Returns true if <paramref name="type" /> implements/inherits <paramref name="moreGeneralType" />.
            <example><para>typeof(object[]).Implements(typeof(IEnumerable)) --&gt; true</para></example>
            </summary>
            <param name="type">The type.</param>
            <param name="moreGeneralType">Type of the more general.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Akka.PatternMatch">
            <summary>
            Class PatternMatch.
            </summary>
        </member>
        <member name="M:Akka.PatternMatch.Match(System.Object)">
            <summary>
            Matches the specified target.
            </summary>
            <param name="target">The target.</param>
            <returns>Case.</returns>
        </member>
        <member name="T:Akka.IMatchResult">
            <summary>
            Interface IMatchResult
            </summary>
        </member>
        <member name="P:Akka.IMatchResult.WasHandled">
            <summary>
            Gets a value indicating whether [was handled].
            </summary>
            <value><c>true</c> if [was handled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Akka.Case">
            <summary>
            Class Case.
            </summary>
        </member>
        <member name="F:Akka.Case._message">
            <summary>
            The _message
            </summary>
        </member>
        <member name="F:Akka.Case._handled">
            <summary>
            The _handled
            </summary>
        </member>
        <member name="P:Akka.Case.WasHandled">
            <summary>
            Gets a value indicating whether [was handled].
            </summary>
            <value><c>true</c> if [was handled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Akka.Case.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Case"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Case.With``1(System.Action)">
            <summary>
            Withes the specified action.
            </summary>
            <typeparam name="TMessage">The type of the t message.</typeparam>
            <param name="action">The action.</param>
            <returns>Case.</returns>
        </member>
        <member name="M:Akka.Case.With``1(System.Action{``0})">
            <summary>
            Withes the specified action.
            </summary>
            <typeparam name="TMessage">The type of the t message.</typeparam>
            <param name="action">The action.</param>
            <returns>Case.</returns>
        </member>
        <member name="M:Akka.Case.Default(System.Action{System.Object})">
            <summary>
            Defaults the specified action.
            </summary>
            <param name="action">The action.</param>
            <returns>IMatchResult.</returns>
        </member>
        <member name="T:Akka.Case.AlwaysHandled">
            <summary>
            Class AlwaysHandled.
            </summary>
        </member>
        <member name="F:Akka.Case.AlwaysHandled.Instance">
            <summary>
            The instance
            </summary>
        </member>
        <member name="M:Akka.Case.AlwaysHandled.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Akka.Case.AlwaysHandled"/> class from being created.
            </summary>
        </member>
        <member name="P:Akka.Case.AlwaysHandled.WasHandled">
            <summary>
            Gets a value indicating whether [was handled].
            </summary>
            <value><c>true</c> if [was handled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Akka.Tools.MatchHandler.ILambdaExpressionCompiler.Compile(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Produces a delegate that represents the lambda expression.
            </summary>
            <param name="expression">The expression to compile</param>
            <returns>A delegate containing the compiled version of the lambda.</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.ILambdaExpressionCompiler.CompileToMethod(System.Linq.Expressions.LambdaExpression,System.Reflection.Emit.MethodBuilder)">
            <summary>
            Compiles the lambda into a method definition.
            </summary>
            <param name="expression">The expression to compile</param>
            <param name="method">A <see cref="T:System.Reflection.Emit.MethodBuilder"/> which will be used to hold the lambda's IL.</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.IPartialActionBuilder.Build``1(Akka.Tools.MatchHandler.CompiledMatchHandlerWithArguments)">
            <summary>
            Builds the specified delegate and arguments to a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1"/>
            <para>If the number of arguments are 0, the delegate should be a <see cref="T:System.Func`1">Func&lt;<typeparamref name="T"/>,bool&gt;</see></para>
            <para>If the number of arguments are 1, the delegate should be a <see cref="T:System.Func`2">Func&lt;<typeparamref name="T"/>,T1,bool&gt;</see></para>
            <para>...</para>
            <para>If the number of arguments are n, the delegate should be a Func&lt;<typeparamref name="T"/>,T1,...,Tn,bool&gt;</para>
            <para>The maximum number of arguments i.e. n in the above example is therefore <see cref="F:Akka.Tools.MatchHandler.PartialActionBuilder.MaxNumberOfArguments"/>=14</para>
            <para>Given a delegate deleg of type Func&lt;<typeparamref name="T"/>,T1,...,Tn,bool&gt; and args [a_1,...a_n] then 
            the delegate corresponding to this code is returned:
            <example>(value) => deleg(value,a_1, ..., a_n)</example>
            </para>
            </summary>
            <typeparam name="T">The type of the value parameter in to the returned <see cref="T:Akka.Tools.MatchHandler.PartialAction`1"/></typeparam>
            <param name="handlerAndArgs">The handler, i.e. a Func&lt;<typeparamref name="T"/>,T1,...,Tn,bool&gt; and arguments [a_1,...a_n].</param>
            <returns>Returns a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1"/> that calls the delegate with the arguments.</returns>
        </member>
        <member name="F:Akka.Tools.MatchHandler.PartialActionBuilder.MaxNumberOfArguments">
            <summary>
            The maximum number of arguments=15 not including the obligatory first value argument in a partial action. 
            16 is the maximum number of args in a Func, see <see cref="T:System.Func`17"/>
            </summary>
        </member>
        <member name="F:Akka.Tools.MatchHandler.HandlerKind.Action">
            <summary>The handler is a Action&lt;T&gt;</summary>
        </member>
        <member name="F:Akka.Tools.MatchHandler.HandlerKind.ActionWithPredicate">
            <summary>The handler is a Action&lt;T&gt; and a Predicate&lt;T&gt; is specified</summary>
        </member>
        <member name="F:Akka.Tools.MatchHandler.HandlerKind.Func">
            <summary>The handler is a Func&lt;T, bool&gt;</summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Match``1(System.Action{``0},System.Predicate{``0})">
            <summary>
            Adds a handler that is called if the item being matched is of type <typeparamref name="T"/>
            and <paramref name="shouldHandle"/>, if it has been specified, returns <c>true</c>.
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type that it must match in order for <paramref name="handler"/> to be called.</typeparam>
            <param name="handler">The handler that is invoked when everything matches.</param>
            <param name="shouldHandle">An optional predicate to test if the item matches. If it returns <c>true</c> the <paramref name="handler"/> is invoked.</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Match(System.Type,System.Action{`0},System.Predicate{`0})">
            <summary>
            Adds a handler that is called if the item being matched is of type <paramref name="handlesType"/>
            and <paramref name="shouldHandle"/>, if it has been specified, returns <c>true</c>.
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
            <param name="handlesType">The type that it must match in order for <paramref name="handler"/> to be called.</param>
            <param name="handler">The handler that is invoked when everything matches.</param>
            <param name="shouldHandle">An optional predicate to test if the item matches. If it returns <c>true</c> the <paramref name="handler"/> is invoked.</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Match``1(System.Func{``0,System.Boolean})">
            <summary>
            Adds a handler that is called if the item being matched is of type <typeparamref name="T"/>.
            The handler should return <c>true</c> if the item sent in matched and was handled.
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type that it must match in order for <paramref name="handler"/> to be called.</typeparam>
            <param name="handler">The handler that is invoked. It should return <c>true</c> if the item sent in matched and was handled.</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Match(System.Type,System.Func{`0,System.Boolean})">
            <summary>
            Adds a handler that is called if the item being matched is of type <paramref name="handlesType"/>.
            The handler should return <c>true</c> if the item sent in matched and was handled.
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
            <param name="handlesType">The type that it must match in order for <paramref name="handler"/> to be called.</param>
            <param name="handler">The handler that is invoked. It should return <c>true</c> if the item sent in matched and was handled.</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.MatchAny(System.Action{`0})">
            <summary>
            Adds a handler that is invoked no matter the type the item being matched is.
            <remarks>Note that since this matches all items, no more handlers may be added after this one.</remarks>
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Build">
            <summary>
            Builds all added handlers and returns a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1"/>.
            </summary>
            <returns>Returns a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1"/></returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.MatchBuilderSignature">
            <summary>
            This class contains the handled <see cref="T:System.Type">Types</see> and <see cref="T:Akka.Tools.MatchHandler.HandlerKind">HandlerKinds</see> 
            that has been added to a <see cref="T:Akka.Tools.MatchHandler.MatchBuilder"/>.
            Two signatures are equal if they contain the same <see cref="T:System.Type">Types</see> and <see cref="T:Akka.Tools.MatchHandler.HandlerKind">HandlerKinds</see>
            in the same order.
            </summary>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialAction`1">
            <summary>
            An action that returns <c>true</c> if the <paramref name="item"/> was handled.
            </summary>
            <typeparam name="T">The type of the argument</typeparam>
            <param name="item">The argument.</param>
            <returns>Returns <c>true</c> if the <paramref name="item"/> was handled</returns>
        </member>
        <member name="T:Helios.Concurrency.ThreadType">
            <summary>
            The type of threads to use - either foreground or background threads.
            </summary>
        </member>
        <member name="T:Helios.Concurrency.DedicatedThreadPoolSettings">
            <summary>
            Provides settings for a dedicated thread pool
            </summary>
        </member>
        <member name="F:Helios.Concurrency.DedicatedThreadPoolSettings.DefaultThreadType">
            <summary>
            Background threads are the default thread type
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.NumThreads">
            <summary>
            The total number of threads to run in this thread pool.
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.ThreadType">
            <summary>
            The type of threads to run in this thread pool.
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.ApartmentState">
            <summary>
            Apartment state for threads to run in this thread pool
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.DeadlockTimeout">
            <summary>
            Interval to check for thread deadlocks.
            
            If a thread takes longer than <see cref="P:Helios.Concurrency.DedicatedThreadPoolSettings.DeadlockTimeout"/> it will be aborted
            and replaced.
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.ThreadMaxStackSize">
            <summary>
            Gets the thread stack size, 0 represents the default stack size.
            </summary>
        </member>
        <member name="T:Helios.Concurrency.DedicatedThreadPoolTaskScheduler">
            <summary>
            TaskScheduler for working with a <see cref="T:Helios.Concurrency.DedicatedThreadPool"/> instance
            </summary>
        </member>
        <member name="F:Helios.Concurrency.DedicatedThreadPoolTaskScheduler._parallelWorkers">
            <summary>
            Number of tasks currently running
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolTaskScheduler.MaximumConcurrencyLevel">
            <summary>
            Level of concurrency is directly equal to the number of threads
            in the <see cref="T:Helios.Concurrency.DedicatedThreadPool"/>.
            </summary>
        </member>
        <member name="T:Helios.Concurrency.DedicatedThreadPool">
            <summary>
            An instanced, dedicated thread pool.
            </summary>
        </member>
    </members>
</doc>
